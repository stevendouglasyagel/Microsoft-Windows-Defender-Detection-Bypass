/*! @azure/msal-common v1.0.0-beta.0 2020-03-31 */
'use strict';
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * AuthErrorMessage class containing string constants used by error codes and messages.
 */
var AuthErrorMessage = {
    unexpectedError: {
        code: "unexpected_error",
        desc: "Unexpected error in authentication."
    }
};
/**
 * General error class thrown by the MSAL.js library.
 */
var AuthError = /** @class */ (function (_super) {
    __extends(AuthError, _super);
    function AuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorMessage) || this;
        Object.setPrototypeOf(_this, AuthError.prototype);
        _this.errorCode = errorCode;
        _this.errorMessage = errorMessage;
        _this.name = "AuthError";
        return _this;
    }
    /**
     * Creates an error that is thrown when something unexpected happens in the library.
     * @param errDesc
     */
    AuthError.createUnexpectedError = function (errDesc) {
        return new AuthError(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
    };
    return AuthError;
}(Error));

var name = "@azure/msal-common";
var author = {
	name: "Microsoft",
	email: "nugetaad@microsoft.com",
	url: "https://www.microsoft.com"
};
var license = "MIT";
var repository = {
	type: "git",
	url: "https://github.com/AzureAD/microsoft-authentication-library-for-js.git"
};
var version = "1.0.0-beta.0";
var description = "Microsoft Authentication Library for js";
var keywords = [
	"implicit",
	"authorization code",
	"PKCE",
	"js",
	"AAD",
	"msal",
	"oauth"
];
var main = "./dist/index.js";
var module = "./dist/index.es.js";
var types = "./dist/src/index.d.ts";
var browserslist = [
	"last 1 version",
	"> 1%",
	"maintained node versions",
	"not dead"
];
var engines = {
	node: ">=0.8.0"
};
var directories = {
	test: "test"
};
var files = [
	"dist"
];
var scripts = {
	clean: "shx rm -rf dist lib",
	"clean:coverage": "rimraf ../../.nyc_output/*",
	lint: "eslint src --ext .ts",
	test: "mocha",
	"test:coverage": "nyc --reporter=text mocha --exit",
	"test:coverage:only": "npm run clean:coverage && npm run test:coverage",
	"build:modules": "rollup -c",
	"build:modules:watch": "rollup -cw",
	build: "npm run clean && npm run lint && npm run build:modules",
	prepack: "npm run build"
};
var devDependencies = {
	"@babel/core": "^7.7.2",
	"@babel/plugin-proposal-class-properties": "^7.7.0",
	"@babel/plugin-proposal-object-rest-spread": "^7.6.2",
	"@babel/polyfill": "^7.7.0",
	"@babel/preset-env": "^7.7.1",
	"@babel/preset-typescript": "^7.7.2",
	"@babel/register": "^7.7.0",
	"@istanbuljs/nyc-config-babel": "^2.1.1",
	"@rollup/plugin-json": "^4.0.0",
	"@types/chai": "^4.2.5",
	"@types/chai-as-promised": "^7.1.2",
	"@types/mocha": "^5.2.7",
	"@types/sinon": "^7.5.0",
	"@typescript-eslint/eslint-plugin": "^2.4.0",
	"@typescript-eslint/eslint-plugin-tslint": "^2.4.0",
	"@typescript-eslint/parser": "^2.4.0",
	"babel-plugin-istanbul": "^5.2.0",
	chai: "^4.2.0",
	"chai-as-promised": "^7.1.1",
	eslint: "^6.5.1",
	husky: "^3.0.9",
	mocha: "^6.2.2",
	nyc: "^14.1.1",
	rimraf: "^3.0.2",
	rollup: "^1.24.0",
	"rollup-plugin-typescript2": "^0.24.3",
	"rollup-plugin-uglify": "^6.0.3",
	shx: "^0.3.2",
	sinon: "^7.5.0",
	tslib: "^1.10.0",
	tslint: "^5.20.0",
	typescript: "^3.6.4"
};
var dependencies = {
};
var pkg = {
	name: name,
	author: author,
	license: license,
	repository: repository,
	version: version,
	description: description,
	keywords: keywords,
	main: main,
	module: module,
	types: types,
	browserslist: browserslist,
	engines: engines,
	directories: directories,
	files: files,
	scripts: scripts,
	devDependencies: devDependencies,
	dependencies: dependencies
};

/**
 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
 */
var ClientAuthErrorMessage = {
    clientInfoDecodingError: {
        code: "client_info_decoding_error",
        desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
    },
    clientInfoEmptyError: {
        code: "client_info_empty_error",
        desc: "The client info was empty. Please review the trace to determine the root cause."
    },
    idTokenParsingError: {
        code: "id_token_parsing_error",
        desc: "ID token cannot be parsed. Please review stack trace to determine root cause."
    },
    nullOrEmptyIdToken: {
        code: "null_or_empty_id_token",
        desc: "The idToken is null or empty. Please review the trace to determine the root cause."
    },
    tokenRequestCacheError: {
        code: "token_request_cache_error",
        desc: "The token request could not be fetched from the cache correctly."
    },
    endpointResolutionError: {
        code: "endpoints_resolution_error",
        desc: "Error: could not resolve endpoints. Please check network and try again."
    },
    invalidAuthorityType: {
        code: "invalid_authority_type",
        desc: "The given authority is not a valid type of authority supported by MSAL. Please review the trace to determine the root cause."
    },
    hashNotDeserialized: {
        code: "hash_not_deserialized",
        desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
    },
    blankGuidGenerated: {
        code: "blank_guid_generated",
        desc: "The guid generated was blank. Please review the trace to determine the root cause."
    },
    stateMismatchError: {
        code: "state_mismatch",
        desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
    },
    nonceMismatchError: {
        code: "nonce_mismatch",
        desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
    },
    accountMismatchError: {
        code: "account_mismatch",
        desc: "The cached account and account which made the token request do not match."
    },
    invalidIdToken: {
        code: "invalid_id_token",
        desc: "Invalid ID token format."
    },
    noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
    },
    cacheParseError: {
        code: "cache_parse_error",
        desc: "Could not parse cache key."
    },
    userLoginRequiredError: {
        code: "user_login_error",
        desc: "User login is required."
    },
    multipleMatchingTokens: {
        code: "multiple_matching_tokens",
        desc: "The cache contains multiple tokens satisfying the requirements. " +
            "Call AcquireToken again providing more requirements such as authority, resource, or account."
    },
    tokenRequestCannotBeMade: {
        code: "request_cannot_be_made",
        desc: "Token request cannot be made without authorization code or refresh token."
    },
    appendEmptyScopeError: {
        code: "cannot_append_empty_scope",
        desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
    },
    removeEmptyScopeError: {
        code: "cannot_remove_empty_scope",
        desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
    },
    appendScopeSetError: {
        code: "cannot_append_scopeset",
        desc: "Cannot append ScopeSet due to error."
    },
    emptyInputScopeSetError: {
        code: "empty_input_scopeset",
        desc: "Empty input ScopeSet cannot be processed."
    }
};
/**
 * Error thrown when there is an error in the client code running on the browser.
 */
var ClientAuthError = /** @class */ (function (_super) {
    __extends(ClientAuthError, _super);
    function ClientAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientAuthError";
        Object.setPrototypeOf(_this, ClientAuthError.prototype);
        return _this;
    }
    /**
     * Creates an error thrown when client info object doesn't decode correctly.
     * @param caughtError
     */
    ClientAuthError.createClientInfoDecodingError = function (caughtError) {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
    };
    /**
     * Creates an error thrown if the client info is empty.
     * @param rawClientInfo
     */
    ClientAuthError.createClientInfoEmptyError = function (rawClientInfo) {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code, ClientAuthErrorMessage.clientInfoEmptyError.desc + " Given Object: " + rawClientInfo);
    };
    /**
     * Creates an error thrown when the id token extraction errors out.
     * @param err
     */
    ClientAuthError.createIdTokenParsingError = function (caughtExtractionError) {
        return new ClientAuthError(ClientAuthErrorMessage.idTokenParsingError.code, ClientAuthErrorMessage.idTokenParsingError.desc + " Failed with error: " + caughtExtractionError);
    };
    /**
     * Creates an error thrown when the id token string is null or empty.
     * @param invalidRawTokenString
     */
    ClientAuthError.createIdTokenNullOrEmptyError = function (invalidRawTokenString) {
        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyIdToken.code, ClientAuthErrorMessage.nullOrEmptyIdToken.desc + " Raw ID Token Value: " + invalidRawTokenString);
    };
    /**
     * Creates an error thrown when the token request could not be retrieved from the cache
     * @param errDetail
     */
    ClientAuthError.createTokenRequestCacheError = function (errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCacheError.code, ClientAuthErrorMessage.tokenRequestCacheError.desc + " Error Detail: " + errDetail);
    };
    /**
     * Creates an error thrown when the endpoint discovery doesn't complete correctly.
     */
    ClientAuthError.createEndpointDiscoveryIncompleteError = function (errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
    };
    /**
     * Creates an error thrown if authority type is not valid.
     * @param invalidAuthorityError
     */
    ClientAuthError.createInvalidAuthorityTypeError = function (givenUrl) {
        return new ClientAuthError(ClientAuthErrorMessage.invalidAuthorityType.code, ClientAuthErrorMessage.invalidAuthorityType.desc + " Given Url: " + givenUrl);
    };
    /**
     * Creates an error thrown when the hash cannot be deserialized.
     * @param invalidAuthorityError
     */
    ClientAuthError.createHashNotDeserializedError = function (hashParamObj) {
        return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
    };
    /**
     * Creates an error thrown when two states do not match.
     */
    ClientAuthError.createStateMismatchError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
    };
    /**
     * Creates an error thrown when the nonce does not match.
     */
    ClientAuthError.createNonceMismatchError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
    };
    /**
     * Creates an error thrown when the cached account and response account do not match.
     */
    ClientAuthError.createAccountMismatchError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.accountMismatchError.code, ClientAuthErrorMessage.accountMismatchError.desc);
    };
    /**
     * Throws error if idToken is not correctly formed
     * @param idToken
     */
    ClientAuthError.createInvalidIdTokenError = function (idToken) {
        return new ClientAuthError(ClientAuthErrorMessage.invalidIdToken.code, ClientAuthErrorMessage.invalidIdToken.desc + " Given token: " + JSON.stringify(idToken));
    };
    /**
     * Creates an error thrown when the authorization code required for a token request is null or empty.
     */
    ClientAuthError.createNoTokensFoundError = function (scopes) {
        return new ClientAuthError(ClientAuthErrorMessage.noTokensFoundError.code, ClientAuthErrorMessage.noTokensFoundError.desc + " Scopes: " + scopes);
    };
    /**
     * Creates an error in cache parsing.
     */
    ClientAuthError.createCacheParseError = function (cacheKey) {
        return new ClientAuthError(ClientAuthErrorMessage.cacheParseError.code, ClientAuthErrorMessage.cacheParseError.desc + " Cache key: " + cacheKey);
    };
    /**
     * Throws error when renewing token without login.
     */
    ClientAuthError.createUserLoginRequiredError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.userLoginRequiredError.code, ClientAuthErrorMessage.userLoginRequiredError.desc);
    };
    /**
     * Throws error when multiple tokens are in cache for the given scope.
     * @param scope
     */
    ClientAuthError.createMultipleMatchingTokensInCacheError = function (scope) {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code, "Cache error for scope " + scope + ": " + ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
    };
    /**
     * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.
     */
    ClientAuthError.createTokenRequestCannotBeMadeError = function () {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
    };
    /**
     * Throws error when attempting to append a null, undefined or empty scope to a set
     * @param givenScope
     */
    ClientAuthError.createAppendEmptyScopeToSetError = function (givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    /**
     * Throws error when attempting to append a null, undefined or empty scope to a set
     * @param givenScope
     */
    ClientAuthError.createRemoveEmptyScopeFromSetError = function (givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
    };
    /**
     * Throws error when attempting to append null or empty ScopeSet.
     * @param appendError
     */
    ClientAuthError.createAppendScopeSetError = function (appendError) {
        return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
    };
    /**
     * Throws error if ScopeSet is null or undefined.
     * @param givenScopeSet
     */
    ClientAuthError.createEmptyInputScopeSetError = function (givenScopeSet) {
        return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, ClientAuthErrorMessage.emptyInputScopeSetError.desc + " Given ScopeSet: " + givenScopeSet);
    };
    return ClientAuthError;
}(AuthError));

/**
 * @hidden
 */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    /**
     * decode a JWT
     *
     * @param jwtToken
     */
    StringUtils.decodeJwt = function (jwtToken) {
        if (StringUtils.isEmpty(jwtToken)) {
            throw ClientAuthError.createIdTokenNullOrEmptyError(jwtToken);
        }
        var idTokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
        var matches = idTokenPartsRegex.exec(jwtToken);
        if (!matches || matches.length < 4) {
            throw ClientAuthError.createIdTokenParsingError("Given token is malformed: " + JSON.stringify(jwtToken));
        }
        var crackedToken = {
            header: matches[1],
            JWSPayload: matches[2],
            JWSSig: matches[3]
        };
        return crackedToken;
    };
    /**
     * Check if a string is empty.
     *
     * @param str
     */
    StringUtils.isEmpty = function (str) {
        return (typeof str === "undefined" || !str || 0 === str.length);
    };
    /**
     * Parses string into an object.
     *
     * @param query
     */
    StringUtils.queryStringToObject = function (query) {
        var match; // Regex for replacing addition symbol with a space
        var pl = /\+/g;
        var search = /([^&=]+)=([^&]*)/g;
        var decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); };
        var obj = {};
        match = search.exec(query);
        while (match) {
            obj[decode(match[1])] = decode(match[2]);
            match = search.exec(query);
        }
        return obj;
    };
    /**
     * Trims entries and converts them to lower case.
     *
     * @param arr
     */
    StringUtils.trimAndConvertArrayEntriesToLowerCase = function (arr) {
        return arr.map(function (entry) { return entry.trim().toLowerCase(); });
    };
    /**
     * Removes empty strings from array
     * @param arr
     */
    StringUtils.removeEmptyStringsFromArray = function (arr) {
        return arr.filter(function (entry) {
            return !StringUtils.isEmpty(entry);
        });
    };
    return StringUtils;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Log message level.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warning"] = 1] = "Warning";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
})(LogLevel || (LogLevel = {}));
/**
 * Class which facilitates logging of messages to a specific place.
 */
var Logger = /** @class */ (function () {
    function Logger(loggerOptions) {
        // Current log level, defaults to info.
        this.level = LogLevel.Info;
        if (loggerOptions) {
            this.localCallback = loggerOptions.loggerCallback;
            this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled;
            this.level = loggerOptions.logLevel;
        }
    }
    /**
     * Log message with required options.
     */
    Logger.prototype.logMessage = function (logMessage, options) {
        if ((options.logLevel > this.level) || (!this.piiLoggingEnabled && options.containsPii)) {
            return;
        }
        var timestamp = new Date().toUTCString();
        var logHeader = StringUtils.isEmpty(this.correlationId) ? "[" + timestamp + "] : " : "[" + timestamp + "] : [" + this.correlationId + "]";
        var log = logHeader + " : " + pkg.version + " : " + LogLevel[options.logLevel] + " - " + logMessage;
        this.executeCallback(options.logLevel, log, options.containsPii);
    };
    /**
     * Execute callback with message.
     */
    Logger.prototype.executeCallback = function (level, message, containsPii) {
        if (this.localCallback) {
            this.localCallback(level, message, containsPii);
        }
    };
    /**
     * Logs error messages.
     */
    Logger.prototype.error = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Error,
            containsPii: false,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs error messages with PII.
     */
    Logger.prototype.errorPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Error,
            containsPii: true,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs warning messages.
     */
    Logger.prototype.warning = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Warning,
            containsPii: false,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs warning messages with PII.
     */
    Logger.prototype.warningPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Warning,
            containsPii: true,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs info messages.
     */
    Logger.prototype.info = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Info,
            containsPii: false,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs info messages with PII.
     */
    Logger.prototype.infoPii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Info,
            containsPii: true,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs verbose messages.
     */
    Logger.prototype.verbose = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Verbose,
            containsPii: false,
            correlationId: correlationId || ""
        });
    };
    /**
     * Logs verbose messages with PII.
     */
    Logger.prototype.verbosePii = function (message, correlationId) {
        this.logMessage(message, {
            logLevel: LogLevel.Verbose,
            containsPii: true,
            correlationId: correlationId || ""
        });
    };
    /**
     * Returns whether PII Logging is enabled or not.
     */
    Logger.prototype.isPiiLoggingEnabled = function () {
        return this.piiLoggingEnabled || false;
    };
    return Logger;
}());

// Token renewal offset default in seconds
var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
// Default module system options
var DEFAULT_SYSTEM_OPTIONS = {
    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
    telemetry: null
};
// Default logger implementation
var DEFAULT_LOGGER_IMPLEMENTATION = {
    loggerCallback: function () {
        var notImplErr = "Logger - loggerCallbackInterface() has not been implemented.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    piiLoggingEnabled: false,
    logLevel: LogLevel.Info
};
// Default storage implementation
var DEFAULT_STORAGE_IMPLEMENTATION = {
    clear: function () {
        var notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    containsKey: function () {
        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    getItem: function () {
        var notImplErr = "Storage interface - getItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    getKeys: function () {
        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    removeItem: function () {
        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    setItem: function () {
        var notImplErr = "Storage interface - setItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
    }
};
// Default network implementation
var DEFAULT_NETWORK_IMPLEMENTATION = {
    sendGetRequestAsync: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    },
    sendPostRequestAsync: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    }
};
// Default crypto implementation
var DEFAULT_CRYPTO_IMPLEMENTATION = {
    createNewGuid: function () {
        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    base64Decode: function () {
        var notImplErr = "Crypto interface - base64Decode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    base64Encode: function () {
        var notImplErr = "Crypto interface - base64Encode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
    },
    generatePkceCodes: function () {
        return __awaiter(this, void 0, void 0, function () {
            var notImplErr;
            return __generator(this, function (_a) {
                notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
            });
        });
    }
};
/**
 * Function that sets the default options when not explicitly configured from app developer
 *
 * @param TStorageOptions
 * @param TSystemOptions
 * @param TFrameworkOptions
 *
 * @returns MsalConfiguration object
 */
function buildModuleConfiguration(_a) {
    var userSystemOptions = _a.systemOptions, userLoggerOption = _a.loggerOptions, storageImplementation = _a.storageInterface, networkImplementation = _a.networkInterface, cryptoImplementation = _a.cryptoInterface;
    var overlayedConfig = {
        systemOptions: userSystemOptions || DEFAULT_SYSTEM_OPTIONS,
        loggerOptions: userLoggerOption || DEFAULT_LOGGER_IMPLEMENTATION,
        storageInterface: storageImplementation || DEFAULT_STORAGE_IMPLEMENTATION,
        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION
    };
    return overlayedConfig;
}

/**
 * Access token cache item which is used to manage tokens and token renewal.
 */
var AccessTokenCacheItem = /** @class */ (function () {
    function AccessTokenCacheItem(key, value) {
        this.key = key;
        this.value = value;
    }
    return AccessTokenCacheItem;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Constants = {
    LIBRARY_NAME: "MSAL.JS",
    // Prefix for all library cache entries
    CACHE_PREFIX: "msal",
    // default authority
    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common",
    // Default AAD Instance Discovery Endpoint
    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance",
    // Resource delimiter - used for certain cache entries
    RESOURCE_DELIM: "|",
    // Placeholder for non-existent account ids/objects
    NO_ACCOUNT: "NO_ACCOUNT",
    // Claims
    CLAIMS: "claims",
    // Consumer UTID
    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
    // Default scopes
    OPENID_SCOPE: "openid",
    PROFILE_SCOPE: "profile",
    OFFLINE_ACCESS_SCOPE: "offline_access",
    // Default response type for authorization code flow
    CODE_RESPONSE_TYPE: "code",
    CODE_GRANT_TYPE: "authorization_code",
    RT_GRANT_TYPE: "refresh_token",
    FRAGMENT_RESPONSE_MODE: "fragment",
    S256_CODE_CHALLENGE_METHOD: "S256",
    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded"
};
/**
 * Request header names
 */
var HEADER_NAMES;
(function (HEADER_NAMES) {
    HEADER_NAMES["CONTENT_TYPE"] = "Content-Type";
})(HEADER_NAMES || (HEADER_NAMES = {}));
/**
 * Temporary cache keys for MSAL, deleted after any request.
 */
var TemporaryCacheKeys;
(function (TemporaryCacheKeys) {
    TemporaryCacheKeys["AUTHORITY"] = "authority";
    TemporaryCacheKeys["ACQUIRE_TOKEN_ACCOUNT"] = "acquireToken.account";
    TemporaryCacheKeys["SESSION_STATE"] = "session.state";
    TemporaryCacheKeys["REQUEST_STATE"] = "request.state";
    TemporaryCacheKeys["NONCE_IDTOKEN"] = "nonce.idtoken";
    TemporaryCacheKeys["ORIGIN_URI"] = "request.origin";
    TemporaryCacheKeys["RENEW_STATUS"] = "token.renew.status";
    TemporaryCacheKeys["URL_HASH"] = "urlHash";
    TemporaryCacheKeys["REQUEST_PARAMS"] = "request.params";
    TemporaryCacheKeys["SCOPES"] = "scopes";
})(TemporaryCacheKeys || (TemporaryCacheKeys = {}));
/**
 * Persistent cache keys MSAL which stay while user is logged in.
 */
var PersistentCacheKeys;
(function (PersistentCacheKeys) {
    PersistentCacheKeys["ID_TOKEN"] = "idtoken";
    PersistentCacheKeys["CLIENT_INFO"] = "client.info";
    PersistentCacheKeys["ADAL_ID_TOKEN"] = "adal.idtoken";
    PersistentCacheKeys["ERROR"] = "error";
    PersistentCacheKeys["ERROR_DESC"] = "error.description";
})(PersistentCacheKeys || (PersistentCacheKeys = {}));
/**
 * List of pre-established trusted host URLs.
 */
var AADTrustedHostList = [
    "login.windows.net",
    "login.chinacloudapi.cn",
    "login.cloudgovapi.us",
    "login.microsoftonline.com",
    "login.microsoftonline.de",
    "login.microsoftonline.us"
];
/**
 * String constants related to AAD Authority
 */
var AADAuthorityConstants;
(function (AADAuthorityConstants) {
    AADAuthorityConstants["COMMON"] = "common";
    AADAuthorityConstants["ORGANIZATIONS"] = "organizations";
    AADAuthorityConstants["CONSUMERS"] = "consumers";
})(AADAuthorityConstants || (AADAuthorityConstants = {}));
/**
 * Keys in the hashParams sent by AAD Server
 */
var AADServerParamKeys;
(function (AADServerParamKeys) {
    AADServerParamKeys["CLIENT_ID"] = "client_id";
    AADServerParamKeys["RESOURCE"] = "resource";
    AADServerParamKeys["REDIRECT_URI"] = "redirect_uri";
    AADServerParamKeys["RESPONSE_TYPE"] = "response_type";
    AADServerParamKeys["RESPONSE_MODE"] = "response_mode";
    AADServerParamKeys["GRANT_TYPE"] = "grant_type";
    AADServerParamKeys["CLAIMS"] = "claims";
    AADServerParamKeys["SCOPE"] = "scope";
    AADServerParamKeys["ERROR"] = "error";
    AADServerParamKeys["ERROR_DESCRIPTION"] = "error_description";
    AADServerParamKeys["ACCESS_TOKEN"] = "access_token";
    AADServerParamKeys["ID_TOKEN"] = "id_token";
    AADServerParamKeys["REFRESH_TOKEN"] = "refresh_token";
    AADServerParamKeys["EXPIRES_IN"] = "expires_in";
    AADServerParamKeys["STATE"] = "state";
    AADServerParamKeys["NONCE"] = "nonce";
    AADServerParamKeys["PROMPT"] = "prompt";
    AADServerParamKeys["SESSION_STATE"] = "session_state";
    AADServerParamKeys["CLIENT_INFO"] = "client_info";
    AADServerParamKeys["CODE"] = "code";
    AADServerParamKeys["CODE_CHALLENGE"] = "code_challenge";
    AADServerParamKeys["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
    AADServerParamKeys["CODE_VERIFIER"] = "code_verifier";
    AADServerParamKeys["CLIENT_REQUEST_ID"] = "client-request-id";
    AADServerParamKeys["X_CLIENT_SKU"] = "x-client-SKU";
    AADServerParamKeys["X_CLIENT_VER"] = "x-client-Ver";
    AADServerParamKeys["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
})(AADServerParamKeys || (AADServerParamKeys = {}));
/**
 * IdToken claim string constants
 */
var IdTokenClaimName;
(function (IdTokenClaimName) {
    IdTokenClaimName["ISSUER"] = "iss";
    IdTokenClaimName["OBJID"] = "oid";
    IdTokenClaimName["SUBJECT"] = "sub";
    IdTokenClaimName["TENANTID"] = "tid";
    IdTokenClaimName["VERSION"] = "ver";
    IdTokenClaimName["PREF_USERNAME"] = "preferred_username";
    IdTokenClaimName["NAME"] = "name";
    IdTokenClaimName["NONCE"] = "nonce";
    IdTokenClaimName["EXPIRATION"] = "exp";
    IdTokenClaimName["HOME_OBJID"] = "home_oid";
    IdTokenClaimName["SESSIONID"] = "sid";
    IdTokenClaimName["CLOUD_INSTANCE_HOSTNAME"] = "cloud_instance_host_name";
})(IdTokenClaimName || (IdTokenClaimName = {}));
/**
 * we considered making this "enum" in the request instead of string, however it looks like the allowed list of
 * prompt values kept changing over past couple of years. There are some undocumented prompt values for some
 * internal partners too, hence the choice of generic "string" type instead of the "enum"
 */
var PromptValue = {
    LOGIN: "login",
    SELECT_ACCOUNT: "select_account",
    CONSENT: "consent",
    NONE: "none",
};
/**
 * SSO Types - generated to populate hints
 */
var SSOTypes;
(function (SSOTypes) {
    SSOTypes["ACCOUNT"] = "account";
    SSOTypes["SID"] = "sid";
    SSOTypes["LOGIN_HINT"] = "login_hint";
    SSOTypes["ID_TOKEN"] = "id_token";
    SSOTypes["DOMAIN_HINT"] = "domain_hint";
    SSOTypes["ORGANIZATIONS"] = "organizations";
    SSOTypes["CONSUMERS"] = "consumers";
    SSOTypes["ACCOUNT_ID"] = "accountIdentifier";
    SSOTypes["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
})(SSOTypes || (SSOTypes = {}));
/**
 * Disallowed extra query parameters.
 */
var BlacklistedEQParams = [
    SSOTypes.SID,
    SSOTypes.LOGIN_HINT
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * The CacheHelpers class contains a set of helper functions used by the module to manage cache items.
 */
var CacheHelpers = /** @class */ (function () {
    function CacheHelpers(cacheImpl) {
        this.cacheStorage = cacheImpl;
    }
    /**
     * Create acquireTokenAccountKey to cache account object
     * @param accountId
     * @param state
     */
    CacheHelpers.prototype.generateAcquireTokenAccountKey = function (accountId) {
        return "" + TemporaryCacheKeys.ACQUIRE_TOKEN_ACCOUNT + Constants.RESOURCE_DELIM + accountId;
    };
    /**
     * Create authorityKey to cache authority
     * @param state
     */
    CacheHelpers.prototype.generateAuthorityKey = function (state) {
        return "" + TemporaryCacheKeys.AUTHORITY + Constants.RESOURCE_DELIM + state;
    };
    /**
     * Create Nonce key to cache nonce
     * @param state
     */
    CacheHelpers.prototype.generateNonceKey = function (state) {
        return "" + TemporaryCacheKeys.NONCE_IDTOKEN + Constants.RESOURCE_DELIM + state;
    };
    /**
     * Sets the cachekeys for and stores the account information in cache
     * @param account
     * @param state
     */
    CacheHelpers.prototype.setAccountCache = function (account) {
        // Cache acquireTokenAccountKey
        var accountId = account && account.homeAccountIdentifier ? account.homeAccountIdentifier : Constants.NO_ACCOUNT;
        var acquireTokenAccountKey = this.generateAcquireTokenAccountKey(accountId);
        this.cacheStorage.setItem(acquireTokenAccountKey, JSON.stringify(account));
    };
    /**
     * Sets the cacheKey for and stores the authority information in cache
     * @param state
     * @param authority
     */
    CacheHelpers.prototype.setAuthorityCache = function (authority, state) {
        // Cache authorityKey
        var authorityKey = this.generateAuthorityKey(state);
        this.cacheStorage.setItem(authorityKey, authority.canonicalAuthority);
    };
    /**
     * Updates account, authority, and state in cache
     * @param serverAuthenticationRequest
     * @param account
     */
    CacheHelpers.prototype.updateCacheEntries = function (serverAuthenticationRequest, account) {
        // Cache account and state
        if (account) {
            this.setAccountCache(account);
        }
        // Cache the request state
        this.cacheStorage.setItem(TemporaryCacheKeys.REQUEST_STATE, serverAuthenticationRequest.state);
        // Cache the nonce
        this.cacheStorage.setItem(this.generateNonceKey(serverAuthenticationRequest.state), serverAuthenticationRequest.nonce);
        // Cache authorityKey
        this.setAuthorityCache(serverAuthenticationRequest.authorityInstance, serverAuthenticationRequest.state);
    };
    /**
     * Reset all temporary cache items
     * @param state
     */
    CacheHelpers.prototype.resetTempCacheItems = function (state) {
        var _this = this;
        // check state and remove associated cache items
        this.cacheStorage.getKeys().forEach(function (key) {
            if (!StringUtils.isEmpty(state) && key.indexOf(state) !== -1) {
                var splitKey = key.split(Constants.RESOURCE_DELIM);
                var keyState = splitKey.length > 1 ? splitKey[splitKey.length - 1] : null;
                if (keyState === state) {
                    _this.cacheStorage.removeItem(key);
                }
            }
        });
        // delete generic interactive request parameters
        this.cacheStorage.removeItem(TemporaryCacheKeys.REQUEST_STATE);
        this.cacheStorage.removeItem(TemporaryCacheKeys.REQUEST_PARAMS);
        this.cacheStorage.removeItem(TemporaryCacheKeys.ORIGIN_URI);
    };
    /**
     * Get all access tokens in the cache
     * @param clientId
     * @param homeAccountIdentifier
     */
    CacheHelpers.prototype.getAllAccessTokens = function (clientId, authority, resource, homeAccountIdentifier) {
        var _this = this;
        var results = this.cacheStorage.getKeys().reduce(function (tokens, key) {
            var keyMatches = key.match(clientId) && key.match(authority) && key.match(resource) && key.match(homeAccountIdentifier);
            if (keyMatches) {
                var value = _this.cacheStorage.getItem(key);
                if (value) {
                    try {
                        var parseAtKey = JSON.parse(key);
                        if (_this.checkForExactKeyMatch(parseAtKey, clientId, authority, resource, homeAccountIdentifier)) {
                            var newAccessTokenCacheItem = new AccessTokenCacheItem(parseAtKey, JSON.parse(value));
                            return tokens.concat([newAccessTokenCacheItem]);
                        }
                    }
                    catch (e) {
                        throw ClientAuthError.createCacheParseError(key);
                    }
                }
            }
            return tokens;
        }, []);
        return results;
    };
    /**
     * Remove all access tokens in the cache
     * @param clientId
     * @param homeAccountIdentifier
     */
    CacheHelpers.prototype.removeAllAccessTokens = function (clientId, authority, resource, homeAccountIdentifier) {
        var _this = this;
        this.cacheStorage.getKeys().forEach(function (key) {
            var keyMatches = key.match(clientId) && key.match(authority) && key.match(resource) && key.match(homeAccountIdentifier);
            if (keyMatches) {
                try {
                    var parseAtKey = JSON.parse(key);
                    if (_this.checkForExactKeyMatch(parseAtKey, clientId, authority, resource, homeAccountIdentifier)) {
                        _this.cacheStorage.removeItem(key);
                    }
                }
                catch (e) {
                    throw ClientAuthError.createCacheParseError(key);
                }
            }
        });
    };
    /**
     * Checks that any parameters are exact matches for key value, since key.match in the above functions only do contains checks, not exact matches.
     * @param atKey
     * @param clientId
     * @param authority
     * @param resource
     * @param homeAccountIdentifier
     */
    CacheHelpers.prototype.checkForExactKeyMatch = function (atKey, clientId, authority, resource, homeAccountIdentifier) {
        var hasClientId = (atKey.clientId === clientId);
        // If any inputs are empty, return true so we don't fail the check.
        var hasAuthorityUri = StringUtils.isEmpty(authority) || (atKey.authority === authority);
        var hasResourceUri = StringUtils.isEmpty(resource) || (atKey.resource === resource);
        var hasHomeAccountId = StringUtils.isEmpty(homeAccountIdentifier) || (atKey.homeAccountIdentifier === homeAccountIdentifier);
        return hasClientId && hasAuthorityUri && hasResourceUri && hasHomeAccountId;
    };
    return CacheHelpers;
}());

/**
 * accountIdentifier       combination of idToken.uid and idToken.utid
 * homeAccountIdentifier   combination of clientInfo.uid and clientInfo.utid
 * userName                idToken.preferred_username
 * name                    idToken.name
 * idToken                 idToken
 * sid                     idToken.sid - session identifier
 * environment             idtoken.issuer (the authority that issues the token)
 */
var Account = /** @class */ (function () {
    /**
     * Creates an Account Object
     * @praram accountIdentifier
     * @param homeAccountIdentifier
     * @param userName
     * @param name
     * @param idToken
     * @param sid
     * @param environment
     */
    function Account(accountIdentifier, homeAccountIdentifier, idTokenClaims, rawIdToken) {
        this.accountIdentifier = accountIdentifier;
        this.homeAccountIdentifier = homeAccountIdentifier;
        this.userName = idTokenClaims.preferred_username;
        this.name = idTokenClaims.name;
        // will be deprecated soon
        this.idToken = rawIdToken;
        this.idTokenClaims = idTokenClaims;
        this.sid = idTokenClaims.sid;
        this.environment = idTokenClaims.iss;
    }
    /**
     * @param idToken
     * @param clientInfo
     */
    Account.createAccount = function (idToken, clientInfo, crypto) {
        // create accountIdentifier
        var accountIdentifier = idToken.claims.oid || idToken.claims.sub;
        // create homeAccountIdentifier
        var uid = clientInfo ? clientInfo.uid : "";
        var utid = clientInfo ? clientInfo.utid : "";
        var homeAccountIdentifier;
        if (!StringUtils.isEmpty(uid) && !StringUtils.isEmpty(utid)) {
            homeAccountIdentifier = crypto.base64Encode(uid) + "." + crypto.base64Encode(utid);
        }
        return new Account(accountIdentifier, homeAccountIdentifier, idToken.claims, idToken.rawIdToken);
    };
    /**
     * Utils function to compare two Account objects - used to check if the same user account is logged in
     *
     * @param a1: Account object
     * @param a2: Account object
     */
    Account.compareAccounts = function (a1, a2) {
        if (!(a1 && a1.homeAccountIdentifier) || !(a2 && a2.homeAccountIdentifier)) {
            return false;
        }
        return a1.homeAccountIdentifier === a2.homeAccountIdentifier;
    };
    return Account;
}());

/**
 * Id Token representation class. Parses id token string and generates claims object.
 */
var IdToken = /** @class */ (function () {
    function IdToken(rawIdToken, crypto) {
        if (StringUtils.isEmpty(rawIdToken)) {
            throw ClientAuthError.createIdTokenNullOrEmptyError(rawIdToken);
        }
        this.rawIdToken = rawIdToken;
        this.claims = IdToken.extractIdToken(rawIdToken, crypto);
    }
    /**
     * Extract IdToken by decoding the RAWIdToken
     *
     * @param encodedIdToken
     */
    IdToken.extractIdToken = function (encodedIdToken, crypto) {
        // id token will be decoded to get the username
        var decodedToken = StringUtils.decodeJwt(encodedIdToken);
        if (!decodedToken) {
            return null;
        }
        try {
            var base64IdTokenPayload = decodedToken.JWSPayload;
            // base64Decode() should throw an error if there is an issue
            var base64Decoded = crypto.base64Decode(base64IdTokenPayload);
            return JSON.parse(base64Decoded);
        }
        catch (err) {
            throw ClientAuthError.createIdTokenParsingError(JSON.stringify(err));
        }
    };
    return IdToken;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Function to build a client info object
 * @param rawClientInfo
 * @param crypto
 */
function buildClientInfo(rawClientInfo, crypto) {
    if (StringUtils.isEmpty(rawClientInfo)) {
        throw ClientAuthError.createClientInfoEmptyError(rawClientInfo);
    }
    try {
        var decodedClientInfo = crypto.base64Decode(rawClientInfo);
        return JSON.parse(decodedClientInfo);
    }
    catch (e) {
        throw ClientAuthError.createClientInfoDecodingError(e);
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * AuthModule class
 *
 * Parent object instance which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.
 *
 */
var AuthModule = /** @class */ (function () {
    function AuthModule(configuration) {
        // Set the configuration
        this.config = buildModuleConfiguration(configuration);
        // Initialize the logger
        this.logger = new Logger(this.config.loggerOptions);
        // Initialize crypto
        this.cryptoObj = this.config.cryptoInterface;
        // Initialize storage interface
        this.cacheStorage = this.config.storageInterface;
        // Initialize storage helper object
        this.cacheManager = new CacheHelpers(this.cacheStorage);
        // Set the network interface
        this.networkClient = this.config.networkInterface;
    }
    // #endregion
    // #region Getters and Setters
    /**
     * Returns the signed in account
     * (the account object is created at the time of successful login)
     * or null when no state is found
     * @returns {@link Account} - the account object stored in MSAL
     */
    AuthModule.prototype.getAccount = function () {
        if (this.account) {
            return this.account;
        }
        // Get id token and client info from cache
        var rawIdToken = this.cacheStorage.getItem(PersistentCacheKeys.ID_TOKEN);
        var rawClientInfo = this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO);
        if (!StringUtils.isEmpty(rawIdToken) && !StringUtils.isEmpty(rawClientInfo)) {
            var idToken = new IdToken(rawIdToken, this.cryptoObj);
            var clientInfo = buildClientInfo(rawClientInfo, this.cryptoObj);
            this.account = Account.createAccount(idToken, clientInfo, this.cryptoObj);
            return this.account;
        }
        // if login is not yet done, return null
        return null;
    };
    return AuthModule;
}());

var DEFAULT_AUTH_OPTIONS = {
    clientId: "",
    authority: null,
    redirectUri: "",
    postLogoutRedirectUri: ""
};
/**
 * Function that sets the default options when not explicitly configured from app developer
 *
 * @param TAuthOptions
 * @param TStorageOptions
 * @param TSystemOptions
 * @param TFrameworkOptions
 *
 * @returns TConfiguration object
 */
function buildPublicClientSPAConfiguration(_a) {
    var auth = _a.auth, loggerOptions = _a.loggerOptions, storageInterface = _a.storageInterface, networkInterface = _a.networkInterface, cryptoInterface = _a.cryptoInterface;
    var baseConfig = buildModuleConfiguration({ loggerOptions: loggerOptions, storageInterface: storageInterface, networkInterface: networkInterface, cryptoInterface: cryptoInterface });
    var overlayedConfig = __assign({ auth: __assign(__assign({}, DEFAULT_AUTH_OPTIONS), auth) }, baseConfig);
    return overlayedConfig;
}

/**
 * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.
 */
var ClientConfigurationErrorMessage = {
    redirectUriNotSet: {
        code: "redirect_uri_empty",
        desc: "A redirect URI is required for all calls, and none has been set."
    },
    postLogoutUriNotSet: {
        code: "post_logout_uri_empty",
        desc: "A post logout redirect has not been set."
    },
    claimsRequestParsingError: {
        code: "claims_request_parsing_error",
        desc: "Could not parse the given claims request object."
    },
    authorityUriInsecure: {
        code: "authority_uri_insecure",
        desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
    },
    urlParseError: {
        code: "url_parse_error",
        desc: "URL could not be parsed into appropriate segments."
    },
    urlEmptyError: {
        code: "empty_url_error",
        desc: "URL was empty or null."
    },
    emptyScopesError: {
        code: "empty_input_scopes_error",
        desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
    },
    nonArrayScopesError: {
        code: "nonarray_input_scopes_error",
        desc: "Scopes cannot be passed as non-array."
    },
    clientIdSingleScopeError: {
        code: "clientid_input_scopes_error",
        desc: "Client ID can only be provided as a single scope."
    },
    invalidPrompt: {
        code: "invalid_prompt_value",
        desc: "Supported prompt values are 'login', 'select_account', 'consent' and 'none'.  Please see here for valid configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
    },
    tokenRequestEmptyError: {
        code: "token_request_empty",
        desc: "Token request was empty and not found in cache."
    }
};
/**
 * Error thrown when there is an error in configuration of the MSAL.js library.
 */
var ClientConfigurationError = /** @class */ (function (_super) {
    __extends(ClientConfigurationError, _super);
    function ClientConfigurationError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientConfigurationError";
        Object.setPrototypeOf(_this, ClientConfigurationError.prototype);
        return _this;
    }
    /**
     * Creates an error thrown when the redirect uri is empty (not set by caller)
     */
    ClientConfigurationError.createRedirectUriEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
    };
    /**
     * Creates an error thrown when the post-logout redirect uri is empty (not set by caller)
     */
    ClientConfigurationError.createPostLogoutRedirectUriEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
    };
    /**
     * Creates an error thrown when the claims request could not be successfully parsed
     */
    ClientConfigurationError.createClaimsRequestParsingError = function (claimsRequestParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
    };
    /**
     * Creates an error thrown if authority uri is given an insecure protocol.
     * @param urlString
     */
    ClientConfigurationError.createInsecureAuthorityUriError = function (urlString) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
    };
    /**
     * Creates an error thrown if URL string does not parse into separate segments.
     * @param urlString
     */
    ClientConfigurationError.createUrlParseError = function (urlParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
    };
    /**
     * Creates an error thrown if URL string is empty or null.
     * @param urlString
     */
    ClientConfigurationError.createUrlEmptyError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
    };
    /**
     * Error thrown when scopes are not an array
     * @param inputScopes
     */
    ClientConfigurationError.createScopesNonArrayError = function (inputScopes) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.nonArrayScopesError.code, ClientConfigurationErrorMessage.nonArrayScopesError.desc + " Given Scopes: " + inputScopes);
    };
    /**
     * Error thrown when scopes are empty.
     * @param scopesValue
     */
    ClientConfigurationError.createEmptyScopesArrayError = function (inputScopes) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopesError.code, ClientConfigurationErrorMessage.emptyScopesError.desc + " Given Scopes: " + inputScopes);
    };
    /**
     * Error thrown when client id scope is not provided as single scope.
     * @param inputScopes
     */
    ClientConfigurationError.createClientIdSingleScopeError = function (inputScopes) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
    };
    /**
     * Error thrown when prompt is not an allowed type.
     * @param promptValue
     */
    ClientConfigurationError.createInvalidPromptError = function (promptValue) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
    };
    /**
     * Throws error when token request is empty and nothing cached in storage.
     */
    ClientConfigurationError.createEmptyTokenRequestError = function () {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
    };
    return ClientConfigurationError;
}(ClientAuthError));

/**
 * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes
 * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings to ensure uniqueness of strings.
 */
var ScopeSet = /** @class */ (function () {
    function ScopeSet(inputScopes, appClientId, scopesRequired) {
        this.clientId = appClientId;
        this.scopesRequired = scopesRequired;
        // Filter empty string and null/undefined array items
        var filteredInput = inputScopes ? StringUtils.removeEmptyStringsFromArray(inputScopes) : inputScopes;
        // Validate and filter scopes (validate function throws if validation fails)
        this.validateInputScopes(filteredInput);
        var scopeArr = filteredInput ? StringUtils.trimAndConvertArrayEntriesToLowerCase(__spreadArrays(filteredInput)) : [];
        this.scopes = new Set(scopeArr);
        if (!this.scopesRequired) {
            this.appendScope(this.clientId);
        }
        this.originalScopes = new Set(this.scopes);
        this.replaceDefaultScopes();
    }
    /**
     * Factory method to create ScopeSet from space-delimited string
     * @param inputScopeString
     * @param appClientId
     * @param scopesRequired
     */
    ScopeSet.fromString = function (inputScopeString, appClientId, scopesRequired) {
        inputScopeString = inputScopeString || "";
        var inputScopes = inputScopeString.split(" ");
        return new ScopeSet(inputScopes, appClientId, scopesRequired);
    };
    /**
     * Replace client id with the default scopes used for token acquisition.
     */
    ScopeSet.prototype.replaceDefaultScopes = function () {
        if (this.scopes.has(this.clientId)) {
            this.removeScope(this.clientId);
            this.appendScope(Constants.OPENID_SCOPE);
            this.appendScope(Constants.PROFILE_SCOPE);
        }
        this.appendScope(Constants.OFFLINE_ACCESS_SCOPE);
    };
    /**
     * Used to validate the scopes input parameter requested  by the developer.
     * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.
     * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not
     */
    ScopeSet.prototype.validateInputScopes = function (inputScopes) {
        if (this.scopesRequired) {
            // Check if scopes are required but not given or is an empty array
            if (!inputScopes || inputScopes.length < 1) {
                throw ClientConfigurationError.createEmptyScopesArrayError(inputScopes);
            }
        }
        // Check that scopes is an array object
        if (!Array.isArray(inputScopes)) {
            throw ClientConfigurationError.createScopesNonArrayError(inputScopes);
        }
    };
    /**
     * Check if a given scope is present in this set of scopes.
     * @param scope
     */
    ScopeSet.prototype.containsScope = function (scope) {
        return !StringUtils.isEmpty(scope) ? this.scopes.has(scope) : false;
    };
    /**
     * Check if a set of scopes is present in this set of scopes.
     * @param scopeSet
     */
    ScopeSet.prototype.containsScopeSet = function (scopeSet) {
        var _this = this;
        if (!scopeSet) {
            return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function (scope) { return _this.containsScope(scope); });
    };
    /**
     * Appends single scope if passed
     * @param newScope
     */
    ScopeSet.prototype.appendScope = function (newScope) {
        if (StringUtils.isEmpty(newScope)) {
            throw ClientAuthError.createAppendEmptyScopeToSetError(newScope);
        }
        this.scopes.add(newScope.trim().toLowerCase());
    };
    /**
     * Appends multiple scopes if passed
     * @param newScopes
     */
    ScopeSet.prototype.appendScopes = function (newScopes) {
        try {
            var newScopeSet = new ScopeSet(newScopes, this.clientId, this.scopesRequired);
            this.scopes = this.unionScopeSets(newScopeSet);
        }
        catch (e) {
            throw ClientAuthError.createAppendScopeSetError(e);
        }
    };
    /**
     * Removes element from set of scopes.
     * @param scope
     */
    ScopeSet.prototype.removeScope = function (scope) {
        if (StringUtils.isEmpty(scope)) {
            throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
        }
        this.scopes.delete(scope.trim().toLowerCase());
    };
    /**
     * Combines an array of scopes with the current set of scopes.
     * @param otherScopes
     */
    ScopeSet.prototype.unionScopeSets = function (otherScopes) {
        if (!otherScopes) {
            throw ClientAuthError.createEmptyInputScopeSetError(otherScopes);
        }
        return new Set(__spreadArrays(otherScopes.asArray(), Array.from(this.scopes)));
    };
    /**
     * Check if scopes intersect between this set and another.
     * @param otherScopes
     */
    ScopeSet.prototype.intersectingScopeSets = function (otherScopes) {
        if (!otherScopes) {
            throw ClientAuthError.createEmptyInputScopeSetError(otherScopes);
        }
        return this.unionScopeSets(otherScopes).size < (this.scopes.size + otherScopes.getScopeCount());
    };
    /**
     * Returns size of set of scopes.
     */
    ScopeSet.prototype.getScopeCount = function () {
        return this.scopes.size;
    };
    /**
     * Returns true if the set of original scopes only contained client-id
     */
    ScopeSet.prototype.isLoginScopeSet = function () {
        var hasLoginScopes = (this.originalScopes.has(this.clientId) ||
            this.originalScopes.has(Constants.OPENID_SCOPE) ||
            this.originalScopes.has(Constants.PROFILE_SCOPE));
        return this.originalScopes && hasLoginScopes;
    };
    /**
     * Returns the scopes as an array of string values
     */
    ScopeSet.prototype.asArray = function () {
        return Array.from(this.scopes);
    };
    /**
     * Returns the original scopes as an array (no extra scopes to consent)
     */
    ScopeSet.prototype.getOriginalScopesAsArray = function () {
        return Array.from(this.originalScopes);
    };
    /**
     * Prints scopes into a space-delimited string
     */
    ScopeSet.prototype.printScopes = function () {
        if (this.scopes) {
            var scopeArr = this.asArray();
            return scopeArr.join(" ");
        }
        return "";
    };
    return ScopeSet;
}());

/**
 * Function which validates claims request passed in by the user.
 * @param request
 */
function validateClaimsRequest(request) {
    if (!request.claimsRequest) {
        return;
    }
    try {
        JSON.parse(request.claimsRequest);
    }
    catch (e) {
        throw ClientConfigurationError.createClaimsRequestParsingError(e);
    }
    // TODO: More validation will be added when the server team tells us how they have actually implemented claims
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Class which provides helpers for OAuth 2.0 protocol specific values
 */
var ProtocolUtils = /** @class */ (function () {
    function ProtocolUtils() {
    }
    /**
     * Appends user state with random guid, or returns random guid.
     * @param userState
     * @param randomGuid
     */
    ProtocolUtils.setRequestState = function (userState, randomGuid) {
        return !StringUtils.isEmpty(userState) ? "" + randomGuid + Constants.RESOURCE_DELIM + userState : randomGuid;
    };
    /**
     *
     * Extracts user state value from the state sent with the authentication request.
     * @returns {string} scope.
     * @ignore
     */
    ProtocolUtils.getUserRequestState = function (serverResponseState) {
        if (!StringUtils.isEmpty(serverResponseState)) {
            var splitIndex = serverResponseState.indexOf(Constants.RESOURCE_DELIM);
            if (splitIndex > -1 && splitIndex + 1 < serverResponseState.length) {
                return serverResponseState.substring(splitIndex + 1);
            }
        }
        return "";
    };
    return ProtocolUtils;
}());

/**
 * This class extends the ServerRequestParameters class. This class validates URL request parameters, checks for SSO and generates required URL.
 */
var ServerCodeRequestParameters = /** @class */ (function () {
    function ServerCodeRequestParameters(authority, clientId, userRequest, cachedAccount, redirectUri, cryptoImpl, isLoginCall) {
        this.clientId = clientId;
        this.cryptoObj = cryptoImpl;
        this.redirectUri = redirectUri;
        // Telemetry Info
        this.xClientSku = Constants.LIBRARY_NAME;
        this.xClientVer = pkg.version;
        this.authorityInstance = authority;
        this.userRequest = userRequest;
        this.responseType = Constants.CODE_RESPONSE_TYPE;
        this.account = (userRequest && userRequest.account) || cachedAccount;
        // Set scopes, append extra scopes if there is a login call.
        this.scopes = new ScopeSet((this.userRequest && this.userRequest.scopes) || [], this.clientId, !isLoginCall);
        if (isLoginCall) {
            this.appendExtraScopes();
        }
        // Set random vars
        var randomGuid = this.cryptoObj.createNewGuid();
        this.state = ProtocolUtils.setRequestState(this.userRequest && this.userRequest.userRequestState, randomGuid);
        this.nonce = this.cryptoObj.createNewGuid();
        this.correlationId = this.userRequest.correlationId || this.cryptoObj.createNewGuid();
    }
    /**
     * Appends extraScopesToConsent if passed
     */
    ServerCodeRequestParameters.prototype.appendExtraScopes = function () {
        if (this.userRequest && this.scopes) {
            if (this.userRequest.extraScopesToConsent) {
                this.scopes.appendScopes(this.userRequest.extraScopesToConsent);
            }
        }
    };
    /**
     * Check to see if there are SSO params set in the Request
     * @param request
     */
    ServerCodeRequestParameters.prototype.hasSSOParam = function () {
        var isSSORequest = this.userRequest && (this.account || this.userRequest.sid || this.userRequest.loginHint);
        return !!this.account || !!isSSORequest;
    };
    /**
     * Adds SSO parameter to query parameters:
     * - sid of the account object used to identify the session of the user on the service
     * - login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time
     * Also does a sanity check for extraQueryParameters passed by the user to ensure no repeat queryParameters
     *
     * @param {@link Account} account - Account for which the token is requested
     * @param queryparams
     * @param {@link ServerRequestParameters}
     */
    ServerCodeRequestParameters.prototype.addSSOQueryParameters = function (adalIdToken) {
        /*
         * This is a final check for all queryParams added so far; preference order: sid > login_hint
         * sid cannot be passed along with login_hint or domain_hint, hence we check both are not populated yet in queryParameters
         */
        // preference order: account > sid > login_hint
        var serverReqParam = {};
        // if account info is passed, account.sid > account.login_hint
        if (this.account) {
            // sid can only be passed if prompt = none
            if (this.account.sid && this.userRequest && this.userRequest.prompt === PromptValue.NONE) {
                serverReqParam[SSOTypes.SID] = this.account.sid;
            }
            else if (this.account.userName) {
                serverReqParam[SSOTypes.LOGIN_HINT] = this.account.userName;
            }
        }
        // if no account info available, request.sid > request.login_hint
        else if (this.userRequest) {
            // sid from request - can only be passed if prompt = none
            if (this.userRequest.sid && this.userRequest.prompt === PromptValue.NONE) {
                serverReqParam[SSOTypes.SID] = this.userRequest.sid;
            }
            // loginHint from request
            else if (this.userRequest.loginHint) {
                serverReqParam[SSOTypes.LOGIN_HINT] = this.userRequest.loginHint;
            }
        }
        // adalIdToken retrieved from cache
        if (adalIdToken && StringUtils.isEmpty(serverReqParam[SSOTypes.SID]) && StringUtils.isEmpty(serverReqParam[SSOTypes.LOGIN_HINT])) {
            if (adalIdToken.claims && adalIdToken.claims.upn) {
                serverReqParam[SSOTypes.LOGIN_HINT] = adalIdToken.claims.upn;
            }
        }
        return serverReqParam;
    };
    /**
     * Utility to populate QueryParameters and ExtraQueryParameters to ServerRequestParamerers
     * @param adalIdTokenObject
     */
    ServerCodeRequestParameters.prototype.populateQueryParams = function (adalIdTokenObject) {
        var queryParameters = {};
        if (this.userRequest) {
            // add the prompt parameter to serverRequestParameters if passed
            if (this.userRequest.prompt) {
                this.validatePromptParameter(this.userRequest.prompt);
            }
            // Add claims challenge to serverRequestParameters if passed
            if (this.userRequest.claimsRequest) {
                validateClaimsRequest(this.userRequest);
            }
        }
        /*
         * adds sid/login_hint if an SSO Parameter is available
         * this.logger.verbose("Calling addHint parameters");
         */
        if (this.hasSSOParam() || adalIdTokenObject) {
            queryParameters = this.addSSOQueryParameters(adalIdTokenObject);
        }
        // sanity check for developer passed extraQueryParameters
        var eQParams;
        if (this.userRequest) {
            eQParams = this.sanitizeEQParams(this.userRequest, queryParameters);
        }
        // Populate the extraQueryParameters to be sent to the server
        this.queryParameters = this.generateQueryParametersString(queryParameters);
        this.extraQueryParameters = this.generateQueryParametersString(eQParams);
    };
    /**
     * Create navigation url.
     */
    ServerCodeRequestParameters.prototype.createNavigateUrl = function () {
        return __awaiter(this, void 0, void 0, function () {
            var paramStrings, authEndpoint, requestUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createParamString()];
                    case 1:
                        paramStrings = _a.sent();
                        authEndpoint = this.authorityInstance.authorizationEndpoint;
                        // if the endpoint already has queryparams, lets add to it, otherwise add the first one
                        if (authEndpoint.indexOf("?") < 0) {
                            authEndpoint += "?";
                        }
                        else {
                            authEndpoint += "&";
                        }
                        requestUrl = "" + authEndpoint + paramStrings.join("&");
                        return [2 /*return*/, requestUrl];
                }
            });
        });
    };
    /**
     * Create a query parameter string.
     */
    ServerCodeRequestParameters.prototype.createParamString = function () {
        return __awaiter(this, void 0, void 0, function () {
            var str, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        str = [];
                        str.push(AADServerParamKeys.RESPONSE_TYPE + "=" + this.responseType);
                        str.push(AADServerParamKeys.SCOPE + "=" + encodeURIComponent(this.scopes.printScopes()));
                        str.push(AADServerParamKeys.CLIENT_ID + "=" + encodeURIComponent(this.clientId));
                        str.push(AADServerParamKeys.REDIRECT_URI + "=" + encodeURIComponent(this.redirectUri));
                        str.push(AADServerParamKeys.STATE + "=" + encodeURIComponent(this.state));
                        str.push(AADServerParamKeys.NONCE + "=" + encodeURIComponent(this.nonce));
                        str.push(AADServerParamKeys.CLIENT_INFO + "=1");
                        str.push(AADServerParamKeys.X_CLIENT_SKU + "=" + this.xClientSku);
                        str.push(AADServerParamKeys.X_CLIENT_VER + "=" + this.xClientVer);
                        // Add codes here. May want to add optional step to allow for non-PKCE auth code flows
                        _a = this;
                        return [4 /*yield*/, this.cryptoObj.generatePkceCodes()];
                    case 1:
                        // Add codes here. May want to add optional step to allow for non-PKCE auth code flows
                        _a.generatedPkce = _b.sent();
                        str.push(AADServerParamKeys.CODE_CHALLENGE + "=" + encodeURIComponent(this.generatedPkce.challenge));
                        str.push(AADServerParamKeys.CODE_CHALLENGE_METHOD + "=" + Constants.S256_CODE_CHALLENGE_METHOD);
                        // Append resource
                        if (this.userRequest && this.userRequest.resource) {
                            str.push(AADServerParamKeys.RESOURCE + "=" + encodeURIComponent(this.userRequest.resource));
                        }
                        // Append prompt
                        if (this.userRequest && this.userRequest.prompt) {
                            str.push(AADServerParamKeys.PROMPT + "=" + (encodeURIComponent(this.userRequest.prompt)));
                        }
                        // Append claims request
                        if (this.userRequest && this.userRequest.claimsRequest) {
                            str.push(AADServerParamKeys.CLAIMS + "=" + encodeURIComponent(this.userRequest.claimsRequest));
                        }
                        // Append query params
                        if (this.queryParameters) {
                            str.push(this.queryParameters);
                        }
                        // Append extra query params
                        if (this.extraQueryParameters) {
                            str.push(this.extraQueryParameters);
                        }
                        str.push(AADServerParamKeys.CLIENT_REQUEST_ID + "=" + encodeURIComponent(this.correlationId));
                        str.push(AADServerParamKeys.RESPONSE_MODE + "=" + Constants.FRAGMENT_RESPONSE_MODE);
                        return [2 /*return*/, str];
                }
            });
        });
    };
    /**
     * Utility to test if valid prompt value is passed in the request
     * @param request
     */
    ServerCodeRequestParameters.prototype.validatePromptParameter = function (prompt) {
        if ([PromptValue.LOGIN, PromptValue.SELECT_ACCOUNT, PromptValue.CONSENT, PromptValue.NONE].indexOf(prompt) < 0) {
            throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
    };
    /**
     * Removes unnecessary or duplicate query parameters from extraQueryParameters
     * @param request
     */
    ServerCodeRequestParameters.prototype.sanitizeEQParams = function (request, ssoQueryParams) {
        var eQParams = request.extraQueryParameters;
        if (!eQParams) {
            return null;
        }
        if (request.claimsRequest) {
            // TODO: this.logger.error("Removed duplicate claims from extraQueryParameters. Please use either the claimsRequest field OR pass as extraQueryParameter - not both.");
            delete eQParams[Constants.CLAIMS];
        }
        // Remove any query parameters that are blacklisted
        BlacklistedEQParams.forEach(function (param) {
            if (eQParams[param]) {
                // TODO: this.logger.error("Removed duplicate " + param + " from extraQueryParameters. Please use the " + param + " field in request object.");
                delete eQParams[param];
            }
        });
        // Remove any query parameters already included in SSO params
        Object.keys(ssoQueryParams).forEach(function (key) {
            if (eQParams[key]) {
                // TODO: this.logger.error("Removed param " + key + " from extraQueryParameters since it was already present in library query parameters.")
                delete eQParams[key];
            }
            if (key === SSOTypes.SID) {
                // TODO: this.logger.error("Removed domain hint since sid was provided.")
                delete eQParams[SSOTypes.DOMAIN_HINT];
            }
        });
        return eQParams;
    };
    /**
     * Utility to generate a QueryParameterString from a Key-Value mapping of extraQueryParameters passed
     * @param extraQueryParameters
     */
    ServerCodeRequestParameters.prototype.generateQueryParametersString = function (queryParameters) {
        var paramsString = "";
        if (queryParameters) {
            Object.keys(queryParameters).forEach(function (key) {
                if (StringUtils.isEmpty(paramsString)) {
                    paramsString = key + "=" + encodeURIComponent(queryParameters[key]);
                }
                else {
                    paramsString += "&" + key + "=" + encodeURIComponent(queryParameters[key]);
                }
            });
        }
        return paramsString;
    };
    return ServerCodeRequestParameters;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class extends the ServerRequestParameters class. This class validates token request parameters and generates a form body and headers required for the request.
 */
var ServerTokenRequestParameters = /** @class */ (function () {
    function ServerTokenRequestParameters(clientId, tokenRequest, codeResponse, redirectUri, cryptoImpl, refreshToken) {
        this.clientId = clientId;
        this.cryptoObj = cryptoImpl;
        this.redirectUri = redirectUri;
        // Telemetry Info
        this.xClientSku = Constants.LIBRARY_NAME;
        this.xClientVer = pkg.version;
        this.tokenRequest = tokenRequest;
        this.codeResponse = codeResponse;
        this.refreshToken = refreshToken;
        // Set scopes, always required for token request/exchange
        this.scopes = new ScopeSet((this.tokenRequest && this.tokenRequest.scopes) || [], this.clientId, true);
        // Set correlation id
        this.correlationId = this.tokenRequest.correlationId || this.cryptoObj.createNewGuid();
    }
    /**
     * Creates headers required for token request.
     */
    ServerTokenRequestParameters.prototype.createRequestHeaders = function () {
        var headers = new Map();
        headers.set(HEADER_NAMES.CONTENT_TYPE, Constants.URL_FORM_CONTENT_TYPE);
        return headers;
    };
    /**
     * Creates string of parameters to send to server in request body.
     */
    ServerTokenRequestParameters.prototype.createRequestBody = function () {
        var paramString = this.createParamString();
        return paramString.join("&");
    };
    /**
     * Helper creates an array of key value string pairs.
     */
    ServerTokenRequestParameters.prototype.createParamString = function () {
        var str = [];
        str.push(AADServerParamKeys.CLIENT_ID + "=" + encodeURIComponent(this.clientId));
        str.push(AADServerParamKeys.SCOPE + "=" + encodeURIComponent(this.scopes.printScopes()));
        str.push(AADServerParamKeys.REDIRECT_URI + "=" + encodeURIComponent(this.redirectUri));
        // If there is a code response or refresh token, push relevant variables. Throw error otherwise.
        if (this.codeResponse) {
            str.push(AADServerParamKeys.CODE + "=" + encodeURIComponent(this.codeResponse.code));
            str.push(AADServerParamKeys.CODE_VERIFIER + "=" + encodeURIComponent(this.tokenRequest.codeVerifier));
            str.push(AADServerParamKeys.GRANT_TYPE + "=" + Constants.CODE_GRANT_TYPE);
        }
        else if (!StringUtils.isEmpty(this.refreshToken)) {
            str.push(AADServerParamKeys.REFRESH_TOKEN + "=" + this.refreshToken);
            str.push(AADServerParamKeys.GRANT_TYPE + "=" + Constants.RT_GRANT_TYPE);
        }
        else {
            throw ClientAuthError.createTokenRequestCannotBeMadeError();
        }
        return str;
    };
    return ServerTokenRequestParameters;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Utility class which exposes functions for managing date and time operations.
 */
var TimeUtils = /** @class */ (function () {
    function TimeUtils() {
    }
    /**
     * return the current time in Unix time (seconds).
     */
    TimeUtils.nowSeconds = function () {
        // Date.getTime() returns in milliseconds.
        return Math.round(new Date().getTime() / 1000.0);
    };
    return TimeUtils;
}());

/**
 * Url object class which can perform various transformations on url strings.
 */
var UrlString = /** @class */ (function () {
    function UrlString(url) {
        this._urlString = url;
        if (!StringUtils.isEmpty(this._urlString) && StringUtils.isEmpty(this.getHash())) {
            this._urlString = this.canonicalizeUri(url);
        }
        else if (StringUtils.isEmpty(this._urlString)) {
            // Throws error if url is empty
            throw ClientConfigurationError.createUrlEmptyError();
        }
    }
    Object.defineProperty(UrlString.prototype, "urlString", {
        get: function () {
            return this._urlString;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Ensure urls are lower case and end with a / character.
     * @param url
     */
    UrlString.prototype.canonicalizeUri = function (url) {
        if (url) {
            url = url.toLowerCase();
        }
        if (url && !url.endsWith("/")) {
            url += "/";
        }
        return url;
    };
    /**
     * Throws if urlString passed is not a valid authority URI string.
     */
    UrlString.prototype.validateAsUri = function () {
        // Attempts to parse url for uri components
        var components;
        try {
            components = this.getUrlComponents();
        }
        catch (e) {
            throw ClientConfigurationError.createUrlParseError(e);
        }
        // Throw error if URI or path segments are not parseable.
        if (!components.HostNameAndPort || !components.PathSegments || components.PathSegments.length < 1) {
            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        // Throw error if uri is insecure.
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
        }
    };
    /**
     * Function to remove query string params from url. Returns the new url.
     * @param url
     * @param name
     */
    UrlString.prototype.urlRemoveQueryStringParameter = function (name) {
        var regex = new RegExp("(\\&" + name + "=)[^\&]+");
        this._urlString = this.urlString.replace(regex, "");
        // name=value&
        regex = new RegExp("(" + name + "=)[^\&]+&");
        this._urlString = this.urlString.replace(regex, "");
        // name=value
        regex = new RegExp("(" + name + "=)[^\&]+");
        this._urlString = this.urlString.replace(regex, "");
        return this.urlString;
    };
    /**
     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
     * @param href The url
     * @param tenantId The tenant id to replace
     */
    UrlString.prototype.replaceTenantPath = function (tenantId) {
        var urlObject = this.getUrlComponents();
        var pathArray = urlObject.PathSegments;
        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
            pathArray[0] = tenantId;
        }
        return UrlString.constructAuthorityUriFromObject(urlObject);
    };
    /**
     * Returns the anchor part(#) of the URL
     */
    UrlString.prototype.getHash = function () {
        var hashIndex1 = this.urlString.indexOf("#");
        var hashIndex2 = this.urlString.indexOf("#/");
        if (hashIndex2 > -1) {
            return this.urlString.substring(hashIndex2 + 2);
        }
        else if (hashIndex1 > -1) {
            return this.urlString.substring(hashIndex1 + 1);
        }
        return "";
    };
    /**
     * Returns deserialized portion of URL hash
     */
    UrlString.prototype.getDeserializedHash = function () {
        var hash = this.getHash();
        var deserializedHash = StringUtils.queryStringToObject(hash);
        if (!deserializedHash) {
            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
        }
        return deserializedHash;
    };
    /**
     * Parses out the components from a url string.
     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
     */
    UrlString.prototype.getUrlComponents = function () {
        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0
        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        // If url string does not match regEx, we throw an error
        var match = this.urlString.match(regEx);
        if (!match) {
            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        // Url component object
        var urlComponents = {
            Protocol: match[1],
            HostNameAndPort: match[4],
            AbsolutePath: match[5]
        };
        var pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter(function (val) { return val && val.length > 0; }); // remove empty elements
        urlComponents.PathSegments = pathSegments;
        return urlComponents;
    };
    UrlString.constructAuthorityUriFromObject = function (urlObject) {
        return new UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
    };
    /**
     * Check if the hash of the URL string contains known properties
     */
    UrlString.hashContainsKnownProperties = function (url) {
        if (StringUtils.isEmpty(url)) {
            return false;
        }
        var urlString = new UrlString(url);
        var parameters = urlString.getDeserializedHash();
        return !!(parameters.error_description ||
            parameters.error ||
            parameters.state);
    };
    return UrlString;
}());

/**
 * Key to cache access tokens, id tokens, and refresh tokens. Helps manage token renewal.
 */
var AccessTokenKey = /** @class */ (function () {
    function AccessTokenKey(authority, clientId, scopes, resource, uid, utid, cryptoObj) {
        var authorityUri = new UrlString(authority);
        this.authority = authorityUri.urlString;
        this.clientId = clientId;
        this.scopes = scopes;
        this.resource = resource;
        if (!StringUtils.isEmpty(uid) && !StringUtils.isEmpty(utid)) {
            this.homeAccountIdentifier = cryptoObj.base64Encode(uid) + "." + cryptoObj.base64Encode(utid);
        }
    }
    return AccessTokenKey;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Value of access token cache item which is stored in cache. Helps manage token renewal.
 */
var AccessTokenValue = /** @class */ (function () {
    function AccessTokenValue(tokenType, accessToken, idToken, refreshToken, expiresOn, extExpiresOn) {
        this.tokenType = tokenType;
        this.accessToken = accessToken;
        this.idToken = idToken;
        this.refreshToken = refreshToken;
        this.expiresOnSec = expiresOn;
        this.extExpiresOnSec = extExpiresOn;
    }
    return AccessTokenValue;
}());

/**
 * Error thrown when there is an error with the server code, for example, unavailability.
 */
var ServerError = /** @class */ (function (_super) {
    __extends(ServerError, _super);
    function ServerError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError.prototype);
        return _this;
    }
    return ServerError;
}(AuthError));

/**
 * Class that handles response parsing.
 */
var ResponseHandler = /** @class */ (function () {
    function ResponseHandler(clientId, cacheStorage, cacheManager, cryptoObj, logger) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cacheManager = cacheManager;
        this.cryptoObj = cryptoObj;
        this.logger = logger;
    }
    /**
     * Returns a new response with the data from original response filled with the relevant IdToken data.
     * - raw id token
     * - id token claims
     * - unique id (oid or sub claim of token)
     * - tenant id (tid claim of token)
     * @param originalResponse
     * @param idTokenObj
     */
    ResponseHandler.setResponseIdToken = function (originalResponse, idTokenObj) {
        if (!originalResponse) {
            return null;
        }
        else if (!idTokenObj) {
            return originalResponse;
        }
        var expiresSeconds = Number(idTokenObj.claims.exp);
        if (expiresSeconds && !originalResponse.expiresOn) {
            originalResponse.expiresOn = new Date(expiresSeconds * 1000);
        }
        return __assign(__assign({}, originalResponse), { idToken: idTokenObj.rawIdToken, idTokenClaims: idTokenObj.claims, uniqueId: idTokenObj.claims.oid || idTokenObj.claims.sub, tenantId: idTokenObj.claims.tid });
    };
    /**
     * Validates and handles a response from the server, and returns a constructed object with the authorization code and state.
     * @param serverParams
     */
    ResponseHandler.prototype.handleServerCodeResponse = function (serverParams) {
        try {
            // Validate hash fragment response parameters
            this.validateServerAuthorizationCodeResponse(serverParams, this.cacheStorage.getItem(TemporaryCacheKeys.REQUEST_STATE), this.cryptoObj);
            // Cache client info
            if (serverParams.client_info) {
                this.cacheStorage.setItem(PersistentCacheKeys.CLIENT_INFO, serverParams.client_info);
            }
            // Create response object
            var response = {
                code: serverParams.code,
                userRequestState: serverParams.state
            };
            return response;
        }
        catch (e) {
            this.cacheManager.resetTempCacheItems(serverParams && serverParams.state);
            throw e;
        }
    };
    /**
     * Function which validates server authorization code response.
     * @param serverResponseHash
     * @param cachedState
     * @param cryptoObj
     */
    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {
        if (serverResponseHash.state !== cachedState) {
            throw ClientAuthError.createStateMismatchError();
        }
        // Check for error
        if (serverResponseHash.error || serverResponseHash.error_description) {
            throw new ServerError(serverResponseHash.error, serverResponseHash.error_description);
        }
        if (serverResponseHash.client_info) {
            buildClientInfo(serverResponseHash.client_info, cryptoObj);
        }
    };
    /**
     * Function which validates server authorization token response.
     * @param serverResponse
     */
    ResponseHandler.prototype.validateServerAuthorizationTokenResponse = function (serverResponse) {
        // Check for error
        if (serverResponse.error || serverResponse.error_description) {
            var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
            throw new ServerError(serverResponse.error, errString);
        }
    };
    /**
     * Helper function which saves or updates the token in the cache and constructs the final token response to send back to the user.
     * @param originalTokenResponse
     * @param authority
     * @param resource
     * @param serverTokenResponse
     * @param clientInfo
     */
    ResponseHandler.prototype.saveToken = function (originalTokenResponse, authority, resource, serverTokenResponse, clientInfo) {
        var _this = this;
        // Set consented scopes in response
        var responseScopes = ScopeSet.fromString(serverTokenResponse.scope, this.clientId, true);
        var responseScopeArray = responseScopes.asArray();
        // Expiration calculation
        var expiresIn = serverTokenResponse.expires_in;
        var expirationSec = TimeUtils.nowSeconds() + expiresIn;
        var extendedExpirationSec = expirationSec + serverTokenResponse.ext_expires_in;
        // Get id token
        if (!StringUtils.isEmpty(originalTokenResponse.idToken)) {
            this.cacheStorage.setItem(PersistentCacheKeys.ID_TOKEN, originalTokenResponse.idToken);
        }
        // Save access token in cache
        var newAccessTokenValue = new AccessTokenValue(serverTokenResponse.token_type, serverTokenResponse.access_token, originalTokenResponse.idToken, serverTokenResponse.refresh_token, expirationSec.toString(), extendedExpirationSec.toString());
        var homeAccountIdentifier = originalTokenResponse.account && originalTokenResponse.account.homeAccountIdentifier;
        var accessTokenCacheItems = this.cacheManager.getAllAccessTokens(this.clientId, authority || "", resource || "", homeAccountIdentifier || "");
        // If no items in cache with these parameters, set new item.
        if (accessTokenCacheItems.length < 1) {
            this.logger.info("No tokens found, creating new item.");
            var newTokenKey = new AccessTokenKey(authority, this.clientId, serverTokenResponse.scope, resource, clientInfo && clientInfo.uid, clientInfo && clientInfo.utid, this.cryptoObj);
            this.cacheStorage.setItem(JSON.stringify(newTokenKey), JSON.stringify(newAccessTokenValue));
        }
        else {
            // Check if scopes are intersecting. If they are, combine scopes and replace cache item.
            accessTokenCacheItems.forEach(function (accessTokenCacheItem) {
                var cachedScopes = ScopeSet.fromString(accessTokenCacheItem.key.scopes, _this.clientId, true);
                if (cachedScopes.intersectingScopeSets(responseScopes)) {
                    _this.cacheStorage.removeItem(JSON.stringify(accessTokenCacheItem.key));
                    cachedScopes.appendScopes(responseScopeArray);
                    accessTokenCacheItem.key.scopes = cachedScopes.printScopes();
                    if (StringUtils.isEmpty(newAccessTokenValue.idToken)) {
                        newAccessTokenValue.idToken = accessTokenCacheItem.value.idToken;
                    }
                    _this.cacheStorage.setItem(JSON.stringify(accessTokenCacheItem.key), JSON.stringify(newAccessTokenValue));
                }
            });
        }
        // Save tokens in response and return
        return __assign(__assign({}, originalTokenResponse), { tokenType: serverTokenResponse.token_type, scopes: responseScopeArray, accessToken: serverTokenResponse.access_token, refreshToken: serverTokenResponse.refresh_token, expiresOn: new Date(expirationSec * 1000) });
    };
    /**
     * Gets account cached with given key. Returns null if parsing could not be completed.
     * @param accountKey
     */
    ResponseHandler.prototype.getCachedAccount = function (accountKey) {
        try {
            return JSON.parse(this.cacheStorage.getItem(accountKey));
        }
        catch (e) {
            this.logger.warning("Account could not be parsed: " + JSON.stringify(e));
            return null;
        }
    };
    /**
     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
     * @param serverTokenResponse
     * @param authorityString
     * @param resource
     * @param state
     */
    ResponseHandler.prototype.createTokenResponse = function (serverTokenResponse, authorityString, resource, state) {
        var tokenResponse = {
            uniqueId: "",
            tenantId: "",
            tokenType: "",
            idToken: null,
            idTokenClaims: null,
            accessToken: "",
            refreshToken: "",
            scopes: [],
            expiresOn: null,
            account: null,
            userRequestState: ""
        };
        // Retrieve current id token object
        var idTokenObj;
        var cachedIdToken = this.cacheStorage.getItem(PersistentCacheKeys.ID_TOKEN);
        if (serverTokenResponse.id_token) {
            idTokenObj = new IdToken(serverTokenResponse.id_token, this.cryptoObj);
            tokenResponse = ResponseHandler.setResponseIdToken(tokenResponse, idTokenObj);
            // If state is empty, refresh token is being used
            if (!StringUtils.isEmpty(state)) {
                this.logger.info("State was detected - nonce should be available.");
                // check nonce integrity if refresh token is not used - throw an error if not matched        
                if (StringUtils.isEmpty(idTokenObj.claims.nonce)) {
                    throw ClientAuthError.createInvalidIdTokenError(idTokenObj);
                }
                var nonce = this.cacheStorage.getItem(this.cacheManager.generateNonceKey(state));
                if (idTokenObj.claims.nonce !== nonce) {
                    throw ClientAuthError.createNonceMismatchError();
                }
            }
        }
        else if (cachedIdToken) {
            idTokenObj = new IdToken(cachedIdToken, this.cryptoObj);
            tokenResponse = ResponseHandler.setResponseIdToken(tokenResponse, idTokenObj);
        }
        else {
            idTokenObj = null;
        }
        var clientInfo = null;
        var cachedAccount = null;
        if (idTokenObj) {
            // Retrieve client info
            clientInfo = buildClientInfo(this.cacheStorage.getItem(PersistentCacheKeys.CLIENT_INFO), this.cryptoObj);
            // Create account object for request
            tokenResponse.account = Account.createAccount(idTokenObj, clientInfo, this.cryptoObj);
            // Save the access token if it exists
            var accountKey = this.cacheManager.generateAcquireTokenAccountKey(tokenResponse.account.homeAccountIdentifier);
            // Get cached account
            cachedAccount = this.getCachedAccount(accountKey);
        }
        // Return user set state in the response
        tokenResponse.userRequestState = ProtocolUtils.getUserRequestState(state);
        this.cacheManager.resetTempCacheItems(state);
        if (!cachedAccount || !tokenResponse.account || Account.compareAccounts(cachedAccount, tokenResponse.account)) {
            return this.saveToken(tokenResponse, authorityString, resource, serverTokenResponse, clientInfo);
        }
        else {
            this.logger.error("Accounts do not match.");
            this.logger.errorPii("Cached Account: " + JSON.stringify(cachedAccount) + ", New Account: " + JSON.stringify(tokenResponse.account));
            throw ClientAuthError.createAccountMismatchError();
        }
    };
    return ResponseHandler;
}());

/**
 * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the
 * endpoint. It will store the pertinent config data in this object for use during token calls.
 */
var Authority = /** @class */ (function () {
    function Authority(authority, networkInterface) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
    }
    Object.defineProperty(Authority.prototype, "canonicalAuthority", {
        /**
         * A URL that is the authority set by the developer
         */
        get: function () {
            return this._canonicalAuthority.urlString;
        },
        /**
         * Sets canonical authority.
         */
        set: function (url) {
            this._canonicalAuthority = new UrlString(url);
            this._canonicalAuthority.validateAsUri();
            this._canonicalAuthorityUrlComponents = null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "canonicalAuthorityUrlComponents", {
        /**
         * Get authority components.
         */
        get: function () {
            if (!this._canonicalAuthorityUrlComponents) {
                this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
            }
            return this._canonicalAuthorityUrlComponents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "tenant", {
        /**
         * Get tenant for authority.
         */
        get: function () {
            return this.canonicalAuthorityUrlComponents.PathSegments[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "authorizationEndpoint", {
        /**
         * OAuth /authorize endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                return this.replaceTenant(this.tenantDiscoveryResponse.authorization_endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "tokenEndpoint", {
        /**
         * OAuth /token endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                return this.replaceTenant(this.tenantDiscoveryResponse.token_endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "endSessionEndpoint", {
        /**
         * OAuth logout endpoint for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                return this.replaceTenant(this.tenantDiscoveryResponse.end_session_endpoint);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Authority.prototype, "selfSignedJwtAudience", {
        /**
         * OAuth issuer for requests
         */
        get: function () {
            if (this.discoveryComplete()) {
                return this.replaceTenant(this.tenantDiscoveryResponse.issuer);
            }
            else {
                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Replaces tenant in url path with current tenant. Defaults to common.
     * @param urlString
     */
    Authority.prototype.replaceTenant = function (urlString) {
        return urlString.replace("{tenant}", this.tenant);
    };
    Object.defineProperty(Authority.prototype, "defaultOpenIdConfigurationEndpoint", {
        /**
         * The default open id configuration endpoint for any canonical authority.
         */
        get: function () {
            return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Boolean that returns whethr or not tenant discovery has been completed.
     */
    Authority.prototype.discoveryComplete = function () {
        return !!this.tenantDiscoveryResponse;
    };
    /**
     * Gets OAuth endpoints from the given OpenID configuration endpoint.
     * @param openIdConfigurationEndpoint
     */
    Authority.prototype.discoverEndpoints = function (openIdConfigurationEndpoint) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint)];
            });
        });
    };
    /**
     * Perform endpoint discovery to discover the /authorize, /token and logout endpoints.
     */
    Authority.prototype.resolveEndpointsAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var openIdConfigEndpoint, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getOpenIdConfigurationEndpointAsync()];
                    case 1:
                        openIdConfigEndpoint = _b.sent();
                        _a = this;
                        return [4 /*yield*/, this.discoverEndpoints(openIdConfigEndpoint)];
                    case 2:
                        _a.tenantDiscoveryResponse = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return Authority;
}());

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Authority types supported by MSAL.
 */
var AuthorityType;
(function (AuthorityType) {
    AuthorityType[AuthorityType["Aad"] = 0] = "Aad";
    AuthorityType[AuthorityType["Adfs"] = 1] = "Adfs";
    AuthorityType[AuthorityType["B2C"] = 2] = "B2C";
})(AuthorityType || (AuthorityType = {}));

/**
 * The AadAuthority class extends the Authority class and adds functionality specific to the Azure AD OAuth Authority.
 */
var AadAuthority = /** @class */ (function (_super) {
    __extends(AadAuthority, _super);
    function AadAuthority(authority, networkInterface) {
        return _super.call(this, authority, networkInterface) || this;
    }
    Object.defineProperty(AadAuthority.prototype, "authorityType", {
        // Set authority type to AAD
        get: function () {
            return AuthorityType.Aad;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AadAuthority.prototype, "aadInstanceDiscoveryEndpointUrl", {
        // Default AAD Instance Discovery Endpoint
        get: function () {
            return Constants.AAD_INSTANCE_DISCOVERY_ENDPT + "?api-version=1.0&authorization_endpoint=" + this.canonicalAuthority + "oauth2/v2.0/authorize";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a promise which resolves to the OIDC endpoint
     * Only responds with the endpoint
     */
    AadAuthority.prototype.getOpenIdConfigurationEndpointAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isInTrustedHostList(this.canonicalAuthorityUrlComponents.HostNameAndPort)) {
                            return [2 /*return*/, this.defaultOpenIdConfigurationEndpoint];
                        }
                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.aadInstanceDiscoveryEndpointUrl)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.tenant_discovery_endpoint];
                }
            });
        });
    };
    /**
     * Checks to see if the host is in a list of trusted hosts
     * @param {string} The host to look up
     */
    AadAuthority.prototype.isInTrustedHostList = function (host) {
        return AADTrustedHostList.includes(host);
    };
    return AadAuthority;
}(Authority));

var AuthorityFactory = /** @class */ (function () {
    function AuthorityFactory() {
    }
    /**
     * Parse the url and determine the type of authority
     */
    AuthorityFactory.detectAuthorityFromUrl = function (authorityString) {
        var authorityUrl = new UrlString(authorityString);
        var components = authorityUrl.getUrlComponents();
        var pathSegments = components.PathSegments;
        switch (pathSegments[0]) {
            case "tfp":
                // tfp denotes a b2c url
                return AuthorityType.B2C;
            default:
                // default authority is always AAD
                return AuthorityType.Aad;
        }
    };
    /**
     * Create an authority object of the correct type based on the url
     * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)
     */
    AuthorityFactory.createInstance = function (authorityUrl, networkInterface) {
        // Throw error if authority url is empty
        if (StringUtils.isEmpty(authorityUrl)) {
            throw ClientConfigurationError.createUrlEmptyError();
        }
        var type = AuthorityFactory.detectAuthorityFromUrl(authorityUrl);
        // Depending on above detection, create the right type.
        switch (type) {
            case AuthorityType.Aad:
                return new AadAuthority(authorityUrl, networkInterface);
            default:
                throw ClientAuthError.createInvalidAuthorityTypeError("Given Url: " + authorityUrl);
        }
    };
    return AuthorityFactory;
}());

/**
 * AuthorizationCodeModule class
 *
 * Object instance which will construct requests to send to and handle responses
 * from the Microsoft STS using the authorization code flow.
 */
var AuthorizationCodeModule = /** @class */ (function (_super) {
    __extends(AuthorizationCodeModule, _super);
    function AuthorizationCodeModule(configuration) {
        var _this = 
        // Implement base module
        _super.call(this, {
            systemOptions: configuration.systemOptions,
            loggerOptions: configuration.loggerOptions,
            storageInterface: configuration.storageInterface,
            networkInterface: configuration.networkInterface,
            cryptoInterface: configuration.cryptoInterface
        }) || this;
        // Implement defaults in config
        _this.clientConfig = buildPublicClientSPAConfiguration(configuration);
        // Initialize default authority instance
        _this.defaultAuthorityInstance = AuthorityFactory.createInstance(_this.clientConfig.auth.authority || Constants.DEFAULT_AUTHORITY, _this.networkClient);
        return _this;
    }
    /**
     * Creates a url for logging in a user. This will by default append the client id to the list of scopes,
     * allowing you to retrieve an id token in the subsequent code exchange. Also performs validation of the request parameters.
     * Including any SSO parameters (account, sid, login_hint) will short circuit the authentication and allow you to retrieve a code without interaction.
     * @param request
     */
    AuthorizationCodeModule.prototype.createLoginUrl = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.createUrl(request, true)];
            });
        });
    };
    /**
     * Creates a url for logging in a user. Also performs validation of the request parameters.
     * Including any SSO parameters (account, sid, login_hint) will short circuit the authentication and allow you to retrieve a code without interaction.
     * @param request
     */
    AuthorizationCodeModule.prototype.createAcquireTokenUrl = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.createUrl(request, false)];
            });
        });
    };
    /**
     * Helper function which creates URL. If isLoginCall is true, MSAL appends client id scope to retrieve id token from the service.
     * @param request
     * @param isLoginCall
     */
    AuthorizationCodeModule.prototype.createUrl = function (request, isLoginCall) {
        return __awaiter(this, void 0, void 0, function () {
            var acquireTokenAuthority, e_1, requestParameters, adalIdToken, adalIdTokenString, urlNavigate, tokenRequest, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        acquireTokenAuthority = (request && request.authority) ? AuthorityFactory.createInstance(request.authority, this.networkClient) : this.defaultAuthorityInstance;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        requestParameters = new ServerCodeRequestParameters(acquireTokenAuthority, this.clientConfig.auth.clientId, request, this.getAccount(), this.getRedirectUri(), this.cryptoObj, isLoginCall);
                        adalIdToken = null;
                        if (!requestParameters.hasSSOParam()) {
                            adalIdTokenString = this.cacheStorage.getItem(PersistentCacheKeys.ADAL_ID_TOKEN);
                            if (!StringUtils.isEmpty(adalIdTokenString)) {
                                adalIdToken = new IdToken(adalIdTokenString, this.cryptoObj);
                                this.cacheStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);
                            }
                        }
                        // Update required cache entries for request.
                        this.cacheManager.updateCacheEntries(requestParameters, request.account);
                        // Populate query parameters (sid/login_hint/domain_hint) and any other extraQueryParameters set by the developer.
                        requestParameters.populateQueryParams(adalIdToken);
                        return [4 /*yield*/, requestParameters.createNavigateUrl()];
                    case 5:
                        urlNavigate = _a.sent();
                        tokenRequest = {
                            scopes: requestParameters.scopes.getOriginalScopesAsArray(),
                            resource: request.resource,
                            codeVerifier: requestParameters.generatedPkce.verifier,
                            extraQueryParameters: request.extraQueryParameters,
                            authority: requestParameters.authorityInstance.canonicalAuthority,
                            correlationId: requestParameters.correlationId
                        };
                        this.cacheStorage.setItem(TemporaryCacheKeys.REQUEST_PARAMS, this.cryptoObj.base64Encode(JSON.stringify(tokenRequest)));
                        return [2 /*return*/, urlNavigate];
                    case 6:
                        e_2 = _a.sent();
                        // Reset cache items before re-throwing.
                        this.cacheManager.resetTempCacheItems(requestParameters && requestParameters.state);
                        throw e_2;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Given an authorization code, it will perform a token exchange using cached values from a previous call to
     * createLoginUrl() or createAcquireTokenUrl(). You must call this AFTER using one of those APIs first. You should
     * also use the handleFragmentResponse() API to pass the codeResponse to this function afterwards.
     * @param codeResponse
     */
    AuthorizationCodeModule.prototype.acquireToken = function (codeResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenRequest, acquireTokenAuthority, e_3, tokenEndpoint, tokenReqParams, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        // If no code response is given, we cannot acquire a token.
                        if (!codeResponse || StringUtils.isEmpty(codeResponse.code)) {
                            throw ClientAuthError.createTokenRequestCannotBeMadeError();
                        }
                        tokenRequest = this.getCachedRequest(codeResponse.userRequestState);
                        acquireTokenAuthority = (tokenRequest && tokenRequest.authority) ? AuthorityFactory.createInstance(tokenRequest.authority, this.networkClient) : this.defaultAuthorityInstance;
                        if (!!acquireTokenAuthority.discoveryComplete()) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_3 = _a.sent();
                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_3);
                    case 4:
                        tokenEndpoint = acquireTokenAuthority.tokenEndpoint;
                        tokenReqParams = new ServerTokenRequestParameters(this.clientConfig.auth.clientId, tokenRequest, codeResponse, this.getRedirectUri(), this.cryptoObj);
                        return [4 /*yield*/, this.getTokenResponse(tokenEndpoint, tokenReqParams, tokenRequest, codeResponse)];
                    case 5: 
                    // User helper to retrieve token response.
                    // Need to await function call before return to catch any thrown errors.
                    // if errors are thrown asynchronously in return statement, they are caught by caller of this function instead.
                    return [2 /*return*/, _a.sent()];
                    case 6:
                        e_4 = _a.sent();
                        // Reset cache items and set account to null before re-throwing.
                        this.cacheManager.resetTempCacheItems(codeResponse && codeResponse.userRequestState);
                        this.account = null;
                        throw e_4;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew
     * the given token and returns the renewed token. Will throw an error if login is not completed (unless
     * id tokens are not being renewed).
     * @param request
     */
    AuthorizationCodeModule.prototype.renewToken = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var account, requestScopes, acquireTokenAuthority, e_5, cachedTokenItem, expirationSec, offsetCurrentTimeSec, cachedScopes, defaultTokenResponse, tokenEndpoint, tokenReqParams, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        // Cannot renew token if no request object is given.
                        if (!request) {
                            throw ClientConfigurationError.createEmptyTokenRequestError();
                        }
                        account = request.account || this.getAccount();
                        requestScopes = new ScopeSet(request.scopes || [], this.clientConfig.auth.clientId, true);
                        // If this is an id token renewal, and no account is present, throw an error.
                        if (requestScopes.isLoginScopeSet()) {
                            if (!account) {
                                throw ClientAuthError.createUserLoginRequiredError();
                            }
                        }
                        acquireTokenAuthority = request.authority ? AuthorityFactory.createInstance(request.authority, this.networkClient) : this.defaultAuthorityInstance;
                        if (!!acquireTokenAuthority.discoveryComplete()) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_5 = _a.sent();
                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_5);
                    case 4:
                        cachedTokenItem = this.getCachedTokens(requestScopes, acquireTokenAuthority.canonicalAuthority, request.resource, account && account.homeAccountIdentifier);
                        expirationSec = Number(cachedTokenItem.value.expiresOnSec);
                        offsetCurrentTimeSec = TimeUtils.nowSeconds() + this.clientConfig.systemOptions.tokenRenewalOffsetSeconds;
                        if (!(!request.forceRefresh && expirationSec && expirationSec > offsetCurrentTimeSec)) return [3 /*break*/, 5];
                        cachedScopes = ScopeSet.fromString(cachedTokenItem.key.scopes, this.clientConfig.auth.clientId, true);
                        defaultTokenResponse = {
                            uniqueId: "",
                            tenantId: "",
                            scopes: cachedScopes.asArray(),
                            tokenType: cachedTokenItem.value.tokenType,
                            idToken: "",
                            idTokenClaims: null,
                            accessToken: cachedTokenItem.value.accessToken,
                            refreshToken: cachedTokenItem.value.refreshToken,
                            expiresOn: new Date(expirationSec * 1000),
                            account: account,
                            userRequestState: ""
                        };
                        // Only populate id token if it exists in cache item.
                        return [2 /*return*/, StringUtils.isEmpty(cachedTokenItem.value.idToken) ? defaultTokenResponse :
                                ResponseHandler.setResponseIdToken(defaultTokenResponse, new IdToken(cachedTokenItem.value.idToken, this.cryptoObj))];
                    case 5:
                        // Renew the tokens.
                        request.authority = cachedTokenItem.key.authority;
                        tokenEndpoint = acquireTokenAuthority.tokenEndpoint;
                        tokenReqParams = new ServerTokenRequestParameters(this.clientConfig.auth.clientId, request, null, this.getRedirectUri(), this.cryptoObj, cachedTokenItem.value.refreshToken);
                        return [4 /*yield*/, this.getTokenResponse(tokenEndpoint, tokenReqParams, request)];
                    case 6: 
                    // User helper to retrieve token response.
                    // Need to await function call before return to catch any thrown errors.
                    // if errors are thrown asynchronously in return statement, they are caught by caller of this function instead.
                    return [2 /*return*/, _a.sent()];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        e_6 = _a.sent();
                        // Reset cache items and set account to null before re-throwing.
                        this.cacheManager.resetTempCacheItems();
                        this.account = null;
                        throw e_6;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    // #region Logout
    /**
     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param authorityUri
     */
    AuthorizationCodeModule.prototype.logout = function (authorityUri) {
        return __awaiter(this, void 0, void 0, function () {
            var currentAccount, homeAccountIdentifier, postLogoutRedirectUri, acquireTokenAuthority, e_7, logoutUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentAccount = this.getAccount();
                        homeAccountIdentifier = currentAccount ? currentAccount.homeAccountIdentifier : "";
                        // Remove all pertinent access tokens.
                        this.cacheManager.removeAllAccessTokens(this.clientConfig.auth.clientId, authorityUri, "", homeAccountIdentifier);
                        // Clear remaining cache items.
                        this.cacheStorage.clear();
                        // Clear current account.
                        this.account = null;
                        postLogoutRedirectUri = "";
                        try {
                            postLogoutRedirectUri = "?" + AADServerParamKeys.POST_LOGOUT_URI + "=" + encodeURIComponent(this.getPostLogoutRedirectUri());
                        }
                        catch (e) { }
                        acquireTokenAuthority = (authorityUri) ? AuthorityFactory.createInstance(authorityUri, this.networkClient) : this.defaultAuthorityInstance;
                        if (!!acquireTokenAuthority.discoveryComplete()) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_7 = _a.sent();
                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_7);
                    case 4:
                        logoutUri = "" + acquireTokenAuthority.endSessionEndpoint + postLogoutRedirectUri;
                        return [2 /*return*/, logoutUri];
                }
            });
        });
    };
    // #endregion
    // #region Response Handling
    /**
     * Handles the hash fragment response from public client code request. Returns a code response used by
     * the client to exchange for a token in acquireToken.
     * @param hashFragment
     */
    AuthorizationCodeModule.prototype.handleFragmentResponse = function (hashFragment) {
        // Handle responses.
        var responseHandler = new ResponseHandler(this.clientConfig.auth.clientId, this.cacheStorage, this.cacheManager, this.cryptoObj, this.logger);
        // Deserialize hash fragment response parameters.
        var hashUrlString = new UrlString(hashFragment);
        var serverParams = hashUrlString.getDeserializedHash();
        // Get code response
        return responseHandler.handleServerCodeResponse(serverParams);
    };
    // #endregion
    // #region Helpers
    /**
     * Clears cache of items related to current request.
     */
    AuthorizationCodeModule.prototype.cancelRequest = function () {
        var cachedState = this.cacheStorage.getItem(TemporaryCacheKeys.REQUEST_STATE);
        this.cacheManager.resetTempCacheItems(cachedState || "");
    };
    /**
     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.
     */
    AuthorizationCodeModule.prototype.getCachedRequest = function (state) {
        try {
            // Get token request from cache and parse as TokenExchangeParameters.
            var encodedTokenRequest = this.cacheStorage.getItem(TemporaryCacheKeys.REQUEST_PARAMS);
            var parsedRequest = JSON.parse(this.cryptoObj.base64Decode(encodedTokenRequest));
            this.cacheStorage.removeItem(TemporaryCacheKeys.REQUEST_PARAMS);
            // Get cached authority and use if no authority is cached with request.
            if (StringUtils.isEmpty(parsedRequest.authority)) {
                var authorityKey = this.cacheManager.generateAuthorityKey(state);
                var cachedAuthority = this.cacheStorage.getItem(authorityKey);
                parsedRequest.authority = cachedAuthority;
            }
            return parsedRequest;
        }
        catch (err) {
            throw ClientAuthError.createTokenRequestCacheError(err);
        }
    };
    /**
     * Gets all cached tokens based on the given criteria.
     * @param requestScopes
     * @param authorityUri
     * @param resourceId
     * @param homeAccountIdentifier
     */
    AuthorizationCodeModule.prototype.getCachedTokens = function (requestScopes, authorityUri, resourceId, homeAccountIdentifier) {
        var _this = this;
        // Get all access tokens with matching authority, resource id and home account ID
        var tokenCacheItems = this.cacheManager.getAllAccessTokens(this.clientConfig.auth.clientId, authorityUri || "", resourceId || "", homeAccountIdentifier || "");
        if (tokenCacheItems.length === 0) {
            throw ClientAuthError.createNoTokensFoundError(requestScopes.printScopes());
        }
        // Filter cache items based on available scopes.
        var filteredCacheItems = tokenCacheItems.filter(function (cacheItem) {
            var cachedScopes = ScopeSet.fromString(cacheItem.key.scopes, _this.clientConfig.auth.clientId, true);
            return cachedScopes.containsScopeSet(requestScopes);
        });
        // If cache items contains too many matching tokens, throw error.
        if (filteredCacheItems.length > 1) {
            throw ClientAuthError.createMultipleMatchingTokensInCacheError(requestScopes.printScopes());
        }
        else if (filteredCacheItems.length === 1) {
            // Return single cache item.
            return filteredCacheItems[0];
        }
        // If cache items are empty, throw error.
        throw ClientAuthError.createNoTokensFoundError(requestScopes.printScopes());
    };
    /**
     * Makes a request to the token endpoint with the given parameters and parses the response.
     * @param tokenEndpoint
     * @param tokenReqParams
     * @param tokenRequest
     * @param codeResponse
     */
    AuthorizationCodeModule.prototype.getTokenResponse = function (tokenEndpoint, tokenReqParams, tokenRequest, codeResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var acquiredTokenResponse, responseHandler, tokenResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.networkClient.sendPostRequestAsync(tokenEndpoint, {
                            body: tokenReqParams.createRequestBody(),
                            headers: tokenReqParams.createRequestHeaders()
                        })];
                    case 1:
                        acquiredTokenResponse = _a.sent();
                        responseHandler = new ResponseHandler(this.clientConfig.auth.clientId, this.cacheStorage, this.cacheManager, this.cryptoObj, this.logger);
                        // Validate response. This function throws a server error if an error is returned by the server.
                        responseHandler.validateServerAuthorizationTokenResponse(acquiredTokenResponse);
                        tokenResponse = responseHandler.createTokenResponse(acquiredTokenResponse, tokenRequest.authority, tokenRequest.resource, codeResponse && codeResponse.userRequestState);
                        // Set current account to received response account, if any.
                        this.account = tokenResponse.account;
                        return [2 /*return*/, tokenResponse];
                }
            });
        });
    };
    // #endregion
    // #region Getters and setters
    /**
     *
     * Use to get the redirect uri configured in MSAL or null.
     * Evaluates redirectUri if its a function, otherwise simply returns its value.
     * @returns {string} redirect URL
     *
     */
    AuthorizationCodeModule.prototype.getRedirectUri = function () {
        if (this.clientConfig.auth.redirectUri) {
            if (typeof this.clientConfig.auth.redirectUri === "function") {
                return this.clientConfig.auth.redirectUri();
            }
            else if (!StringUtils.isEmpty(this.clientConfig.auth.redirectUri)) {
                return this.clientConfig.auth.redirectUri;
            }
        }
        // This should never throw unless window.location.href is returning empty.
        throw ClientConfigurationError.createRedirectUriEmptyError();
    };
    /**
     * Use to get the post logout redirect uri configured in MSAL or null.
     * Evaluates postLogoutredirectUri if its a function, otherwise simply returns its value.
     *
     * @returns {string} post logout redirect URL
     */
    AuthorizationCodeModule.prototype.getPostLogoutRedirectUri = function () {
        if (this.clientConfig.auth.postLogoutRedirectUri) {
            if (typeof this.clientConfig.auth.postLogoutRedirectUri === "function") {
                return this.clientConfig.auth.postLogoutRedirectUri();
            }
            else if (!StringUtils.isEmpty(this.clientConfig.auth.postLogoutRedirectUri)) {
                return this.clientConfig.auth.postLogoutRedirectUri;
            }
        }
        // This should never throw unless window.location.href is returning empty.
        throw ClientConfigurationError.createPostLogoutRedirectUriEmptyError();
    };
    return AuthorizationCodeModule;
}(AuthModule));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Builds a response that only sets state
 * @param responseState
 */
function buildResponseStateOnly(responseState) {
    return {
        userRequestState: responseState
    };
}

export { Account, AuthError, AuthErrorMessage, Authority, AuthorityFactory, AuthorizationCodeModule, ClientAuthError, ClientAuthErrorMessage, ClientConfigurationError, ClientConfigurationErrorMessage, Constants, LogLevel, PersistentCacheKeys, ServerError, StringUtils, TemporaryCacheKeys, UrlString, buildResponseStateOnly };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9lcnJvci9BdXRoRXJyb3IudHMiLCIuLi9zcmMvZXJyb3IvQ2xpZW50QXV0aEVycm9yLnRzIiwiLi4vc3JjL3V0aWxzL1N0cmluZ1V0aWxzLnRzIiwiLi4vc3JjL2xvZ2dlci9Mb2dnZXIudHMiLCIuLi9zcmMvYXBwL2NvbmZpZy9Nb2R1bGVDb25maWd1cmF0aW9uLnRzIiwiLi4vc3JjL2NhY2hlL0FjY2Vzc1Rva2VuQ2FjaGVJdGVtLnRzIiwiLi4vc3JjL3V0aWxzL0NvbnN0YW50cy50cyIsIi4uL3NyYy9jYWNoZS9DYWNoZUhlbHBlcnMudHMiLCIuLi9zcmMvYXV0aC9BY2NvdW50LnRzIiwiLi4vc3JjL2F1dGgvSWRUb2tlbi50cyIsIi4uL3NyYy9hdXRoL0NsaWVudEluZm8udHMiLCIuLi9zcmMvYXBwL21vZHVsZS9BdXRoTW9kdWxlLnRzIiwiLi4vc3JjL2FwcC9jb25maWcvUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbi50cyIsIi4uL3NyYy9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IudHMiLCIuLi9zcmMvYXV0aC9TY29wZVNldC50cyIsIi4uL3NyYy9yZXF1ZXN0L0F1dGhlbnRpY2F0aW9uUGFyYW1ldGVycy50cyIsIi4uL3NyYy91dGlscy9Qcm90b2NvbFV0aWxzLnRzIiwiLi4vc3JjL3NlcnZlci9TZXJ2ZXJDb2RlUmVxdWVzdFBhcmFtZXRlcnMudHMiLCIuLi9zcmMvc2VydmVyL1NlcnZlclRva2VuUmVxdWVzdFBhcmFtZXRlcnMudHMiLCIuLi9zcmMvdXRpbHMvVGltZVV0aWxzLnRzIiwiLi4vc3JjL3VybC9VcmxTdHJpbmcudHMiLCIuLi9zcmMvY2FjaGUvQWNjZXNzVG9rZW5LZXkudHMiLCIuLi9zcmMvY2FjaGUvQWNjZXNzVG9rZW5WYWx1ZS50cyIsIi4uL3NyYy9lcnJvci9TZXJ2ZXJFcnJvci50cyIsIi4uL3NyYy9yZXNwb25zZS9SZXNwb25zZUhhbmRsZXIudHMiLCIuLi9zcmMvYXV0aC9hdXRob3JpdHkvQXV0aG9yaXR5LnRzIiwiLi4vc3JjL2F1dGgvYXV0aG9yaXR5L0F1dGhvcml0eVR5cGUudHMiLCIuLi9zcmMvYXV0aC9hdXRob3JpdHkvQWFkQXV0aG9yaXR5LnRzIiwiLi4vc3JjL2F1dGgvYXV0aG9yaXR5L0F1dGhvcml0eUZhY3RvcnkudHMiLCIuLi9zcmMvYXBwL21vZHVsZS9BdXRob3JpemF0aW9uQ29kZU1vZHVsZS50cyIsIi4uL3NyYy9yZXNwb25zZS9BdXRoUmVzcG9uc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQXV0aEVycm9yTWVzc2FnZSBjbGFzcyBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQXV0aEVycm9yTWVzc2FnZSA9IHtcclxuICAgIHVuZXhwZWN0ZWRFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwidW5leHBlY3RlZF9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGlvbi5cIlxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYWwgZXJyb3IgY2xhc3MgdGhyb3duIGJ5IHRoZSBNU0FMLmpzIGxpYnJhcnkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cclxuICAgIC8vIFNob3J0IHN0cmluZyBkZW5vdGluZyBlcnJvclxyXG4gICAgZXJyb3JDb2RlOiBzdHJpbmc7XHJcbiAgICAvLyBEZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiBlcnJvclxyXG4gICAgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlOiBzdHJpbmcsIGVycm9yTWVzc2FnZT86IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEF1dGhFcnJvci5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIkF1dGhFcnJvclwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aGF0IGlzIHRocm93biB3aGVuIHNvbWV0aGluZyB1bmV4cGVjdGVkIGhhcHBlbnMgaW4gdGhlIGxpYnJhcnkuXHJcbiAgICAgKiBAcGFyYW0gZXJyRGVzYyBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihlcnJEZXNjOiBzdHJpbmcpOiBBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQXV0aEVycm9yKEF1dGhFcnJvck1lc3NhZ2UudW5leHBlY3RlZEVycm9yLmNvZGUsIGAke0F1dGhFcnJvck1lc3NhZ2UudW5leHBlY3RlZEVycm9yLmRlc2N9OiAke2VyckRlc2N9YCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gXCIuL0F1dGhFcnJvclwiO1xyXG5pbXBvcnQgeyBJZFRva2VuIH0gZnJvbSBcIi4uL2F1dGgvSWRUb2tlblwiO1xyXG5pbXBvcnQgeyBTY29wZVNldCB9IGZyb20gXCIuLi9hdXRoL1Njb3BlU2V0XCI7XHJcblxyXG4vKipcclxuICogQ2xpZW50QXV0aEVycm9yTWVzc2FnZSBjbGFzcyBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ2xpZW50QXV0aEVycm9yTWVzc2FnZSA9IHtcclxuICAgIGNsaWVudEluZm9EZWNvZGluZ0Vycm9yOiB7XHJcbiAgICAgICAgY29kZTogXCJjbGllbnRfaW5mb19kZWNvZGluZ19lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGhlIGNsaWVudCBpbmZvIGNvdWxkIG5vdCBiZSBwYXJzZWQvZGVjb2RlZCBjb3JyZWN0bHkuIFBsZWFzZSByZXZpZXcgdGhlIHRyYWNlIHRvIGRldGVybWluZSB0aGUgcm9vdCBjYXVzZS5cIlxyXG4gICAgfSxcclxuICAgIGNsaWVudEluZm9FbXB0eUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogXCJjbGllbnRfaW5mb19lbXB0eV9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGhlIGNsaWVudCBpbmZvIHdhcyBlbXB0eS4gUGxlYXNlIHJldmlldyB0aGUgdHJhY2UgdG8gZGV0ZXJtaW5lIHRoZSByb290IGNhdXNlLlwiXHJcbiAgICB9LFxyXG4gICAgaWRUb2tlblBhcnNpbmdFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwiaWRfdG9rZW5fcGFyc2luZ19lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiSUQgdG9rZW4gY2Fubm90IGJlIHBhcnNlZC4gUGxlYXNlIHJldmlldyBzdGFjayB0cmFjZSB0byBkZXRlcm1pbmUgcm9vdCBjYXVzZS5cIlxyXG4gICAgfSxcclxuICAgIG51bGxPckVtcHR5SWRUb2tlbjoge1xyXG4gICAgICAgIGNvZGU6IFwibnVsbF9vcl9lbXB0eV9pZF90b2tlblwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGhlIGlkVG9rZW4gaXMgbnVsbCBvciBlbXB0eS4gUGxlYXNlIHJldmlldyB0aGUgdHJhY2UgdG8gZGV0ZXJtaW5lIHRoZSByb290IGNhdXNlLlwiXHJcbiAgICB9LFxyXG4gICAgdG9rZW5SZXF1ZXN0Q2FjaGVFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwidG9rZW5fcmVxdWVzdF9jYWNoZV9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGhlIHRva2VuIHJlcXVlc3QgY291bGQgbm90IGJlIGZldGNoZWQgZnJvbSB0aGUgY2FjaGUgY29ycmVjdGx5LlwiXHJcbiAgICB9LFxyXG4gICAgZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImVuZHBvaW50c19yZXNvbHV0aW9uX2Vycm9yXCIsXHJcbiAgICAgICAgZGVzYzogXCJFcnJvcjogY291bGQgbm90IHJlc29sdmUgZW5kcG9pbnRzLiBQbGVhc2UgY2hlY2sgbmV0d29yayBhbmQgdHJ5IGFnYWluLlwiXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZEF1dGhvcml0eVR5cGU6IHtcclxuICAgICAgICBjb2RlOiBcImludmFsaWRfYXV0aG9yaXR5X3R5cGVcIixcclxuICAgICAgICBkZXNjOiBcIlRoZSBnaXZlbiBhdXRob3JpdHkgaXMgbm90IGEgdmFsaWQgdHlwZSBvZiBhdXRob3JpdHkgc3VwcG9ydGVkIGJ5IE1TQUwuIFBsZWFzZSByZXZpZXcgdGhlIHRyYWNlIHRvIGRldGVybWluZSB0aGUgcm9vdCBjYXVzZS5cIlxyXG4gICAgfSxcclxuICAgIGhhc2hOb3REZXNlcmlhbGl6ZWQ6IHtcclxuICAgICAgICBjb2RlOiBcImhhc2hfbm90X2Rlc2VyaWFsaXplZFwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGhlIGhhc2ggcGFyYW1ldGVycyBjb3VsZCBub3QgYmUgZGVzZXJpYWxpemVkLiBQbGVhc2UgcmV2aWV3IHRoZSB0cmFjZSB0byBkZXRlcm1pbmUgdGhlIHJvb3QgY2F1c2UuXCJcclxuICAgIH0sXHJcbiAgICBibGFua0d1aWRHZW5lcmF0ZWQ6IHtcclxuICAgICAgICBjb2RlOiBcImJsYW5rX2d1aWRfZ2VuZXJhdGVkXCIsXHJcbiAgICAgICAgZGVzYzogXCJUaGUgZ3VpZCBnZW5lcmF0ZWQgd2FzIGJsYW5rLiBQbGVhc2UgcmV2aWV3IHRoZSB0cmFjZSB0byBkZXRlcm1pbmUgdGhlIHJvb3QgY2F1c2UuXCJcclxuICAgIH0sXHJcbiAgICBzdGF0ZU1pc21hdGNoRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcInN0YXRlX21pc21hdGNoXCIsXHJcbiAgICAgICAgZGVzYzogXCJTdGF0ZSBtaXNtYXRjaCBlcnJvci4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yay4gQ29udGludWVkIHJlcXVlc3RzIG1heSBjYXVzZSBjYWNoZSBvdmVyZmxvdy5cIlxyXG4gICAgfSxcclxuICAgIG5vbmNlTWlzbWF0Y2hFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwibm9uY2VfbWlzbWF0Y2hcIixcclxuICAgICAgICBkZXNjOiBcIk5vbmNlIG1pc21hdGNoIGVycm9yLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYSByYWNlIGNvbmRpdGlvbiBpbiBjb25jdXJyZW50IHJlcXVlc3RzLlwiXHJcbiAgICB9LFxyXG4gICAgYWNjb3VudE1pc21hdGNoRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImFjY291bnRfbWlzbWF0Y2hcIixcclxuICAgICAgICBkZXNjOiBcIlRoZSBjYWNoZWQgYWNjb3VudCBhbmQgYWNjb3VudCB3aGljaCBtYWRlIHRoZSB0b2tlbiByZXF1ZXN0IGRvIG5vdCBtYXRjaC5cIlxyXG4gICAgfSxcclxuICAgIGludmFsaWRJZFRva2VuOiB7XHJcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX2lkX3Rva2VuXCIsXHJcbiAgICAgICAgZGVzYzogXCJJbnZhbGlkIElEIHRva2VuIGZvcm1hdC5cIlxyXG4gICAgfSxcclxuICAgIG5vVG9rZW5zRm91bmRFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwibm9fdG9rZW5zX2ZvdW5kXCIsXHJcbiAgICAgICAgZGVzYzogXCJObyB0b2tlbnMgd2VyZSBmb3VuZCBmb3IgdGhlIGdpdmVuIHNjb3BlcywgYW5kIG5vIGF1dGhvcml6YXRpb24gY29kZSB3YXMgcGFzc2VkIHRvIGFjcXVpcmVUb2tlbi4gWW91IG11c3QgcmV0cmlldmUgYW4gYXV0aG9yaXphdGlvbiBjb2RlIGJlZm9yZSBtYWtpbmcgYSBjYWxsIHRvIGFjcXVpcmVUb2tlbigpLlwiXHJcbiAgICB9LFxyXG4gICAgY2FjaGVQYXJzZUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogXCJjYWNoZV9wYXJzZV9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiQ291bGQgbm90IHBhcnNlIGNhY2hlIGtleS5cIlxyXG4gICAgfSxcclxuICAgIHVzZXJMb2dpblJlcXVpcmVkRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcInVzZXJfbG9naW5fZXJyb3JcIixcclxuICAgICAgICBkZXNjOiBcIlVzZXIgbG9naW4gaXMgcmVxdWlyZWQuXCJcclxuICAgIH0sXHJcbiAgICBtdWx0aXBsZU1hdGNoaW5nVG9rZW5zOiB7XHJcbiAgICAgICAgY29kZTogXCJtdWx0aXBsZV9tYXRjaGluZ190b2tlbnNcIixcclxuICAgICAgICBkZXNjOiBcIlRoZSBjYWNoZSBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMgc2F0aXNmeWluZyB0aGUgcmVxdWlyZW1lbnRzLiBcIiArXHJcbiAgICAgICAgICAgIFwiQ2FsbCBBY3F1aXJlVG9rZW4gYWdhaW4gcHJvdmlkaW5nIG1vcmUgcmVxdWlyZW1lbnRzIHN1Y2ggYXMgYXV0aG9yaXR5LCByZXNvdXJjZSwgb3IgYWNjb3VudC5cIlxyXG4gICAgfSxcclxuICAgIHRva2VuUmVxdWVzdENhbm5vdEJlTWFkZToge1xyXG4gICAgICAgIGNvZGU6IFwicmVxdWVzdF9jYW5ub3RfYmVfbWFkZVwiLFxyXG4gICAgICAgIGRlc2M6IFwiVG9rZW4gcmVxdWVzdCBjYW5ub3QgYmUgbWFkZSB3aXRob3V0IGF1dGhvcml6YXRpb24gY29kZSBvciByZWZyZXNoIHRva2VuLlwiXHJcbiAgICB9LFxyXG4gICAgYXBwZW5kRW1wdHlTY29wZUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogXCJjYW5ub3RfYXBwZW5kX2VtcHR5X3Njb3BlXCIsXHJcbiAgICAgICAgZGVzYzogXCJDYW5ub3QgYXBwZW5kIG51bGwgb3IgZW1wdHkgc2NvcGUgdG8gU2NvcGVTZXQuIFBsZWFzZSBjaGVjayB0aGUgc3RhY2sgdHJhY2UgZm9yIG1vcmUgaW5mby5cIlxyXG4gICAgfSxcclxuICAgIHJlbW92ZUVtcHR5U2NvcGVFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwiY2Fubm90X3JlbW92ZV9lbXB0eV9zY29wZVwiLFxyXG4gICAgICAgIGRlc2M6IFwiQ2Fubm90IHJlbW92ZSBudWxsIG9yIGVtcHR5IHNjb3BlIGZyb20gU2NvcGVTZXQuIFBsZWFzZSBjaGVjayB0aGUgc3RhY2sgdHJhY2UgZm9yIG1vcmUgaW5mby5cIlxyXG4gICAgfSxcclxuICAgIGFwcGVuZFNjb3BlU2V0RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImNhbm5vdF9hcHBlbmRfc2NvcGVzZXRcIixcclxuICAgICAgICBkZXNjOiBcIkNhbm5vdCBhcHBlbmQgU2NvcGVTZXQgZHVlIHRvIGVycm9yLlwiXHJcbiAgICB9LFxyXG4gICAgZW1wdHlJbnB1dFNjb3BlU2V0RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImVtcHR5X2lucHV0X3Njb3Blc2V0XCIsXHJcbiAgICAgICAgZGVzYzogXCJFbXB0eSBpbnB1dCBTY29wZVNldCBjYW5ub3QgYmUgcHJvY2Vzc2VkLlwiXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGNsaWVudCBjb2RlIHJ1bm5pbmcgb24gdGhlIGJyb3dzZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2xpZW50QXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcclxuICAgICAgICBcclxuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U/OiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDbGllbnRBdXRoRXJyb3JcIjtcclxuXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENsaWVudEF1dGhFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiBjbGllbnQgaW5mbyBvYmplY3QgZG9lc24ndCBkZWNvZGUgY29ycmVjdGx5LlxyXG4gICAgICogQHBhcmFtIGNhdWdodEVycm9yIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQ2xpZW50SW5mb0RlY29kaW5nRXJyb3IoY2F1Z2h0RXJyb3I6IHN0cmluZyk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5jbGllbnRJbmZvRGVjb2RpbmdFcnJvci5jb2RlLFxyXG4gICAgICAgICAgICBgJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlLmNsaWVudEluZm9EZWNvZGluZ0Vycm9yLmRlc2N9IEZhaWxlZCB3aXRoIGVycm9yOiAke2NhdWdodEVycm9yfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gaWYgdGhlIGNsaWVudCBpbmZvIGlzIGVtcHR5LlxyXG4gICAgICogQHBhcmFtIHJhd0NsaWVudEluZm8gXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVDbGllbnRJbmZvRW1wdHlFcnJvcihyYXdDbGllbnRJbmZvOiBzdHJpbmcpOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2UuY2xpZW50SW5mb0VtcHR5RXJyb3IuY29kZSxcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5jbGllbnRJbmZvRW1wdHlFcnJvci5kZXNjfSBHaXZlbiBPYmplY3Q6ICR7cmF3Q2xpZW50SW5mb31gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIGlkIHRva2VuIGV4dHJhY3Rpb24gZXJyb3JzIG91dC5cclxuICAgICAqIEBwYXJhbSBlcnIgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJZFRva2VuUGFyc2luZ0Vycm9yKGNhdWdodEV4dHJhY3Rpb25FcnJvcjogc3RyaW5nKTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLmlkVG9rZW5QYXJzaW5nRXJyb3IuY29kZSxcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5pZFRva2VuUGFyc2luZ0Vycm9yLmRlc2N9IEZhaWxlZCB3aXRoIGVycm9yOiAke2NhdWdodEV4dHJhY3Rpb25FcnJvcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIGlkIHRva2VuIHN0cmluZyBpcyBudWxsIG9yIGVtcHR5LlxyXG4gICAgICogQHBhcmFtIGludmFsaWRSYXdUb2tlblN0cmluZyBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlkVG9rZW5OdWxsT3JFbXB0eUVycm9yKGludmFsaWRSYXdUb2tlblN0cmluZzogc3RyaW5nKSA6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5udWxsT3JFbXB0eUlkVG9rZW4uY29kZSxcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5udWxsT3JFbXB0eUlkVG9rZW4uZGVzY30gUmF3IElEIFRva2VuIFZhbHVlOiAke2ludmFsaWRSYXdUb2tlblN0cmluZ31gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIHRva2VuIHJlcXVlc3QgY291bGQgbm90IGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGVyckRldGFpbCBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVRva2VuUmVxdWVzdENhY2hlRXJyb3IoZXJyRGV0YWlsOiBzdHJpbmcpOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2UudG9rZW5SZXF1ZXN0Q2FjaGVFcnJvci5jb2RlLCBcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS50b2tlblJlcXVlc3RDYWNoZUVycm9yLmRlc2N9IEVycm9yIERldGFpbDogJHtlcnJEZXRhaWx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biB3aGVuIHRoZSBlbmRwb2ludCBkaXNjb3ZlcnkgZG9lc24ndCBjb21wbGV0ZSBjb3JyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVFbmRwb2ludERpc2NvdmVyeUluY29tcGxldGVFcnJvcihlcnJEZXRhaWw6IHN0cmluZyk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5lbmRwb2ludFJlc29sdXRpb25FcnJvci5jb2RlLCBcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5lbmRwb2ludFJlc29sdXRpb25FcnJvci5kZXNjfSBEZXRhaWw6ICR7ZXJyRGV0YWlsfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gaWYgYXV0aG9yaXR5IHR5cGUgaXMgbm90IHZhbGlkLlxyXG4gICAgICogQHBhcmFtIGludmFsaWRBdXRob3JpdHlFcnJvciBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUludmFsaWRBdXRob3JpdHlUeXBlRXJyb3IoZ2l2ZW5Vcmw6IHN0cmluZyk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5pbnZhbGlkQXV0aG9yaXR5VHlwZS5jb2RlLCBcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5pbnZhbGlkQXV0aG9yaXR5VHlwZS5kZXNjfSBHaXZlbiBVcmw6ICR7Z2l2ZW5Vcmx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biB3aGVuIHRoZSBoYXNoIGNhbm5vdCBiZSBkZXNlcmlhbGl6ZWQuXHJcbiAgICAgKiBAcGFyYW0gaW52YWxpZEF1dGhvcml0eUVycm9yIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlSGFzaE5vdERlc2VyaWFsaXplZEVycm9yKGhhc2hQYXJhbU9iajogc3RyaW5nKTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLmhhc2hOb3REZXNlcmlhbGl6ZWQuY29kZSwgXHJcbiAgICAgICAgICAgIGAke0NsaWVudEF1dGhFcnJvck1lc3NhZ2UuaGFzaE5vdERlc2VyaWFsaXplZC5kZXNjfSBHaXZlbiBPYmplY3Q6ICR7aGFzaFBhcmFtT2JqfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiB0d28gc3RhdGVzIGRvIG5vdCBtYXRjaC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVN0YXRlTWlzbWF0Y2hFcnJvcigpOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2Uuc3RhdGVNaXNtYXRjaEVycm9yLmNvZGUsIFxyXG4gICAgICAgICAgICBDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnN0YXRlTWlzbWF0Y2hFcnJvci5kZXNjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIG5vbmNlIGRvZXMgbm90IG1hdGNoLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlTm9uY2VNaXNtYXRjaEVycm9yKCk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5ub25jZU1pc21hdGNoRXJyb3IuY29kZSwgXHJcbiAgICAgICAgICAgIENsaWVudEF1dGhFcnJvck1lc3NhZ2Uubm9uY2VNaXNtYXRjaEVycm9yLmRlc2MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIGNhY2hlZCBhY2NvdW50IGFuZCByZXNwb25zZSBhY2NvdW50IGRvIG5vdCBtYXRjaC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUFjY291bnRNaXNtYXRjaEVycm9yKCk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5hY2NvdW50TWlzbWF0Y2hFcnJvci5jb2RlLCBcclxuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5hY2NvdW50TWlzbWF0Y2hFcnJvci5kZXNjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRocm93cyBlcnJvciBpZiBpZFRva2VuIGlzIG5vdCBjb3JyZWN0bHkgZm9ybWVkXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbiBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUludmFsaWRJZFRva2VuRXJyb3IoaWRUb2tlbjogSWRUb2tlbikgOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2UuaW52YWxpZElkVG9rZW4uY29kZSxcclxuICAgICAgICAgICAgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5pbnZhbGlkSWRUb2tlbi5kZXNjfSBHaXZlbiB0b2tlbjogJHtKU09OLnN0cmluZ2lmeShpZFRva2VuKX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIGF1dGhvcml6YXRpb24gY29kZSByZXF1aXJlZCBmb3IgYSB0b2tlbiByZXF1ZXN0IGlzIG51bGwgb3IgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVOb1Rva2Vuc0ZvdW5kRXJyb3Ioc2NvcGVzOiBzdHJpbmcpOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2Uubm9Ub2tlbnNGb3VuZEVycm9yLmNvZGUsIFxyXG4gICAgICAgICAgICBgJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlLm5vVG9rZW5zRm91bmRFcnJvci5kZXNjfSBTY29wZXM6ICR7c2NvcGVzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciBpbiBjYWNoZSBwYXJzaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlQ2FjaGVQYXJzZUVycm9yKGNhY2hlS2V5OiBzdHJpbmcpOiBDbGllbnRBdXRoRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvck1lc3NhZ2UuY2FjaGVQYXJzZUVycm9yLmNvZGUsIFxyXG4gICAgICAgICAgICBgJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlLmNhY2hlUGFyc2VFcnJvci5kZXNjfSBDYWNoZSBrZXk6ICR7Y2FjaGVLZXl9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaHJvd3MgZXJyb3Igd2hlbiByZW5ld2luZyB0b2tlbiB3aXRob3V0IGxvZ2luLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlVXNlckxvZ2luUmVxdWlyZWRFcnJvcigpIDogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnVzZXJMb2dpblJlcXVpcmVkRXJyb3IuY29kZSxcclxuICAgICAgICAgICAgQ2xpZW50QXV0aEVycm9yTWVzc2FnZS51c2VyTG9naW5SZXF1aXJlZEVycm9yLmRlc2MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGVycm9yIHdoZW4gbXVsdGlwbGUgdG9rZW5zIGFyZSBpbiBjYWNoZSBmb3IgdGhlIGdpdmVuIHNjb3BlLlxyXG4gICAgICogQHBhcmFtIHNjb3BlIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlTXVsdGlwbGVNYXRjaGluZ1Rva2Vuc0luQ2FjaGVFcnJvcihzY29wZTogc3RyaW5nKTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnMuY29kZSxcclxuICAgICAgICAgICAgYENhY2hlIGVycm9yIGZvciBzY29wZSAke3Njb3BlfTogJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnMuZGVzY30uYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaHJvd3MgZXJyb3Igd2hlbiBubyBhdXRoIGNvZGUgb3IgcmVmcmVzaCB0b2tlbiBpcyBnaXZlbiB0byBTZXJ2ZXJUb2tlblJlcXVlc3RQYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlVG9rZW5SZXF1ZXN0Q2Fubm90QmVNYWRlRXJyb3IoKTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnRva2VuUmVxdWVzdENhbm5vdEJlTWFkZS5jb2RlLCBDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnRva2VuUmVxdWVzdENhbm5vdEJlTWFkZS5kZXNjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRocm93cyBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gYXBwZW5kIGEgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5IHNjb3BlIHRvIGEgc2V0XHJcbiAgICAgKiBAcGFyYW0gZ2l2ZW5TY29wZSBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUFwcGVuZEVtcHR5U2NvcGVUb1NldEVycm9yKGdpdmVuU2NvcGU6IHN0cmluZyk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5hcHBlbmRFbXB0eVNjb3BlRXJyb3IuY29kZSwgYCR7Q2xpZW50QXV0aEVycm9yTWVzc2FnZS5hcHBlbmRFbXB0eVNjb3BlRXJyb3IuZGVzY30gR2l2ZW4gU2NvcGU6ICR7Z2l2ZW5TY29wZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRocm93cyBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gYXBwZW5kIGEgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5IHNjb3BlIHRvIGEgc2V0XHJcbiAgICAgKiBAcGFyYW0gZ2l2ZW5TY29wZSBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVJlbW92ZUVtcHR5U2NvcGVGcm9tU2V0RXJyb3IoZ2l2ZW5TY29wZTogc3RyaW5nKTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnJlbW92ZUVtcHR5U2NvcGVFcnJvci5jb2RlLCBgJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlLnJlbW92ZUVtcHR5U2NvcGVFcnJvci5kZXNjfSBHaXZlbiBTY29wZTogJHtnaXZlblNjb3BlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBhcHBlbmQgbnVsbCBvciBlbXB0eSBTY29wZVNldC5cclxuICAgICAqIEBwYXJhbSBhcHBlbmRFcnJvciBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUFwcGVuZFNjb3BlU2V0RXJyb3IoYXBwZW5kRXJyb3I6IHN0cmluZyk6IENsaWVudEF1dGhFcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yTWVzc2FnZS5hcHBlbmRTY29wZVNldEVycm9yLmNvZGUsIGAke0NsaWVudEF1dGhFcnJvck1lc3NhZ2UuYXBwZW5kU2NvcGVTZXRFcnJvci5kZXNjfSBEZXRhaWwgRXJyb3I6ICR7YXBwZW5kRXJyb3J9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgU2NvcGVTZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgICAgKiBAcGFyYW0gZ2l2ZW5TY29wZVNldCBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUVtcHR5SW5wdXRTY29wZVNldEVycm9yKGdpdmVuU2NvcGVTZXQ6IFNjb3BlU2V0KTogQ2xpZW50QXV0aEVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JNZXNzYWdlLmVtcHR5SW5wdXRTY29wZVNldEVycm9yLmNvZGUsIGAke0NsaWVudEF1dGhFcnJvck1lc3NhZ2UuZW1wdHlJbnB1dFNjb3BlU2V0RXJyb3IuZGVzY30gR2l2ZW4gU2NvcGVTZXQ6ICR7Z2l2ZW5TY29wZVNldH1gKTtcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgRGVjb2RlZEp3dCB9IGZyb20gXCIuLi9hdXRoL0RlY29kZWRKd3RcIjtcclxuaW1wb3J0IHsgQ2xpZW50QXV0aEVycm9yIH0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvclwiO1xyXG5cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdVdGlscyB7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogZGVjb2RlIGEgSldUXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGp3dFRva2VuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVKd3Qoand0VG9rZW46IHN0cmluZyk6IERlY29kZWRKd3Qge1xyXG4gICAgICAgIGlmIChTdHJpbmdVdGlscy5pc0VtcHR5KGp3dFRva2VuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlSWRUb2tlbk51bGxPckVtcHR5RXJyb3Ioand0VG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZFRva2VuUGFydHNSZWdleCA9IC9eKFteXFwuXFxzXSopXFwuKFteXFwuXFxzXSspXFwuKFteXFwuXFxzXSopJC87XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGlkVG9rZW5QYXJ0c1JlZ2V4LmV4ZWMoand0VG9rZW4pO1xyXG4gICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUlkVG9rZW5QYXJzaW5nRXJyb3IoYEdpdmVuIHRva2VuIGlzIG1hbGZvcm1lZDogJHtKU09OLnN0cmluZ2lmeShqd3RUb2tlbil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNyYWNrZWRUb2tlbjogRGVjb2RlZEp3dCA9IHtcclxuICAgICAgICAgICAgaGVhZGVyOiBtYXRjaGVzWzFdLFxyXG4gICAgICAgICAgICBKV1NQYXlsb2FkOiBtYXRjaGVzWzJdLFxyXG4gICAgICAgICAgICBKV1NTaWc6IG1hdGNoZXNbM11cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjcmFja2VkVG9rZW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHN0cmluZyBpcyBlbXB0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VtcHR5KHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSBcInVuZGVmaW5lZFwiIHx8ICFzdHIgfHwgMCA9PT0gc3RyLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcXVlcnlTdHJpbmdUb09iamVjdDxUPihxdWVyeTogc3RyaW5nKTogVCB7XHJcbiAgICAgICAgbGV0IG1hdGNoOiBBcnJheTxzdHJpbmc+OyAvLyBSZWdleCBmb3IgcmVwbGFjaW5nIGFkZGl0aW9uIHN5bWJvbCB3aXRoIGEgc3BhY2VcclxuICAgICAgICBjb25zdCBwbCA9IC9cXCsvZztcclxuICAgICAgICBjb25zdCBzZWFyY2ggPSAvKFteJj1dKyk9KFteJl0qKS9nO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZSA9IChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHMucmVwbGFjZShwbCwgXCIgXCIpKTtcclxuICAgICAgICBjb25zdCBvYmo6IHt9ID0ge307XHJcbiAgICAgICAgbWF0Y2ggPSBzZWFyY2guZXhlYyhxdWVyeSk7XHJcbiAgICAgICAgd2hpbGUgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG9ialtkZWNvZGUobWF0Y2hbMV0pXSA9IGRlY29kZShtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqIGFzIFQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmltcyBlbnRyaWVzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIGxvd2VyIGNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFyclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJpbUFuZENvbnZlcnRBcnJheUVudHJpZXNUb0xvd2VyQ2FzZShhcnI6IEFycmF5PHN0cmluZz4pOiBBcnJheTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gYXJyLm1hcChlbnRyeSA9PiBlbnRyeS50cmltKCkudG9Mb3dlckNhc2UoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGVtcHR5IHN0cmluZ3MgZnJvbSBhcnJheVxyXG4gICAgICogQHBhcmFtIGFyciBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlbW92ZUVtcHR5U3RyaW5nc0Zyb21BcnJheShhcnI6IEFycmF5PHN0cmluZz4pOiBBcnJheTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gYXJyLmZpbHRlcihlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAhU3RyaW5nVXRpbHMuaXNFbXB0eShlbnRyeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCBwa2cgZnJvbSBcIi4uLy4uL3BhY2thZ2UuanNvblwiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSBcIi4uL2FwcC9jb25maWcvTW9kdWxlQ29uZmlndXJhdGlvbi5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgZm9yIGxvZ2dlciBtZXNzYWdlcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIExvZ2dlck1lc3NhZ2VPcHRpb25zID0ge1xyXG4gICAgbG9nTGV2ZWw6IExvZ0xldmVsLFxyXG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZyxcclxuICAgIGNvbnRhaW5zUGlpPzogYm9vbGVhblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvZyBtZXNzYWdlIGxldmVsLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xyXG4gICAgRXJyb3IsXHJcbiAgICBXYXJuaW5nLFxyXG4gICAgSW5mbyxcclxuICAgIFZlcmJvc2VcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayB0byBzZW5kIHRoZSBtZXNzYWdlcyB0by5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUxvZ2dlckNhbGxiYWNrIHtcclxuICAgIChsZXZlbDogTG9nTGV2ZWwsIG1lc3NhZ2U6IHN0cmluZywgY29udGFpbnNQaWk6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xhc3Mgd2hpY2ggZmFjaWxpdGF0ZXMgbG9nZ2luZyBvZiBtZXNzYWdlcyB0byBhIHNwZWNpZmljIHBsYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExvZ2dlciB7XHJcblxyXG4gICAgLy8gQ29ycmVsYXRpb24gSUQgZm9yIHJlcXVlc3QsIHVzdWFsbHkgc2V0IGJ5IHVzZXIuXHJcbiAgICBwcml2YXRlIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcclxuXHJcbiAgICAvLyBDdXJyZW50IGxvZyBsZXZlbCwgZGVmYXVsdHMgdG8gaW5mby5cclxuICAgIHByaXZhdGUgbGV2ZWw6IExvZ0xldmVsID0gTG9nTGV2ZWwuSW5mbztcclxuXHJcbiAgICAvLyBCb29sZWFuIGRlc2NyaWJpbmcgd2hldGhlciBQSUkgbG9nZ2luZyBpcyBhbGxvd2VkLlxyXG4gICAgcHJpdmF0ZSBwaWlMb2dnaW5nRW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBDYWxsYmFjayB0byBzZW5kIG1lc3NhZ2VzIHRvLlxyXG4gICAgcHJpdmF0ZSBsb2NhbENhbGxiYWNrOiBJTG9nZ2VyQ2FsbGJhY2s7XHJcblxyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChsb2dnZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxDYWxsYmFjayA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMucGlpTG9nZ2luZ0VuYWJsZWQgPSBsb2dnZXJPcHRpb25zLnBpaUxvZ2dpbmdFbmFibGVkO1xyXG4gICAgICAgICAgICB0aGlzLmxldmVsID0gbG9nZ2VyT3B0aW9ucy5sb2dMZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgbWVzc2FnZSB3aXRoIHJlcXVpcmVkIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9nTWVzc2FnZShsb2dNZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IExvZ2dlck1lc3NhZ2VPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLmxvZ0xldmVsID4gdGhpcy5sZXZlbCkgfHwgKCF0aGlzLnBpaUxvZ2dpbmdFbmFibGVkICYmIG9wdGlvbnMuY29udGFpbnNQaWkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGxvZ0hlYWRlcjogc3RyaW5nID0gU3RyaW5nVXRpbHMuaXNFbXB0eSh0aGlzLmNvcnJlbGF0aW9uSWQpID8gYFske3RpbWVzdGFtcH1dIDogYCA6IGBbJHt0aW1lc3RhbXB9XSA6IFske3RoaXMuY29ycmVsYXRpb25JZH1dYDtcclxuICAgICAgICBjb25zdCBsb2cgPSBgJHtsb2dIZWFkZXJ9IDogJHtwa2cudmVyc2lvbn0gOiAke0xvZ0xldmVsW29wdGlvbnMubG9nTGV2ZWxdfSAtICR7bG9nTWVzc2FnZX1gO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrKG9wdGlvbnMubG9nTGV2ZWwsIGxvZywgb3B0aW9ucy5jb250YWluc1BpaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIGNhbGxiYWNrIHdpdGggbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgZXhlY3V0ZUNhbGxiYWNrKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nLCBjb250YWluc1BpaTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmxvY2FsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbENhbGxiYWNrKGxldmVsLCBtZXNzYWdlLCBjb250YWluc1BpaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBlcnJvciBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkVycm9yLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgXCJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBlcnJvciBtZXNzYWdlcyB3aXRoIFBJSS5cclxuICAgICAqL1xyXG4gICAgZXJyb3JQaWkobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkVycm9yLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogdHJ1ZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBcIlwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHdhcm5pbmcobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLldhcm5pbmcsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiBmYWxzZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBcIlwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMgd2l0aCBQSUkuXHJcbiAgICAgKi9cclxuICAgIHdhcm5pbmdQaWkobWVzc2FnZTogc3RyaW5nLCBjb3JyZWxhdGlvbklkPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLldhcm5pbmcsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiB0cnVlLFxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IFwiXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgaW5mbyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xyXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSW5mbyxcclxuICAgICAgICAgICAgY29udGFpbnNQaWk6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IFwiXCJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgaW5mbyBtZXNzYWdlcyB3aXRoIFBJSS5cclxuICAgICAqL1xyXG4gICAgaW5mb1BpaShtZXNzYWdlOiBzdHJpbmcsIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xyXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSW5mbyxcclxuICAgICAgICAgICAgY29udGFpbnNQaWk6IHRydWUsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgXCJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB2ZXJib3NlIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICB2ZXJib3NlKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XHJcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5WZXJib3NlLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgXCJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB2ZXJib3NlIG1lc3NhZ2VzIHdpdGggUElJLlxyXG4gICAgICovXHJcbiAgICB2ZXJib3NlUGlpKG1lc3NhZ2U6IHN0cmluZywgY29ycmVsYXRpb25JZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XHJcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5WZXJib3NlLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogdHJ1ZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBcIlwiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgUElJIExvZ2dpbmcgaXMgZW5hYmxlZCBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIGlzUGlpTG9nZ2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGlpTG9nZ2luZ0VuYWJsZWQgfHwgZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IElDYWNoZVN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vY2FjaGUvSUNhY2hlU3RvcmFnZVwiO1xyXG5pbXBvcnQgeyBJTmV0d29ya01vZHVsZSB9IGZyb20gXCIuLi8uLi9uZXR3b3JrL0lOZXR3b3JrTW9kdWxlXCI7XHJcbmltcG9ydCB7IElDcnlwdG8sIFBrY2VDb2RlcyB9IGZyb20gXCIuLi8uLi9jcnlwdG8vSUNyeXB0b1wiO1xyXG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3IvQXV0aEVycm9yXCI7XHJcbmltcG9ydCB7IElMb2dnZXJDYWxsYmFjaywgTG9nTGV2ZWwgfSBmcm9tIFwiLi4vLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuLy8gVG9rZW4gcmVuZXdhbCBvZmZzZXQgZGVmYXVsdCBpbiBzZWNvbmRzXHJcbmNvbnN0IERFRkFVTFRfVE9LRU5fUkVORVdBTF9PRkZTRVRfU0VDID0gMzAwO1xyXG5cclxuLyoqXHJcbiAqIFVzZSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gY29uZmlndXJlIE1TQUwgTW9kdWxlcyBhbmQgaW5pdGlhbGl6ZSB0aGUgYmFzZSBpbnRlcmZhY2VzIGZvciBNU0FMLlxyXG4gKlxyXG4gKiBUaGlzIG9iamVjdCBhbGxvd3MgeW91IHRvIGNvbmZpZ3VyZSBpbXBvcnRhbnQgZWxlbWVudHMgb2YgTVNBTCBmdW5jdGlvbmFsaXR5OlxyXG4gKiAtIGxvZ2dlcjogbG9nZ2luZyBmb3IgYXBwbGljYXRpb25cclxuICogLSBzdG9yYWdlOiB0aGlzIGlzIHdoZXJlIHlvdSBjb25maWd1cmUgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbi5cclxuICogLSBuZXR3b3JrOiB0aGlzIGlzIHdoZXJlIHlvdSBjYW4gY29uZmlndXJlIG5ldHdvcmsgaW1wbGVtZW50YXRpb24uXHJcbiAqIC0gY3J5cHRvOiBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gZnVuY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBNb2R1bGVDb25maWd1cmF0aW9uID0ge1xyXG4gICAgc3lzdGVtT3B0aW9ucz86IFN5c3RlbU9wdGlvbnMsXHJcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcclxuICAgIHN0b3JhZ2VJbnRlcmZhY2U/OiBJQ2FjaGVTdG9yYWdlLFxyXG4gICAgbmV0d29ya0ludGVyZmFjZT86IElOZXR3b3JrTW9kdWxlLFxyXG4gICAgY3J5cHRvSW50ZXJmYWNlPzogSUNyeXB0b1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlbGVtZXRyeSBDb25maWcgT3B0aW9uc1xyXG4gKiAtIGFwcGxpY2F0aW9uTmFtZSAgICAgICAgICAgICAgLSBOYW1lIG9mIHRoZSBjb25zdW1pbmcgYXBwcyBhcHBsaWNhdGlvblxyXG4gKiAtIGFwcGxpY2F0aW9uVmVyc2lvbiAgICAgICAgICAgLSBWZXJpc29uIG9mIHRoZSBjb25zdW1pbmcgYXBwbGljYXRpb25cclxuICogLSB0ZWxlbWV0cnlFbWl0dGVyICAgICAgICAgICAgIC0gRnVuY3Rpb24gd2hlcmUgdGVsZW1ldHJ5IGV2ZW50cyBhcmUgZmx1c2hlZCB0b1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgVGVsZW1ldHJ5T3B0aW9ucyA9IHtcclxuICAgIGFwcGxpY2F0aW9uTmFtZTogc3RyaW5nO1xyXG4gICAgYXBwbGljYXRpb25WZXJzaW9uOiBzdHJpbmc7XHJcbiAgICAvLyBUT0RPLCBhZGQgb25seUFkZEZhaWx1cmVUZWxlbWV0cnkgb3B0aW9uXHJcbn07XHJcblxyXG4vKipcclxuICogTGlicmFyeSBTcGVjaWZpYyBPcHRpb25zXHJcbiAqXHJcbiAqIC0gdG9rZW5SZW5ld2FsT2Zmc2V0U2Vjb25kcyAgICAtIHNldHMgdGhlIHdpbmRvdyBvZiBvZmZzZXQgbmVlZGVkIHRvIHJlbmV3IHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJ5XHJcbiAqIC0gdGVsZW1ldHJ5ICAgICAgICAgICAgICAgICAgICAtIFRlbGVtZXRyeSBvcHRpb25zIGZvciBsaWJyYXJ5IG5ldHdvcmsgcmVxdWVzdHNcclxuICovXHJcbmV4cG9ydCB0eXBlIFN5c3RlbU9wdGlvbnMgPSB7XHJcbiAgICB0b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzPzogbnVtYmVyO1xyXG4gICAgdGVsZW1ldHJ5PzogVGVsZW1ldHJ5T3B0aW9uc1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvZ2dlciBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgbG9nZ2luZyB0aGF0IE1TQUwgZG9lcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIExvZ2dlck9wdGlvbnMgPSB7XHJcbiAgICBsb2dnZXJDYWxsYmFjaz86IElMb2dnZXJDYWxsYmFjayxcclxuICAgIHBpaUxvZ2dpbmdFbmFibGVkPzogYm9vbGVhbixcclxuICAgIGxvZ0xldmVsPzogTG9nTGV2ZWxcclxufTtcclxuXHJcbi8vIERlZmF1bHQgbW9kdWxlIHN5c3RlbSBvcHRpb25zXHJcbmNvbnN0IERFRkFVTFRfU1lTVEVNX09QVElPTlM6IFN5c3RlbU9wdGlvbnMgPSB7XHJcbiAgICB0b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzOiBERUZBVUxUX1RPS0VOX1JFTkVXQUxfT0ZGU0VUX1NFQyxcclxuICAgIHRlbGVtZXRyeTogbnVsbFxyXG59O1xyXG5cclxuLy8gRGVmYXVsdCBsb2dnZXIgaW1wbGVtZW50YXRpb25cclxuY29uc3QgREVGQVVMVF9MT0dHRVJfSU1QTEVNRU5UQVRJT046IExvZ2dlck9wdGlvbnMgPSB7XHJcbiAgICBsb2dnZXJDYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdEltcGxFcnIgPSBcIkxvZ2dlciAtIGxvZ2dlckNhbGxiYWNrSW50ZXJmYWNlKCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkLlwiO1xyXG4gICAgICAgIHRocm93IEF1dGhFcnJvci5jcmVhdGVVbmV4cGVjdGVkRXJyb3Iobm90SW1wbEVycik7XHJcbiAgICB9LFxyXG4gICAgcGlpTG9nZ2luZ0VuYWJsZWQ6IGZhbHNlLFxyXG4gICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm9cclxufTtcclxuXHJcbi8vIERlZmF1bHQgc3RvcmFnZSBpbXBsZW1lbnRhdGlvblxyXG5jb25zdCBERUZBVUxUX1NUT1JBR0VfSU1QTEVNRU5UQVRJT046IElDYWNoZVN0b3JhZ2UgPSB7XHJcbiAgICBjbGVhcjogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdEltcGxFcnIgPSBcIlN0b3JhZ2UgaW50ZXJmYWNlIC0gY2xlYXIoKSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBjYWNoZVN0b3JhZ2UgaW50ZXJmYWNlLlwiO1xyXG4gICAgICAgIHRocm93IEF1dGhFcnJvci5jcmVhdGVVbmV4cGVjdGVkRXJyb3Iobm90SW1wbEVycik7XHJcbiAgICB9LFxyXG4gICAgY29udGFpbnNLZXk6ICgpOiBib29sZWFuID0+IHtcclxuICAgICAgICBjb25zdCBub3RJbXBsRXJyID0gXCJTdG9yYWdlIGludGVyZmFjZSAtIGNvbnRhaW5zS2V5KCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgY2FjaGVTdG9yYWdlIGludGVyZmFjZS5cIjtcclxuICAgICAgICB0aHJvdyBBdXRoRXJyb3IuY3JlYXRlVW5leHBlY3RlZEVycm9yKG5vdEltcGxFcnIpO1xyXG4gICAgfSxcclxuICAgIGdldEl0ZW06ICgpOiBzdHJpbmcgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdEltcGxFcnIgPSBcIlN0b3JhZ2UgaW50ZXJmYWNlIC0gZ2V0SXRlbSgpIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIGNhY2hlU3RvcmFnZSBpbnRlcmZhY2UuXCI7XHJcbiAgICAgICAgdGhyb3cgQXV0aEVycm9yLmNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihub3RJbXBsRXJyKTtcclxuICAgIH0sXHJcbiAgICBnZXRLZXlzOiAoKTogc3RyaW5nW10gPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdEltcGxFcnIgPSBcIlN0b3JhZ2UgaW50ZXJmYWNlIC0gZ2V0S2V5cygpIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIGNhY2hlU3RvcmFnZSBpbnRlcmZhY2UuXCI7XHJcbiAgICAgICAgdGhyb3cgQXV0aEVycm9yLmNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihub3RJbXBsRXJyKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVJdGVtOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm90SW1wbEVyciA9IFwiU3RvcmFnZSBpbnRlcmZhY2UgLSByZW1vdmVJdGVtKCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgY2FjaGVTdG9yYWdlIGludGVyZmFjZS5cIjtcclxuICAgICAgICB0aHJvdyBBdXRoRXJyb3IuY3JlYXRlVW5leHBlY3RlZEVycm9yKG5vdEltcGxFcnIpO1xyXG4gICAgfSxcclxuICAgIHNldEl0ZW06ICgpID0+IHtcclxuICAgICAgICBjb25zdCBub3RJbXBsRXJyID0gXCJTdG9yYWdlIGludGVyZmFjZSAtIHNldEl0ZW0oKSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBjYWNoZVN0b3JhZ2UgaW50ZXJmYWNlLlwiO1xyXG4gICAgICAgIHRocm93IEF1dGhFcnJvci5jcmVhdGVVbmV4cGVjdGVkRXJyb3Iobm90SW1wbEVycik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBEZWZhdWx0IG5ldHdvcmsgaW1wbGVtZW50YXRpb25cclxuY29uc3QgREVGQVVMVF9ORVRXT1JLX0lNUExFTUVOVEFUSU9OOiBJTmV0d29ya01vZHVsZSA9IHtcclxuICAgIGFzeW5jIHNlbmRHZXRSZXF1ZXN0QXN5bmM8VD4oKTogUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgY29uc3Qgbm90SW1wbEVyciA9IFwiTmV0d29yayBpbnRlcmZhY2UgLSBzZW5kR2V0UmVxdWVzdEFzeW5jKCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkXCI7XHJcbiAgICAgICAgdGhyb3cgQXV0aEVycm9yLmNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihub3RJbXBsRXJyKTtcclxuICAgIH0sXHJcbiAgICBhc3luYyBzZW5kUG9zdFJlcXVlc3RBc3luYzxUPigpOiBQcm9taXNlPFQ+IHtcclxuICAgICAgICBjb25zdCBub3RJbXBsRXJyID0gXCJOZXR3b3JrIGludGVyZmFjZSAtIHNlbmRQb3N0UmVxdWVzdEFzeW5jKCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkXCI7XHJcbiAgICAgICAgdGhyb3cgQXV0aEVycm9yLmNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihub3RJbXBsRXJyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIERlZmF1bHQgY3J5cHRvIGltcGxlbWVudGF0aW9uXHJcbmNvbnN0IERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OOiBJQ3J5cHRvID0ge1xyXG4gICAgY3JlYXRlTmV3R3VpZDogKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm90SW1wbEVyciA9IFwiQ3J5cHRvIGludGVyZmFjZSAtIGNyZWF0ZU5ld0d1aWQoKSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWRcIjtcclxuICAgICAgICB0aHJvdyBBdXRoRXJyb3IuY3JlYXRlVW5leHBlY3RlZEVycm9yKG5vdEltcGxFcnIpO1xyXG4gICAgfSxcclxuICAgIGJhc2U2NERlY29kZTogKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm90SW1wbEVyciA9IFwiQ3J5cHRvIGludGVyZmFjZSAtIGJhc2U2NERlY29kZSgpIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZFwiO1xyXG4gICAgICAgIHRocm93IEF1dGhFcnJvci5jcmVhdGVVbmV4cGVjdGVkRXJyb3Iobm90SW1wbEVycik7XHJcbiAgICB9LFxyXG4gICAgYmFzZTY0RW5jb2RlOiAoKTogc3RyaW5nID0+IHtcclxuICAgICAgICBjb25zdCBub3RJbXBsRXJyID0gXCJDcnlwdG8gaW50ZXJmYWNlIC0gYmFzZTY0RW5jb2RlKCkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkXCI7XHJcbiAgICAgICAgdGhyb3cgQXV0aEVycm9yLmNyZWF0ZVVuZXhwZWN0ZWRFcnJvcihub3RJbXBsRXJyKTtcclxuICAgIH0sXHJcbiAgICBhc3luYyBnZW5lcmF0ZVBrY2VDb2RlcygpOiBQcm9taXNlPFBrY2VDb2Rlcz4ge1xyXG4gICAgICAgIGNvbnN0IG5vdEltcGxFcnIgPSBcIkNyeXB0byBpbnRlcmZhY2UgLSBnZW5lcmF0ZVBrY2VDb2RlcygpIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZFwiO1xyXG4gICAgICAgIHRocm93IEF1dGhFcnJvci5jcmVhdGVVbmV4cGVjdGVkRXJyb3Iobm90SW1wbEVycik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gdGhhdCBzZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMgd2hlbiBub3QgZXhwbGljaXRseSBjb25maWd1cmVkIGZyb20gYXBwIGRldmVsb3BlclxyXG4gKlxyXG4gKiBAcGFyYW0gVFN0b3JhZ2VPcHRpb25zXHJcbiAqIEBwYXJhbSBUU3lzdGVtT3B0aW9uc1xyXG4gKiBAcGFyYW0gVEZyYW1ld29ya09wdGlvbnNcclxuICpcclxuICogQHJldHVybnMgTXNhbENvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2R1bGVDb25maWd1cmF0aW9uKHsgc3lzdGVtT3B0aW9uczogdXNlclN5c3RlbU9wdGlvbnMsIGxvZ2dlck9wdGlvbnM6IHVzZXJMb2dnZXJPcHRpb24sIHN0b3JhZ2VJbnRlcmZhY2U6IHN0b3JhZ2VJbXBsZW1lbnRhdGlvbiwgbmV0d29ya0ludGVyZmFjZTogbmV0d29ya0ltcGxlbWVudGF0aW9uLCBjcnlwdG9JbnRlcmZhY2U6IGNyeXB0b0ltcGxlbWVudGF0aW9uIH06IE1vZHVsZUNvbmZpZ3VyYXRpb24pOiBNb2R1bGVDb25maWd1cmF0aW9uIHtcclxuICAgIGNvbnN0IG92ZXJsYXllZENvbmZpZzogTW9kdWxlQ29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICBzeXN0ZW1PcHRpb25zOiB1c2VyU3lzdGVtT3B0aW9ucyB8fCBERUZBVUxUX1NZU1RFTV9PUFRJT05TLFxyXG4gICAgICAgIGxvZ2dlck9wdGlvbnM6IHVzZXJMb2dnZXJPcHRpb24gfHwgREVGQVVMVF9MT0dHRVJfSU1QTEVNRU5UQVRJT04sXHJcbiAgICAgICAgc3RvcmFnZUludGVyZmFjZTogc3RvcmFnZUltcGxlbWVudGF0aW9uIHx8IERFRkFVTFRfU1RPUkFHRV9JTVBMRU1FTlRBVElPTixcclxuICAgICAgICBuZXR3b3JrSW50ZXJmYWNlOiBuZXR3b3JrSW1wbGVtZW50YXRpb24gfHwgREVGQVVMVF9ORVRXT1JLX0lNUExFTUVOVEFUSU9OLFxyXG4gICAgICAgIGNyeXB0b0ludGVyZmFjZTogY3J5cHRvSW1wbGVtZW50YXRpb24gfHwgREVGQVVMVF9DUllQVE9fSU1QTEVNRU5UQVRJT05cclxuICAgIH07XHJcbiAgICByZXR1cm4gb3ZlcmxheWVkQ29uZmlnO1xyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBBY2Nlc3NUb2tlbktleSB9IGZyb20gXCIuL0FjY2Vzc1Rva2VuS2V5XCI7XHJcbmltcG9ydCB7IEFjY2Vzc1Rva2VuVmFsdWUgfSBmcm9tIFwiLi9BY2Nlc3NUb2tlblZhbHVlXCI7XHJcblxyXG4vKipcclxuICogQWNjZXNzIHRva2VuIGNhY2hlIGl0ZW0gd2hpY2ggaXMgdXNlZCB0byBtYW5hZ2UgdG9rZW5zIGFuZCB0b2tlbiByZW5ld2FsLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFjY2Vzc1Rva2VuQ2FjaGVJdGVtIHtcclxuXHJcbiAgICBrZXk6IEFjY2Vzc1Rva2VuS2V5O1xyXG4gICAgdmFsdWU6IEFjY2Vzc1Rva2VuVmFsdWU7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5OiBBY2Nlc3NUb2tlbktleSwgdmFsdWU6IEFjY2Vzc1Rva2VuVmFsdWUpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcblxyXG5leHBvcnQgY29uc3QgQ29uc3RhbnRzID0ge1xyXG4gICAgTElCUkFSWV9OQU1FOiBcIk1TQUwuSlNcIixcclxuICAgIC8vIFByZWZpeCBmb3IgYWxsIGxpYnJhcnkgY2FjaGUgZW50cmllc1xyXG4gICAgQ0FDSEVfUFJFRklYOiBcIm1zYWxcIixcclxuICAgIC8vIGRlZmF1bHQgYXV0aG9yaXR5XHJcbiAgICBERUZBVUxUX0FVVEhPUklUWTogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29tbW9uXCIsXHJcbiAgICAvLyBEZWZhdWx0IEFBRCBJbnN0YW5jZSBEaXNjb3ZlcnkgRW5kcG9pbnRcclxuICAgIEFBRF9JTlNUQU5DRV9ESVNDT1ZFUllfRU5EUFQ6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi9kaXNjb3ZlcnkvaW5zdGFuY2VcIixcclxuICAgIC8vIFJlc291cmNlIGRlbGltaXRlciAtIHVzZWQgZm9yIGNlcnRhaW4gY2FjaGUgZW50cmllc1xyXG4gICAgUkVTT1VSQ0VfREVMSU06IFwifFwiLFxyXG4gICAgLy8gUGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBhY2NvdW50IGlkcy9vYmplY3RzXHJcbiAgICBOT19BQ0NPVU5UOiBcIk5PX0FDQ09VTlRcIixcclxuICAgIC8vIENsYWltc1xyXG4gICAgQ0xBSU1TOiBcImNsYWltc1wiLFxyXG4gICAgLy8gQ29uc3VtZXIgVVRJRFxyXG4gICAgQ09OU1VNRVJfVVRJRDogXCI5MTg4MDQwZC02YzY3LTRjNWItYjExMi0zNmEzMDRiNjZkYWRcIixcclxuICAgIC8vIERlZmF1bHQgc2NvcGVzXHJcbiAgICBPUEVOSURfU0NPUEU6IFwib3BlbmlkXCIsXHJcbiAgICBQUk9GSUxFX1NDT1BFOiBcInByb2ZpbGVcIixcclxuICAgIE9GRkxJTkVfQUNDRVNTX1NDT1BFOiBcIm9mZmxpbmVfYWNjZXNzXCIsXHJcbiAgICAvLyBEZWZhdWx0IHJlc3BvbnNlIHR5cGUgZm9yIGF1dGhvcml6YXRpb24gY29kZSBmbG93XHJcbiAgICBDT0RFX1JFU1BPTlNFX1RZUEU6IFwiY29kZVwiLFxyXG4gICAgQ09ERV9HUkFOVF9UWVBFOiBcImF1dGhvcml6YXRpb25fY29kZVwiLFxyXG4gICAgUlRfR1JBTlRfVFlQRTogXCJyZWZyZXNoX3Rva2VuXCIsXHJcbiAgICBGUkFHTUVOVF9SRVNQT05TRV9NT0RFOiBcImZyYWdtZW50XCIsXHJcbiAgICBTMjU2X0NPREVfQ0hBTExFTkdFX01FVEhPRDogXCJTMjU2XCIsXHJcbiAgICBVUkxfRk9STV9DT05URU5UX1RZUEU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1ZXN0IGhlYWRlciBuYW1lc1xyXG4gKi9cclxuZXhwb3J0IGVudW0gSEVBREVSX05BTUVTIHtcclxuICAgIENPTlRFTlRfVFlQRSA9IFwiQ29udGVudC1UeXBlXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZW1wb3JhcnkgY2FjaGUga2V5cyBmb3IgTVNBTCwgZGVsZXRlZCBhZnRlciBhbnkgcmVxdWVzdC5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRlbXBvcmFyeUNhY2hlS2V5cyB7XHJcbiAgICBBVVRIT1JJVFkgPSBcImF1dGhvcml0eVwiLFxyXG4gICAgQUNRVUlSRV9UT0tFTl9BQ0NPVU5UID0gXCJhY3F1aXJlVG9rZW4uYWNjb3VudFwiLFxyXG4gICAgU0VTU0lPTl9TVEFURSA9IFwic2Vzc2lvbi5zdGF0ZVwiLFxyXG4gICAgUkVRVUVTVF9TVEFURSA9IFwicmVxdWVzdC5zdGF0ZVwiLFxyXG4gICAgTk9OQ0VfSURUT0tFTiA9IFwibm9uY2UuaWR0b2tlblwiLFxyXG4gICAgT1JJR0lOX1VSSSA9IFwicmVxdWVzdC5vcmlnaW5cIixcclxuICAgIFJFTkVXX1NUQVRVUyA9IFwidG9rZW4ucmVuZXcuc3RhdHVzXCIsXHJcbiAgICBVUkxfSEFTSCA9IFwidXJsSGFzaFwiLFxyXG4gICAgUkVRVUVTVF9QQVJBTVMgPSBcInJlcXVlc3QucGFyYW1zXCIsXHJcbiAgICBTQ09QRVMgPSBcInNjb3Blc1wiXHJcbn07XHJcblxyXG4vKipcclxuICogUGVyc2lzdGVudCBjYWNoZSBrZXlzIE1TQUwgd2hpY2ggc3RheSB3aGlsZSB1c2VyIGlzIGxvZ2dlZCBpbi5cclxuICovXHJcbmV4cG9ydCBlbnVtIFBlcnNpc3RlbnRDYWNoZUtleXMge1xyXG4gICAgSURfVE9LRU4gPSBcImlkdG9rZW5cIixcclxuICAgIENMSUVOVF9JTkZPID0gXCJjbGllbnQuaW5mb1wiLFxyXG4gICAgQURBTF9JRF9UT0tFTiA9IFwiYWRhbC5pZHRva2VuXCIsXHJcbiAgICBFUlJPUiA9IFwiZXJyb3JcIixcclxuICAgIEVSUk9SX0RFU0MgPSBcImVycm9yLmRlc2NyaXB0aW9uXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMaXN0IG9mIHByZS1lc3RhYmxpc2hlZCB0cnVzdGVkIGhvc3QgVVJMcy4gXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQUFEVHJ1c3RlZEhvc3RMaXN0OiBzdHJpbmdbXSA9IFtcclxuICAgIFwibG9naW4ud2luZG93cy5uZXRcIixcclxuICAgIFwibG9naW4uY2hpbmFjbG91ZGFwaS5jblwiLFxyXG4gICAgXCJsb2dpbi5jbG91ZGdvdmFwaS51c1wiLFxyXG4gICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tXCIsXHJcbiAgICBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5kZVwiLFxyXG4gICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIlxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIFN0cmluZyBjb25zdGFudHMgcmVsYXRlZCB0byBBQUQgQXV0aG9yaXR5XHJcbiAqL1xyXG5leHBvcnQgZW51bSBBQURBdXRob3JpdHlDb25zdGFudHMge1xyXG4gICAgQ09NTU9OID0gXCJjb21tb25cIixcclxuICAgIE9SR0FOSVpBVElPTlMgPSBcIm9yZ2FuaXphdGlvbnNcIixcclxuICAgIENPTlNVTUVSUyA9IFwiY29uc3VtZXJzXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBLZXlzIGluIHRoZSBoYXNoUGFyYW1zIHNlbnQgYnkgQUFEIFNlcnZlclxyXG4gKi9cclxuZXhwb3J0IGVudW0gQUFEU2VydmVyUGFyYW1LZXlzIHtcclxuICAgIENMSUVOVF9JRCA9IFwiY2xpZW50X2lkXCIsXHJcbiAgICBSRVNPVVJDRSA9IFwicmVzb3VyY2VcIixcclxuICAgIFJFRElSRUNUX1VSSSA9IFwicmVkaXJlY3RfdXJpXCIsXHJcbiAgICBSRVNQT05TRV9UWVBFID0gXCJyZXNwb25zZV90eXBlXCIsXHJcbiAgICBSRVNQT05TRV9NT0RFID0gXCJyZXNwb25zZV9tb2RlXCIsXHJcbiAgICBHUkFOVF9UWVBFID0gXCJncmFudF90eXBlXCIsXHJcbiAgICBDTEFJTVMgPSBcImNsYWltc1wiLFxyXG4gICAgU0NPUEUgPSBcInNjb3BlXCIsXHJcbiAgICBFUlJPUiA9IFwiZXJyb3JcIixcclxuICAgIEVSUk9SX0RFU0NSSVBUSU9OID0gXCJlcnJvcl9kZXNjcmlwdGlvblwiLFxyXG4gICAgQUNDRVNTX1RPS0VOID0gXCJhY2Nlc3NfdG9rZW5cIixcclxuICAgIElEX1RPS0VOID0gXCJpZF90b2tlblwiLFxyXG4gICAgUkVGUkVTSF9UT0tFTiA9IFwicmVmcmVzaF90b2tlblwiLFxyXG4gICAgRVhQSVJFU19JTiA9IFwiZXhwaXJlc19pblwiLFxyXG4gICAgU1RBVEUgPSBcInN0YXRlXCIsXHJcbiAgICBOT05DRSA9IFwibm9uY2VcIixcclxuICAgIFBST01QVCA9IFwicHJvbXB0XCIsXHJcbiAgICBTRVNTSU9OX1NUQVRFID0gXCJzZXNzaW9uX3N0YXRlXCIsXHJcbiAgICBDTElFTlRfSU5GTyA9IFwiY2xpZW50X2luZm9cIixcclxuICAgIENPREUgPSBcImNvZGVcIixcclxuICAgIENPREVfQ0hBTExFTkdFID0gXCJjb2RlX2NoYWxsZW5nZVwiLFxyXG4gICAgQ09ERV9DSEFMTEVOR0VfTUVUSE9EID0gXCJjb2RlX2NoYWxsZW5nZV9tZXRob2RcIixcclxuICAgIENPREVfVkVSSUZJRVIgPSBcImNvZGVfdmVyaWZpZXJcIixcclxuICAgIENMSUVOVF9SRVFVRVNUX0lEID0gXCJjbGllbnQtcmVxdWVzdC1pZFwiLFxyXG4gICAgWF9DTElFTlRfU0tVID0gXCJ4LWNsaWVudC1TS1VcIixcclxuICAgIFhfQ0xJRU5UX1ZFUiA9IFwieC1jbGllbnQtVmVyXCIsXHJcbiAgICBQT1NUX0xPR09VVF9VUkkgPSBcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiXHJcbn07XHJcblxyXG4vKipcclxuICogSWRUb2tlbiBjbGFpbSBzdHJpbmcgY29uc3RhbnRzXHJcbiAqL1xyXG5leHBvcnQgZW51bSBJZFRva2VuQ2xhaW1OYW1lIHtcclxuICAgIElTU1VFUiA9IFwiaXNzXCIsXHJcbiAgICBPQkpJRCA9IFwib2lkXCIsXHJcbiAgICBTVUJKRUNUID0gXCJzdWJcIixcclxuICAgIFRFTkFOVElEID0gXCJ0aWRcIixcclxuICAgIFZFUlNJT04gPSBcInZlclwiLFxyXG4gICAgUFJFRl9VU0VSTkFNRSA9IFwicHJlZmVycmVkX3VzZXJuYW1lXCIsXHJcbiAgICBOQU1FID0gXCJuYW1lXCIsXHJcbiAgICBOT05DRSA9IFwibm9uY2VcIixcclxuICAgIEVYUElSQVRJT04gPSBcImV4cFwiLFxyXG4gICAgSE9NRV9PQkpJRCA9IFwiaG9tZV9vaWRcIixcclxuICAgIFNFU1NJT05JRCA9IFwic2lkXCIsXHJcbiAgICBDTE9VRF9JTlNUQU5DRV9IT1NUTkFNRSA9IFwiY2xvdWRfaW5zdGFuY2VfaG9zdF9uYW1lXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIHdlIGNvbnNpZGVyZWQgbWFraW5nIHRoaXMgXCJlbnVtXCIgaW4gdGhlIHJlcXVlc3QgaW5zdGVhZCBvZiBzdHJpbmcsIGhvd2V2ZXIgaXQgbG9va3MgbGlrZSB0aGUgYWxsb3dlZCBsaXN0IG9mXHJcbiAqIHByb21wdCB2YWx1ZXMga2VwdCBjaGFuZ2luZyBvdmVyIHBhc3QgY291cGxlIG9mIHllYXJzLiBUaGVyZSBhcmUgc29tZSB1bmRvY3VtZW50ZWQgcHJvbXB0IHZhbHVlcyBmb3Igc29tZVxyXG4gKiBpbnRlcm5hbCBwYXJ0bmVycyB0b28sIGhlbmNlIHRoZSBjaG9pY2Ugb2YgZ2VuZXJpYyBcInN0cmluZ1wiIHR5cGUgaW5zdGVhZCBvZiB0aGUgXCJlbnVtXCJcclxuICovXHJcbmV4cG9ydCBjb25zdCBQcm9tcHRWYWx1ZSA9IHtcclxuICAgIExPR0lOOiBcImxvZ2luXCIsXHJcbiAgICBTRUxFQ1RfQUNDT1VOVDogXCJzZWxlY3RfYWNjb3VudFwiLFxyXG4gICAgQ09OU0VOVDogXCJjb25zZW50XCIsXHJcbiAgICBOT05FOiBcIm5vbmVcIixcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTU08gVHlwZXMgLSBnZW5lcmF0ZWQgdG8gcG9wdWxhdGUgaGludHNcclxuICovXHJcbmV4cG9ydCBlbnVtIFNTT1R5cGVzIHtcclxuICAgIEFDQ09VTlQgPSBcImFjY291bnRcIixcclxuICAgIFNJRCA9IFwic2lkXCIsXHJcbiAgICBMT0dJTl9ISU5UID0gXCJsb2dpbl9oaW50XCIsXHJcbiAgICBJRF9UT0tFTiA9XCJpZF90b2tlblwiLFxyXG4gICAgRE9NQUlOX0hJTlQgPSBcImRvbWFpbl9oaW50XCIsXHJcbiAgICBPUkdBTklaQVRJT05TID0gXCJvcmdhbml6YXRpb25zXCIsXHJcbiAgICBDT05TVU1FUlMgPSBcImNvbnN1bWVyc1wiLFxyXG4gICAgQUNDT1VOVF9JRCA9IFwiYWNjb3VudElkZW50aWZpZXJcIixcclxuICAgIEhPTUVBQ0NPVU5UX0lEID0gXCJob21lQWNjb3VudElkZW50aWZpZXJcIlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc2FsbG93ZWQgZXh0cmEgcXVlcnkgcGFyYW1ldGVycy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBCbGFja2xpc3RlZEVRUGFyYW1zID0gW1xyXG4gICAgU1NPVHlwZXMuU0lELFxyXG4gICAgU1NPVHlwZXMuTE9HSU5fSElOVFxyXG5dO1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgQWNjZXNzVG9rZW5DYWNoZUl0ZW0gfSBmcm9tIFwiLi9BY2Nlc3NUb2tlbkNhY2hlSXRlbVwiO1xyXG5pbXBvcnQgeyBBY2Nlc3NUb2tlbktleSB9IGZyb20gXCIuL0FjY2Vzc1Rva2VuS2V5XCI7XHJcbmltcG9ydCB7IEFjY2Vzc1Rva2VuVmFsdWUgfSBmcm9tIFwiLi9BY2Nlc3NUb2tlblZhbHVlXCI7XHJcbmltcG9ydCB7IElDYWNoZVN0b3JhZ2UgfSBmcm9tIFwiLi9JQ2FjaGVTdG9yYWdlXCI7XHJcbmltcG9ydCB7IEFjY291bnQgfSBmcm9tIFwiLi4vYXV0aC9BY2NvdW50XCI7XHJcbmltcG9ydCB7IEF1dGhvcml0eSB9IGZyb20gXCIuLi9hdXRoL2F1dGhvcml0eS9BdXRob3JpdHlcIjtcclxuaW1wb3J0IHsgU2VydmVyQ29kZVJlcXVlc3RQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3NlcnZlci9TZXJ2ZXJDb2RlUmVxdWVzdFBhcmFtZXRlcnNcIjtcclxuaW1wb3J0IHsgQ2xpZW50QXV0aEVycm9yIH0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvclwiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBUZW1wb3JhcnlDYWNoZUtleXMsIENvbnN0YW50cyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgQ2FjaGVIZWxwZXJzIGNsYXNzIGNvbnRhaW5zIGEgc2V0IG9mIGhlbHBlciBmdW5jdGlvbnMgdXNlZCBieSB0aGUgbW9kdWxlIHRvIG1hbmFnZSBjYWNoZSBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDYWNoZUhlbHBlcnMge1xyXG5cclxuICAgIC8vIFN0b3JhZ2UgaW50ZXJmYWNlXHJcbiAgICBwcml2YXRlIGNhY2hlU3RvcmFnZTogSUNhY2hlU3RvcmFnZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYWNoZUltcGw6IElDYWNoZVN0b3JhZ2UpIHtcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZSA9IGNhY2hlSW1wbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhY3F1aXJlVG9rZW5BY2NvdW50S2V5IHRvIGNhY2hlIGFjY291bnQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudElkXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVBY3F1aXJlVG9rZW5BY2NvdW50S2V5KGFjY291bnRJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gYCR7VGVtcG9yYXJ5Q2FjaGVLZXlzLkFDUVVJUkVfVE9LRU5fQUNDT1VOVH0ke0NvbnN0YW50cy5SRVNPVVJDRV9ERUxJTX0ke2FjY291bnRJZH1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGF1dGhvcml0eUtleSB0byBjYWNoZSBhdXRob3JpdHlcclxuICAgICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUF1dGhvcml0eUtleShzdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gYCR7VGVtcG9yYXJ5Q2FjaGVLZXlzLkFVVEhPUklUWX0ke0NvbnN0YW50cy5SRVNPVVJDRV9ERUxJTX0ke3N0YXRlfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgTm9uY2Uga2V5IHRvIGNhY2hlIG5vbmNlXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlTm9uY2VLZXkoc3RhdGU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGAke1RlbXBvcmFyeUNhY2hlS2V5cy5OT05DRV9JRFRPS0VOfSR7Q29uc3RhbnRzLlJFU09VUkNFX0RFTElNfSR7c3RhdGV9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNhY2hla2V5cyBmb3IgYW5kIHN0b3JlcyB0aGUgYWNjb3VudCBpbmZvcm1hdGlvbiBpbiBjYWNoZVxyXG4gICAgICogQHBhcmFtIGFjY291bnRcclxuICAgICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBzZXRBY2NvdW50Q2FjaGUoYWNjb3VudDogQWNjb3VudCk6IHZvaWQge1xyXG4gICAgICAgIC8vIENhY2hlIGFjcXVpcmVUb2tlbkFjY291bnRLZXlcclxuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBhY2NvdW50ICYmIGFjY291bnQuaG9tZUFjY291bnRJZGVudGlmaWVyID8gYWNjb3VudC5ob21lQWNjb3VudElkZW50aWZpZXIgOiBDb25zdGFudHMuTk9fQUNDT1VOVDtcclxuXHJcbiAgICAgICAgY29uc3QgYWNxdWlyZVRva2VuQWNjb3VudEtleSA9IHRoaXMuZ2VuZXJhdGVBY3F1aXJlVG9rZW5BY2NvdW50S2V5KGFjY291bnRJZCk7XHJcbiAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2Uuc2V0SXRlbShhY3F1aXJlVG9rZW5BY2NvdW50S2V5LCBKU09OLnN0cmluZ2lmeShhY2NvdW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjYWNoZUtleSBmb3IgYW5kIHN0b3JlcyB0aGUgYXV0aG9yaXR5IGluZm9ybWF0aW9uIGluIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVcclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlcclxuICAgICAqL1xyXG4gICAgc2V0QXV0aG9yaXR5Q2FjaGUoYXV0aG9yaXR5OiBBdXRob3JpdHksIHN0YXRlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICAvLyBDYWNoZSBhdXRob3JpdHlLZXlcclxuICAgICAgICBjb25zdCBhdXRob3JpdHlLZXkgPSB0aGlzLmdlbmVyYXRlQXV0aG9yaXR5S2V5KHN0YXRlKTtcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5zZXRJdGVtKGF1dGhvcml0eUtleSwgYXV0aG9yaXR5LmNhbm9uaWNhbEF1dGhvcml0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFjY291bnQsIGF1dGhvcml0eSwgYW5kIHN0YXRlIGluIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyQXV0aGVudGljYXRpb25SZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDYWNoZUVudHJpZXMoc2VydmVyQXV0aGVudGljYXRpb25SZXF1ZXN0OiBTZXJ2ZXJDb2RlUmVxdWVzdFBhcmFtZXRlcnMsIGFjY291bnQ6IEFjY291bnQpOiB2b2lkIHtcclxuICAgICAgICAvLyBDYWNoZSBhY2NvdW50IGFuZCBzdGF0ZVxyXG4gICAgICAgIGlmIChhY2NvdW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QWNjb3VudENhY2hlKGFjY291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIHJlcXVlc3Qgc3RhdGVcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5zZXRJdGVtKFRlbXBvcmFyeUNhY2hlS2V5cy5SRVFVRVNUX1NUQVRFLCBzZXJ2ZXJBdXRoZW50aWNhdGlvblJlcXVlc3Quc3RhdGUpO1xyXG5cclxuICAgICAgICAvLyBDYWNoZSB0aGUgbm9uY2VcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5zZXRJdGVtKHRoaXMuZ2VuZXJhdGVOb25jZUtleShzZXJ2ZXJBdXRoZW50aWNhdGlvblJlcXVlc3Quc3RhdGUpLCBzZXJ2ZXJBdXRoZW50aWNhdGlvblJlcXVlc3Qubm9uY2UpO1xyXG5cclxuICAgICAgICAvLyBDYWNoZSBhdXRob3JpdHlLZXlcclxuICAgICAgICB0aGlzLnNldEF1dGhvcml0eUNhY2hlKHNlcnZlckF1dGhlbnRpY2F0aW9uUmVxdWVzdC5hdXRob3JpdHlJbnN0YW5jZSwgc2VydmVyQXV0aGVudGljYXRpb25SZXF1ZXN0LnN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGFsbCB0ZW1wb3JhcnkgY2FjaGUgaXRlbXNcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBcclxuICAgICAqL1xyXG4gICAgcmVzZXRUZW1wQ2FjaGVJdGVtcyhzdGF0ZT86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIC8vIGNoZWNrIHN0YXRlIGFuZCByZW1vdmUgYXNzb2NpYXRlZCBjYWNoZSBpdGVtc1xyXG4gICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLmdldEtleXMoKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghU3RyaW5nVXRpbHMuaXNFbXB0eShzdGF0ZSkgJiYga2V5LmluZGV4T2Yoc3RhdGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRLZXkgPSBrZXkuc3BsaXQoQ29uc3RhbnRzLlJFU09VUkNFX0RFTElNKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleVN0YXRlID0gc3BsaXRLZXkubGVuZ3RoID4gMSA/IHNwbGl0S2V5W3NwbGl0S2V5Lmxlbmd0aC0xXTogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlTdGF0ZSA9PT0gc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBkZWxldGUgZ2VuZXJpYyBpbnRlcmFjdGl2ZSByZXF1ZXN0IHBhcmFtZXRlcnNcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5yZW1vdmVJdGVtKFRlbXBvcmFyeUNhY2hlS2V5cy5SRVFVRVNUX1NUQVRFKTtcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5yZW1vdmVJdGVtKFRlbXBvcmFyeUNhY2hlS2V5cy5SRVFVRVNUX1BBUkFNUyk7XHJcbiAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2UucmVtb3ZlSXRlbShUZW1wb3JhcnlDYWNoZUtleXMuT1JJR0lOX1VSSSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIGFjY2VzcyB0b2tlbnMgaW4gdGhlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWRcclxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkZW50aWZpZXJcclxuICAgICAqL1xyXG4gICAgZ2V0QWxsQWNjZXNzVG9rZW5zKGNsaWVudElkOiBzdHJpbmcsIGF1dGhvcml0eTogc3RyaW5nLCByZXNvdXJjZT86IHN0cmluZywgaG9tZUFjY291bnRJZGVudGlmaWVyPzogc3RyaW5nKTogQXJyYXk8QWNjZXNzVG9rZW5DYWNoZUl0ZW0+IHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0S2V5cygpLnJlZHVjZTxBcnJheTxBY2Nlc3NUb2tlbkNhY2hlSXRlbT4+KCh0b2tlbnMsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlNYXRjaGVzID0ga2V5Lm1hdGNoKGNsaWVudElkKSAmJiBrZXkubWF0Y2goYXV0aG9yaXR5KSAmJiBrZXkubWF0Y2gocmVzb3VyY2UpICYmIGtleS5tYXRjaChob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAoa2V5TWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhY2hlU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZUF0S2V5ID0gSlNPTi5wYXJzZShrZXkpIGFzIEFjY2Vzc1Rva2VuS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0ZvckV4YWN0S2V5TWF0Y2gocGFyc2VBdEtleSwgY2xpZW50SWQsIGF1dGhvcml0eSwgcmVzb3VyY2UsIGhvbWVBY2NvdW50SWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FjY2Vzc1Rva2VuQ2FjaGVJdGVtID0gbmV3IEFjY2Vzc1Rva2VuQ2FjaGVJdGVtKHBhcnNlQXRLZXksIEpTT04ucGFyc2UodmFsdWUpIGFzIEFjY2Vzc1Rva2VuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5jb25jYXQoWyBuZXdBY2Nlc3NUb2tlbkNhY2hlSXRlbSBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUNhY2hlUGFyc2VFcnJvcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGFjY2VzcyB0b2tlbnMgaW4gdGhlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWRcclxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkZW50aWZpZXJcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsQWNjZXNzVG9rZW5zKGNsaWVudElkOiBzdHJpbmcsIGF1dGhvcml0eTogc3RyaW5nLCByZXNvdXJjZT86IHN0cmluZywgaG9tZUFjY291bnRJZGVudGlmaWVyPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0S2V5cygpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlNYXRjaGVzID0ga2V5Lm1hdGNoKGNsaWVudElkKSAmJiBrZXkubWF0Y2goYXV0aG9yaXR5KSAmJiBrZXkubWF0Y2gocmVzb3VyY2UpICYmIGtleS5tYXRjaChob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAoa2V5TWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZUF0S2V5ID0gSlNPTi5wYXJzZShrZXkpIGFzIEFjY2Vzc1Rva2VuS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrRm9yRXhhY3RLZXlNYXRjaChwYXJzZUF0S2V5LCBjbGllbnRJZCwgYXV0aG9yaXR5LCByZXNvdXJjZSwgaG9tZUFjY291bnRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVDYWNoZVBhcnNlRXJyb3Ioa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoYXQgYW55IHBhcmFtZXRlcnMgYXJlIGV4YWN0IG1hdGNoZXMgZm9yIGtleSB2YWx1ZSwgc2luY2Uga2V5Lm1hdGNoIGluIHRoZSBhYm92ZSBmdW5jdGlvbnMgb25seSBkbyBjb250YWlucyBjaGVja3MsIG5vdCBleGFjdCBtYXRjaGVzLlxyXG4gICAgICogQHBhcmFtIGF0S2V5IFxyXG4gICAgICogQHBhcmFtIGNsaWVudElkIFxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eSBcclxuICAgICAqIEBwYXJhbSByZXNvdXJjZSBcclxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkZW50aWZpZXIgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tGb3JFeGFjdEtleU1hdGNoKGF0S2V5OiBBY2Nlc3NUb2tlbktleSwgY2xpZW50SWQ6IHN0cmluZywgYXV0aG9yaXR5OiBzdHJpbmcsIHJlc291cmNlPzogc3RyaW5nLCBob21lQWNjb3VudElkZW50aWZpZXI/OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBoYXNDbGllbnRJZCA9IChhdEtleS5jbGllbnRJZCA9PT0gY2xpZW50SWQpO1xyXG4gICAgICAgIC8vIElmIGFueSBpbnB1dHMgYXJlIGVtcHR5LCByZXR1cm4gdHJ1ZSBzbyB3ZSBkb24ndCBmYWlsIHRoZSBjaGVjay5cclxuICAgICAgICBjb25zdCBoYXNBdXRob3JpdHlVcmkgPSBTdHJpbmdVdGlscy5pc0VtcHR5KGF1dGhvcml0eSkgfHwgKGF0S2V5LmF1dGhvcml0eSA9PT0gYXV0aG9yaXR5KTtcclxuICAgICAgICBjb25zdCBoYXNSZXNvdXJjZVVyaSA9IFN0cmluZ1V0aWxzLmlzRW1wdHkocmVzb3VyY2UpIHx8IChhdEtleS5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpO1xyXG4gICAgICAgIGNvbnN0IGhhc0hvbWVBY2NvdW50SWQgPSBTdHJpbmdVdGlscy5pc0VtcHR5KGhvbWVBY2NvdW50SWRlbnRpZmllcikgfHwgKGF0S2V5LmhvbWVBY2NvdW50SWRlbnRpZmllciA9PT0gaG9tZUFjY291bnRJZGVudGlmaWVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhhc0NsaWVudElkICYmIGhhc0F1dGhvcml0eVVyaSAmJiBoYXNSZXNvdXJjZVVyaSAmJiBoYXNIb21lQWNjb3VudElkO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBDbGllbnRJbmZvIH0gZnJvbSBcIi4vQ2xpZW50SW5mb1wiO1xyXG5pbXBvcnQgeyBJZFRva2VuIH0gZnJvbSBcIi4vSWRUb2tlblwiO1xyXG5pbXBvcnQgeyBJZFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4vSWRUb2tlbkNsYWltc1wiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBJQ3J5cHRvIH0gZnJvbSBcIi4uL2NyeXB0by9JQ3J5cHRvXCI7XHJcblxyXG4vKipcclxuICogYWNjb3VudElkZW50aWZpZXIgICAgICAgY29tYmluYXRpb24gb2YgaWRUb2tlbi51aWQgYW5kIGlkVG9rZW4udXRpZFxyXG4gKiBob21lQWNjb3VudElkZW50aWZpZXIgICBjb21iaW5hdGlvbiBvZiBjbGllbnRJbmZvLnVpZCBhbmQgY2xpZW50SW5mby51dGlkXHJcbiAqIHVzZXJOYW1lICAgICAgICAgICAgICAgIGlkVG9rZW4ucHJlZmVycmVkX3VzZXJuYW1lXHJcbiAqIG5hbWUgICAgICAgICAgICAgICAgICAgIGlkVG9rZW4ubmFtZVxyXG4gKiBpZFRva2VuICAgICAgICAgICAgICAgICBpZFRva2VuXHJcbiAqIHNpZCAgICAgICAgICAgICAgICAgICAgIGlkVG9rZW4uc2lkIC0gc2Vzc2lvbiBpZGVudGlmaWVyXHJcbiAqIGVudmlyb25tZW50ICAgICAgICAgICAgIGlkdG9rZW4uaXNzdWVyICh0aGUgYXV0aG9yaXR5IHRoYXQgaXNzdWVzIHRoZSB0b2tlbilcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBY2NvdW50IHtcclxuXHJcbiAgICBhY2NvdW50SWRlbnRpZmllcjogc3RyaW5nO1xyXG4gICAgaG9tZUFjY291bnRJZGVudGlmaWVyOiBzdHJpbmc7XHJcbiAgICB1c2VyTmFtZTogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgaWRUb2tlbjogc3RyaW5nO1xyXG4gICAgaWRUb2tlbkNsYWltczogSWRUb2tlbkNsYWltcztcclxuICAgIHNpZDogc3RyaW5nO1xyXG4gICAgZW52aXJvbm1lbnQ6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gQWNjb3VudCBPYmplY3RcclxuICAgICAqIEBwcmFyYW0gYWNjb3VudElkZW50aWZpZXJcclxuICAgICAqIEBwYXJhbSBob21lQWNjb3VudElkZW50aWZpZXJcclxuICAgICAqIEBwYXJhbSB1c2VyTmFtZVxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqIEBwYXJhbSBpZFRva2VuXHJcbiAgICAgKiBAcGFyYW0gc2lkXHJcbiAgICAgKiBAcGFyYW0gZW52aXJvbm1lbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWNjb3VudElkZW50aWZpZXI6IHN0cmluZywgaG9tZUFjY291bnRJZGVudGlmaWVyOiBzdHJpbmcsIGlkVG9rZW5DbGFpbXM6IElkVG9rZW5DbGFpbXMsIHJhd0lkVG9rZW46IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuYWNjb3VudElkZW50aWZpZXIgPSBhY2NvdW50SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllciA9IGhvbWVBY2NvdW50SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLnVzZXJOYW1lID0gaWRUb2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gaWRUb2tlbkNsYWltcy5uYW1lO1xyXG4gICAgICAgIC8vIHdpbGwgYmUgZGVwcmVjYXRlZCBzb29uXHJcbiAgICAgICAgdGhpcy5pZFRva2VuID0gcmF3SWRUb2tlbjtcclxuICAgICAgICB0aGlzLmlkVG9rZW5DbGFpbXMgPSBpZFRva2VuQ2xhaW1zO1xyXG4gICAgICAgIHRoaXMuc2lkID0gaWRUb2tlbkNsYWltcy5zaWQ7XHJcbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IGlkVG9rZW5DbGFpbXMuaXNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5cclxuICAgICAqIEBwYXJhbSBjbGllbnRJbmZvXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVBY2NvdW50KGlkVG9rZW46IElkVG9rZW4sIGNsaWVudEluZm86IENsaWVudEluZm8sIGNyeXB0bzogSUNyeXB0byk6IEFjY291bnQge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhY2NvdW50SWRlbnRpZmllclxyXG4gICAgICAgIGNvbnN0IGFjY291bnRJZGVudGlmaWVyOiBzdHJpbmcgPSBpZFRva2VuLmNsYWltcy5vaWQgfHwgIGlkVG9rZW4uY2xhaW1zLnN1YjtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGhvbWVBY2NvdW50SWRlbnRpZmllclxyXG4gICAgICAgIGNvbnN0IHVpZDogc3RyaW5nID0gY2xpZW50SW5mbyA/IGNsaWVudEluZm8udWlkIDogXCJcIjtcclxuICAgICAgICBjb25zdCB1dGlkOiBzdHJpbmcgPSBjbGllbnRJbmZvID8gY2xpZW50SW5mby51dGlkIDogXCJcIjtcclxuXHJcbiAgICAgICAgbGV0IGhvbWVBY2NvdW50SWRlbnRpZmllcjogc3RyaW5nO1xyXG4gICAgICAgIGlmICghU3RyaW5nVXRpbHMuaXNFbXB0eSh1aWQpICYmICFTdHJpbmdVdGlscy5pc0VtcHR5KHV0aWQpKSB7XHJcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWRlbnRpZmllciA9IGNyeXB0by5iYXNlNjRFbmNvZGUodWlkKSArIFwiLlwiICsgY3J5cHRvLmJhc2U2NEVuY29kZSh1dGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KGFjY291bnRJZGVudGlmaWVyLCBob21lQWNjb3VudElkZW50aWZpZXIsIGlkVG9rZW4uY2xhaW1zLCBpZFRva2VuLnJhd0lkVG9rZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbHMgZnVuY3Rpb24gdG8gY29tcGFyZSB0d28gQWNjb3VudCBvYmplY3RzIC0gdXNlZCB0byBjaGVjayBpZiB0aGUgc2FtZSB1c2VyIGFjY291bnQgaXMgbG9nZ2VkIGluXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGExOiBBY2NvdW50IG9iamVjdFxyXG4gICAgICogQHBhcmFtIGEyOiBBY2NvdW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZUFjY291bnRzKGExOiBBY2NvdW50LCBhMjogQWNjb3VudCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICghKGExICYmIGExLmhvbWVBY2NvdW50SWRlbnRpZmllcikgfHwgIShhMiAmJiBhMi5ob21lQWNjb3VudElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGExLmhvbWVBY2NvdW50SWRlbnRpZmllciA9PT0gYTIuaG9tZUFjY291bnRJZGVudGlmaWVyO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBJZFRva2VuQ2xhaW1zIH0gZnJvbSBcIi4vSWRUb2tlbkNsYWltc1wiO1xyXG5pbXBvcnQgeyBEZWNvZGVkSnd0IH0gZnJvbSBcIi4vRGVjb2RlZEp3dFwiO1xyXG5pbXBvcnQgeyBDbGllbnRBdXRoRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yXCI7XHJcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZ1V0aWxzXCI7XHJcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vY3J5cHRvL0lDcnlwdG9cIjtcclxuXHJcbi8qKlxyXG4gKiBJZCBUb2tlbiByZXByZXNlbnRhdGlvbiBjbGFzcy4gUGFyc2VzIGlkIHRva2VuIHN0cmluZyBhbmQgZ2VuZXJhdGVzIGNsYWltcyBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSWRUb2tlbiB7XHJcblxyXG4gICAgLy8gUmF3IElkIFRva2VuIHN0cmluZ1xyXG4gICAgcmF3SWRUb2tlbjogc3RyaW5nO1xyXG4gICAgLy8gQ2xhaW1zIGluc2lkZSBJZCBUb2tlblxyXG4gICAgY2xhaW1zOiBJZFRva2VuQ2xhaW1zO1xyXG4gICAgY29uc3RydWN0b3IocmF3SWRUb2tlbjogc3RyaW5nLCBjcnlwdG86IElDcnlwdG8pIHtcclxuICAgICAgICBpZiAoU3RyaW5nVXRpbHMuaXNFbXB0eShyYXdJZFRva2VuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlSWRUb2tlbk51bGxPckVtcHR5RXJyb3IocmF3SWRUb2tlbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJhd0lkVG9rZW4gPSByYXdJZFRva2VuO1xyXG4gICAgICAgIHRoaXMuY2xhaW1zID0gSWRUb2tlbi5leHRyYWN0SWRUb2tlbihyYXdJZFRva2VuLCBjcnlwdG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdCBJZFRva2VuIGJ5IGRlY29kaW5nIHRoZSBSQVdJZFRva2VuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVuY29kZWRJZFRva2VuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBleHRyYWN0SWRUb2tlbihlbmNvZGVkSWRUb2tlbjogc3RyaW5nLCBjcnlwdG86IElDcnlwdG8pOiBJZFRva2VuQ2xhaW1zIHtcclxuICAgICAgICAvLyBpZCB0b2tlbiB3aWxsIGJlIGRlY29kZWQgdG8gZ2V0IHRoZSB1c2VybmFtZVxyXG4gICAgICAgIGNvbnN0IGRlY29kZWRUb2tlbjogRGVjb2RlZEp3dCA9IFN0cmluZ1V0aWxzLmRlY29kZUp3dChlbmNvZGVkSWRUb2tlbik7XHJcbiAgICAgICAgaWYgKCFkZWNvZGVkVG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NElkVG9rZW5QYXlsb2FkID0gZGVjb2RlZFRva2VuLkpXU1BheWxvYWQ7XHJcbiAgICAgICAgICAgIC8vIGJhc2U2NERlY29kZSgpIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZVxyXG4gICAgICAgICAgICBjb25zdCBiYXNlNjREZWNvZGVkID0gY3J5cHRvLmJhc2U2NERlY29kZShiYXNlNjRJZFRva2VuUGF5bG9hZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NERlY29kZWQpIGFzIElkVG9rZW5DbGFpbXM7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVJZFRva2VuUGFyc2luZ0Vycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgQ2xpZW50QXV0aEVycm9yIH0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvclwiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBJQ3J5cHRvIH0gZnJvbSBcIi4uL2NyeXB0by9JQ3J5cHRvXCI7XHJcblxyXG4vKipcclxuICogQ2xpZW50IGluZm8gb2JqZWN0IHdoaWNoIGNvbnNpc3RzIG9mIHR3byBJRHMuIE5lZWQgdG8gYWRkIG1vcmUgaW5mbyBoZXJlLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ2xpZW50SW5mbyA9IHtcclxuICAgIHVpZDogc3RyaW5nLFxyXG4gICAgdXRpZDogc3RyaW5nXHJcbn07XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gdG8gYnVpbGQgYSBjbGllbnQgaW5mbyBvYmplY3RcclxuICogQHBhcmFtIHJhd0NsaWVudEluZm8gXHJcbiAqIEBwYXJhbSBjcnlwdG8gXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDbGllbnRJbmZvKHJhd0NsaWVudEluZm86IHN0cmluZywgY3J5cHRvOiBJQ3J5cHRvKTogQ2xpZW50SW5mbyB7XHJcbiAgICBpZiAoU3RyaW5nVXRpbHMuaXNFbXB0eShyYXdDbGllbnRJbmZvKSkge1xyXG4gICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVDbGllbnRJbmZvRW1wdHlFcnJvcihyYXdDbGllbnRJbmZvKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRlY29kZWRDbGllbnRJbmZvOiBzdHJpbmcgPSBjcnlwdG8uYmFzZTY0RGVjb2RlKHJhd0NsaWVudEluZm8pO1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWRDbGllbnRJbmZvKSBhcyBDbGllbnRJbmZvO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVDbGllbnRJbmZvRGVjb2RpbmdFcnJvcihlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgTW9kdWxlQ29uZmlndXJhdGlvbiwgYnVpbGRNb2R1bGVDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZy9Nb2R1bGVDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi9yZXF1ZXN0L0F1dGhlbnRpY2F0aW9uUGFyYW1ldGVyc1wiO1xyXG5pbXBvcnQgeyBUb2tlblJlbmV3UGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi9yZXF1ZXN0L1Rva2VuUmVuZXdQYXJhbWV0ZXJzXCI7XHJcbmltcG9ydCB7IENvZGVSZXNwb25zZSB9IGZyb20gXCIuLi8uLi9yZXNwb25zZS9Db2RlUmVzcG9uc2VcIjtcclxuaW1wb3J0IHsgVG9rZW5SZXNwb25zZSB9IGZyb20gXCIuLi8uLi9yZXNwb25zZS9Ub2tlblJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IElDYWNoZVN0b3JhZ2UgfSBmcm9tIFwiLi4vLi4vY2FjaGUvSUNhY2hlU3RvcmFnZVwiO1xyXG5pbXBvcnQgeyBDYWNoZUhlbHBlcnMgfSBmcm9tIFwiLi4vLi4vY2FjaGUvQ2FjaGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7IElOZXR3b3JrTW9kdWxlIH0gZnJvbSBcIi4uLy4uL25ldHdvcmsvSU5ldHdvcmtNb2R1bGVcIjtcclxuaW1wb3J0IHsgSUNyeXB0byB9IGZyb20gXCIuLi8uLi9jcnlwdG8vSUNyeXB0b1wiO1xyXG5pbXBvcnQgeyBBY2NvdW50IH0gZnJvbSBcIi4uLy4uL2F1dGgvQWNjb3VudFwiO1xyXG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi4vLi4vYXV0aC9hdXRob3JpdHkvQXV0aG9yaXR5XCI7XHJcbmltcG9ydCB7IElkVG9rZW4gfSBmcm9tIFwiLi4vLi4vYXV0aC9JZFRva2VuXCI7XHJcbmltcG9ydCB7IGJ1aWxkQ2xpZW50SW5mbyB9IGZyb20gXCIuLi8uLi9hdXRoL0NsaWVudEluZm9cIjtcclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2xvZ2dlci9Mb2dnZXJcIjtcclxuaW1wb3J0IHsgUGVyc2lzdGVudENhY2hlS2V5cyB9IGZyb20gXCIuLi8uLi91dGlscy9Db25zdGFudHNcIjtcclxuXHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqIEBpZ25vcmVcclxuICogRGF0YSB0eXBlIHRvIGhvbGQgaW5mb3JtYXRpb24gYWJvdXQgc3RhdGUgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBSZXNwb25zZVN0YXRlSW5mbyA9IHtcclxuICAgIHN0YXRlOiBzdHJpbmc7XHJcbiAgICBzdGF0ZU1hdGNoOiBib29sZWFuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEF1dGhNb2R1bGUgY2xhc3NcclxuICogXHJcbiAqIFBhcmVudCBvYmplY3QgaW5zdGFuY2Ugd2hpY2ggd2lsbCBjb25zdHJ1Y3QgcmVxdWVzdHMgdG8gc2VuZCB0byBhbmQgaGFuZGxlIHJlc3BvbnNlcyBmcm9tIHRoZSBNaWNyb3NvZnQgU1RTIHVzaW5nIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgZmxvdy5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXV0aE1vZHVsZSB7XHJcblxyXG4gICAgLy8gTG9nZ2VyIG9iamVjdFxyXG4gICAgcHVibGljIGxvZ2dlcjogTG9nZ2VyO1xyXG5cclxuICAgIC8vIEFwcGxpY2F0aW9uIGNvbmZpZ1xyXG4gICAgcHJpdmF0ZSBjb25maWc6IE1vZHVsZUNvbmZpZ3VyYXRpb247XHJcbiAgICBcclxuICAgIC8vIENyeXB0byBJbnRlcmZhY2VcclxuICAgIHByb3RlY3RlZCBjcnlwdG9PYmo6IElDcnlwdG87XHJcblxyXG4gICAgLy8gU3RvcmFnZSBJbnRlcmZhY2VcclxuICAgIHByb3RlY3RlZCBjYWNoZVN0b3JhZ2U6IElDYWNoZVN0b3JhZ2U7XHJcblxyXG4gICAgLy8gTmV0d29yayBJbnRlcmZhY2VcclxuICAgIHByb3RlY3RlZCBuZXR3b3JrQ2xpZW50OiBJTmV0d29ya01vZHVsZTtcclxuXHJcbiAgICAvLyBIZWxwZXIgQVBJIG9iamVjdCBmb3IgcnVubmluZyBjYWNoZSBmdW5jdGlvbnNcclxuICAgIHByb3RlY3RlZCBjYWNoZU1hbmFnZXI6IENhY2hlSGVscGVycztcclxuXHJcbiAgICAvLyBBY2NvdW50IG9iamVjdFxyXG4gICAgcHJvdGVjdGVkIGFjY291bnQ6IEFjY291bnQ7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBhdXRob3JpdHkgb2JqZWN0XHJcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEF1dGhvcml0eUluc3RhbmNlOiBBdXRob3JpdHk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbjogTW9kdWxlQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIC8vIFNldCB0aGUgY29uZmlndXJhdGlvblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gYnVpbGRNb2R1bGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBsb2dnZXJcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IG5ldyBMb2dnZXIodGhpcy5jb25maWcubG9nZ2VyT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3J5cHRvXHJcbiAgICAgICAgdGhpcy5jcnlwdG9PYmogPSB0aGlzLmNvbmZpZy5jcnlwdG9JbnRlcmZhY2U7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3RvcmFnZSBpbnRlcmZhY2VcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZSA9IHRoaXMuY29uZmlnLnN0b3JhZ2VJbnRlcmZhY2U7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3RvcmFnZSBoZWxwZXIgb2JqZWN0XHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIgPSBuZXcgQ2FjaGVIZWxwZXJzKHRoaXMuY2FjaGVTdG9yYWdlKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBuZXR3b3JrIGludGVyZmFjZVxyXG4gICAgICAgIHRoaXMubmV0d29ya0NsaWVudCA9IHRoaXMuY29uZmlnLm5ldHdvcmtJbnRlcmZhY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBBYnN0cmFjdCBGdW5jdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB1cmwgZm9yIGxvZ2dpbmcgaW4gYSB1c2VyLiBUaGlzIHdpbGwgYnkgZGVmYXVsdCBhcHBlbmQgdGhlIGNsaWVudCBpZCB0byB0aGUgbGlzdCBvZiBzY29wZXMsIFxyXG4gICAgICogYWxsb3dpbmcgeW91IHRvIHJldHJpZXZlIGFuIGlkIHRva2VuIGluIHRoZSBzdWJzZXF1ZW50IGNvZGUgZXhjaGFuZ2UuIEFsc28gcGVyZm9ybXMgdmFsaWRhdGlvbiBvZiB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzLlxyXG4gICAgICogSW5jbHVkaW5nIGFueSBTU08gcGFyYW1ldGVycyAoYWNjb3VudCwgc2lkLCBsb2dpbl9oaW50KSB3aWxsIHNob3J0IGNpcmN1aXQgdGhlIGF1dGhlbnRpY2F0aW9uIGFuZCBhbGxvdyB5b3UgdG8gcmV0cmlldmUgYSBjb2RlIHdpdGhvdXQgaW50ZXJhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgYXN5bmMgY3JlYXRlTG9naW5VcmwocmVxdWVzdDogQXV0aGVudGljYXRpb25QYXJhbWV0ZXJzKTogUHJvbWlzZTxzdHJpbmc+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHVybCBmb3IgbG9nZ2luZyBpbiBhIHVzZXIuIEFsc28gcGVyZm9ybXMgdmFsaWRhdGlvbiBvZiB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzLlxyXG4gICAgICogSW5jbHVkaW5nIGFueSBTU08gcGFyYW1ldGVycyAoYWNjb3VudCwgc2lkLCBsb2dpbl9oaW50KSB3aWxsIHNob3J0IGNpcmN1aXQgdGhlIGF1dGhlbnRpY2F0aW9uIGFuZCBhbGxvdyB5b3UgdG8gcmV0cmlldmUgYSBjb2RlIHdpdGhvdXQgaW50ZXJhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgYXN5bmMgY3JlYXRlQWNxdWlyZVRva2VuVXJsKHJlcXVlc3Q6IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycyk6IFByb21pc2U8c3RyaW5nPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgdGhlIGhhc2ggZnJhZ21lbnQgcmVzcG9uc2UgZnJvbSBwdWJsaWMgY2xpZW50IGNvZGUgcmVxdWVzdC4gUmV0dXJucyBhIGNvZGUgcmVzcG9uc2UgdXNlZCBieVxyXG4gICAgICogdGhlIGNsaWVudCB0byBleGNoYW5nZSBmb3IgYSB0b2tlbiBpbiBhY3F1aXJlVG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gaGFzaEZyYWdtZW50IFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBoYW5kbGVGcmFnbWVudFJlc3BvbnNlKGhhc2hGcmFnbWVudDogc3RyaW5nKTogQ29kZVJlc3BvbnNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYW4gYXV0aG9yaXphdGlvbiBjb2RlLCBpdCB3aWxsIHBlcmZvcm0gYSB0b2tlbiBleGNoYW5nZSB1c2luZyBjYWNoZWQgdmFsdWVzIGZyb20gYSBwcmV2aW91cyBjYWxsIHRvXHJcbiAgICAgKiBjcmVhdGVMb2dpblVybCgpIG9yIGNyZWF0ZUFjcXVpcmVUb2tlblVybCgpLiBZb3UgbXVzdCBjYWxsIHRoaXMgQUZURVIgdXNpbmcgb25lIG9mIHRob3NlIEFQSXMgZmlyc3QuIFlvdSBzaG91bGRcclxuICAgICAqIGFsc28gdXNlIHRoZSBoYW5kbGVGcmFnbWVudFJlc3BvbnNlKCkgQVBJIHRvIHBhc3MgdGhlIGNvZGVSZXNwb25zZSB0byB0aGlzIGZ1bmN0aW9uIGFmdGVyd2FyZHMuXHJcbiAgICAgKiBAcGFyYW0gY29kZVJlc3BvbnNlIFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBhc3luYyBhY3F1aXJlVG9rZW4oY29kZVJlc3BvbnNlOiBDb2RlUmVzcG9uc2UpOiBQcm9taXNlPFRva2VuUmVzcG9uc2U+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgdG9rZW4gZnJvbSBjYWNoZSBpZiBpdCBpcyBzdGlsbCB2YWxpZCwgb3IgdXNlcyB0aGUgY2FjaGVkIHJlZnJlc2ggdG9rZW4gdG8gcmVuZXdcclxuICAgICAqIHRoZSBnaXZlbiB0b2tlbiBhbmQgcmV0dXJucyB0aGUgcmVuZXdlZCB0b2tlbi4gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBsb2dpbiBpcyBub3QgY29tcGxldGVkICh1bmxlc3NcclxuICAgICAqIGlkIHRva2VucyBhcmUgbm90IGJlaW5nIHJlbmV3ZWQpLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGFzeW5jIHJlbmV3VG9rZW4ocmVxdWVzdDogVG9rZW5SZW5ld1BhcmFtZXRlcnMpOiBQcm9taXNlPFRva2VuUmVzcG9uc2U+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRvIGxvZyBvdXQgdGhlIGN1cnJlbnQgdXNlciwgYW5kIHJlZGlyZWN0IHRoZSB1c2VyIHRvIHRoZSBwb3N0TG9nb3V0UmVkaXJlY3RVcmkuXHJcbiAgICAgKiBEZWZhdWx0IGJlaGF2aW91ciBpcyB0byByZWRpcmVjdCB0aGUgdXNlciB0byBgd2luZG93LmxvY2F0aW9uLmhyZWZgLlxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVVyaSBcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgYXN5bmMgbG9nb3V0KGF1dGhvcml0eVVyaT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcclxuXHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICBcclxuICAgIC8vICNyZWdpb24gR2V0dGVycyBhbmQgU2V0dGVyc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbmVkIGluIGFjY291bnRcclxuICAgICAqICh0aGUgYWNjb3VudCBvYmplY3QgaXMgY3JlYXRlZCBhdCB0aGUgdGltZSBvZiBzdWNjZXNzZnVsIGxvZ2luKVxyXG4gICAgICogb3IgbnVsbCB3aGVuIG5vIHN0YXRlIGlzIGZvdW5kXHJcbiAgICAgKiBAcmV0dXJucyB7QGxpbmsgQWNjb3VudH0gLSB0aGUgYWNjb3VudCBvYmplY3Qgc3RvcmVkIGluIE1TQUxcclxuICAgICAqL1xyXG4gICAgZ2V0QWNjb3VudCgpOiBBY2NvdW50IHtcclxuICAgICAgICBpZiAodGhpcy5hY2NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgaWQgdG9rZW4gYW5kIGNsaWVudCBpbmZvIGZyb20gY2FjaGVcclxuICAgICAgICBjb25zdCByYXdJZFRva2VuID0gdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbShQZXJzaXN0ZW50Q2FjaGVLZXlzLklEX1RPS0VOKTtcclxuICAgICAgICBjb25zdCByYXdDbGllbnRJbmZvID0gdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbShQZXJzaXN0ZW50Q2FjaGVLZXlzLkNMSUVOVF9JTkZPKTtcclxuXHJcbiAgICAgICAgaWYoIVN0cmluZ1V0aWxzLmlzRW1wdHkocmF3SWRUb2tlbikgJiYgIVN0cmluZ1V0aWxzLmlzRW1wdHkocmF3Q2xpZW50SW5mbykpIHtcclxuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IG5ldyBJZFRva2VuKHJhd0lkVG9rZW4sIHRoaXMuY3J5cHRvT2JqKTtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhyYXdDbGllbnRJbmZvLCB0aGlzLmNyeXB0b09iaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFjY291bnQgPSBBY2NvdW50LmNyZWF0ZUFjY291bnQoaWRUb2tlbiwgY2xpZW50SW5mbywgdGhpcy5jcnlwdG9PYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgbG9naW4gaXMgbm90IHlldCBkb25lLCByZXR1cm4gbnVsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNlbmRyZWdpb25cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgTW9kdWxlQ29uZmlndXJhdGlvbiwgYnVpbGRNb2R1bGVDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vTW9kdWxlQ29uZmlndXJhdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIEF1dGhPcHRpb25zOiBVc2UgdGhpcyB0byBjb25maWd1cmUgdGhlIGF1dGggb3B0aW9ucyBpbiB0aGUgQ29uZmlndXJhdGlvbiBvYmplY3RcclxuICpcclxuICogIC0gY2xpZW50SWQgICAgICAgICAgICAgICAgICAgIC0gQ2xpZW50IElEIG9mIHlvdXIgYXBwIHJlZ2lzdGVyZWQgd2l0aCBvdXIgQXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbCA6IGh0dHBzOi8vcG9ydGFsLmF6dXJlLmNvbS8jYmxhZGUvTWljcm9zb2Z0X0FBRF9JQU0vQWN0aXZlRGlyZWN0b3J5TWVudUJsYWRlL1JlZ2lzdGVyZWRBcHBzUHJldmlldyBpbiBNaWNyb3NvZnQgSWRlbnRpdHkgUGxhdGZvcm1cclxuICogIC0gYXV0aG9yaXR5ICAgICAgICAgICAgICAgICAgIC0gWW91IGNhbiBjb25maWd1cmUgYSBzcGVjaWZpYyBhdXRob3JpdHksIGRlZmF1bHRzIHRvIFwiIFwiIG9yIFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vblwiXHJcbiAqICAtIHJlZGlyZWN0VXJpICAgICAgICAgICAgICAgICAtIFRoZSByZWRpcmVjdCBVUkkgb2YgdGhlIGFwcGxpY2F0aW9uLCB0aGlzIHNob3VsZCBiZSBzYW1lIGFzIHRoZSB2YWx1ZSBpbiB0aGUgYXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbC5EZWZhdWx0cyB0byBgd2luZG93LmxvY2F0aW9uLmhyZWZgLlxyXG4gKiAgLSBwb3N0TG9nb3V0UmVkaXJlY3RVcmkgICAgICAgLSBVc2VkIHRvIHJlZGlyZWN0IHRoZSB1c2VyIHRvIHRoaXMgbG9jYXRpb24gYWZ0ZXIgbG9nb3V0LiBEZWZhdWx0cyB0byBgd2luZG93LmxvY2F0aW9uLmhyZWZgLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXV0aE9wdGlvbnMgPSB7XHJcbiAgICBjbGllbnRJZDogc3RyaW5nO1xyXG4gICAgYXV0aG9yaXR5Pzogc3RyaW5nO1xyXG4gICAgcmVkaXJlY3RVcmk/OiBzdHJpbmcgfCAoKCkgPT4gc3RyaW5nKTtcclxuICAgIHBvc3RMb2dvdXRSZWRpcmVjdFVyaT86IHN0cmluZyB8ICgoKSA9PiBzdHJpbmcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVzZSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gY29uZmlndXJlIE1TQUwgYW5kIGluaXRpYWxpemUgdGhlIEF1dGhvcml6YXRpb25Db2RlTW9kdWxlLlxyXG4gKlxyXG4gKiBUaGlzIG9iamVjdCBhbGxvd3MgeW91IHRvIGNvbmZpZ3VyZSBpbXBvcnRhbnQgZWxlbWVudHMgb2YgTVNBTCBmdW5jdGlvbmFsaXR5OlxyXG4gKiAtIGF1dGg6IHRoaXMgaXMgd2hlcmUgeW91IGNvbmZpZ3VyZSBhdXRoIGVsZW1lbnRzIGxpa2UgY2xpZW50SUQsIGF1dGhvcml0eSB1c2VkIGZvciBhdXRoZW50aWNhdGluZyBhZ2FpbnN0IHRoZSBNaWNyb3NvZnQgSWRlbnRpdHkgUGxhdGZvcm1cclxuICovXHJcbmV4cG9ydCB0eXBlIFB1YmxpY0NsaWVudFNQQUNvbmZpZ3VyYXRpb24gPSBNb2R1bGVDb25maWd1cmF0aW9uICYge1xyXG4gICAgYXV0aDogQXV0aE9wdGlvbnNcclxufTtcclxuXHJcbmNvbnN0IERFRkFVTFRfQVVUSF9PUFRJT05TOiBBdXRoT3B0aW9ucyA9IHtcclxuICAgIGNsaWVudElkOiBcIlwiLFxyXG4gICAgYXV0aG9yaXR5OiBudWxsLFxyXG4gICAgcmVkaXJlY3RVcmk6IFwiXCIsXHJcbiAgICBwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IFwiXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0aGF0IHNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aGVuIG5vdCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgZnJvbSBhcHAgZGV2ZWxvcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSBUQXV0aE9wdGlvbnNcclxuICogQHBhcmFtIFRTdG9yYWdlT3B0aW9uc1xyXG4gKiBAcGFyYW0gVFN5c3RlbU9wdGlvbnNcclxuICogQHBhcmFtIFRGcmFtZXdvcmtPcHRpb25zXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRDb25maWd1cmF0aW9uIG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbih7IGF1dGgsIGxvZ2dlck9wdGlvbnMsIHN0b3JhZ2VJbnRlcmZhY2UsIG5ldHdvcmtJbnRlcmZhY2UsIGNyeXB0b0ludGVyZmFjZSB9OiBQdWJsaWNDbGllbnRTUEFDb25maWd1cmF0aW9uKTogUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbiB7XHJcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gYnVpbGRNb2R1bGVDb25maWd1cmF0aW9uKHtsb2dnZXJPcHRpb25zLCBzdG9yYWdlSW50ZXJmYWNlLCBuZXR3b3JrSW50ZXJmYWNlLCBjcnlwdG9JbnRlcmZhY2V9KTtcclxuICAgIGNvbnN0IG92ZXJsYXllZENvbmZpZzogUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICBhdXRoOiB7IC4uLkRFRkFVTFRfQVVUSF9PUFRJT05TLCAuLi5hdXRoIH0sXHJcbiAgICAgICAgLi4uYmFzZUNvbmZpZ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBvdmVybGF5ZWRDb25maWc7XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IENsaWVudEF1dGhFcnJvciB9IGZyb20gXCIuL0NsaWVudEF1dGhFcnJvclwiO1xyXG5cclxuLyoqXHJcbiAqIENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UgY2xhc3MgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UgPSB7XHJcbiAgICByZWRpcmVjdFVyaU5vdFNldDoge1xyXG4gICAgICAgIGNvZGU6IFwicmVkaXJlY3RfdXJpX2VtcHR5XCIsXHJcbiAgICAgICAgZGVzYzogXCJBIHJlZGlyZWN0IFVSSSBpcyByZXF1aXJlZCBmb3IgYWxsIGNhbGxzLCBhbmQgbm9uZSBoYXMgYmVlbiBzZXQuXCJcclxuICAgIH0sXHJcbiAgICBwb3N0TG9nb3V0VXJpTm90U2V0OiB7XHJcbiAgICAgICAgY29kZTogXCJwb3N0X2xvZ291dF91cmlfZW1wdHlcIixcclxuICAgICAgICBkZXNjOiBcIkEgcG9zdCBsb2dvdXQgcmVkaXJlY3QgaGFzIG5vdCBiZWVuIHNldC5cIlxyXG4gICAgfSxcclxuICAgIGNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImNsYWltc19yZXF1ZXN0X3BhcnNpbmdfZXJyb3JcIixcclxuICAgICAgICBkZXNjOiBcIkNvdWxkIG5vdCBwYXJzZSB0aGUgZ2l2ZW4gY2xhaW1zIHJlcXVlc3Qgb2JqZWN0LlwiXHJcbiAgICB9LFxyXG4gICAgYXV0aG9yaXR5VXJpSW5zZWN1cmU6IHtcclxuICAgICAgICBjb2RlOiBcImF1dGhvcml0eV91cmlfaW5zZWN1cmVcIixcclxuICAgICAgICBkZXNjOiBcIkF1dGhvcml0eSBVUklzIG11c3QgdXNlIGh0dHBzLiAgUGxlYXNlIHNlZSBoZXJlIGZvciB2YWxpZCBhdXRob3JpdHkgY29uZmlndXJhdGlvbiBvcHRpb25zOiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9henVyZS9hY3RpdmUtZGlyZWN0b3J5L2RldmVsb3AvbXNhbC1qcy1pbml0aWFsaXppbmctY2xpZW50LWFwcGxpY2F0aW9ucyNjb25maWd1cmF0aW9uLW9wdGlvbnNcIlxyXG4gICAgfSxcclxuICAgIHVybFBhcnNlRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcInVybF9wYXJzZV9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWQgaW50byBhcHByb3ByaWF0ZSBzZWdtZW50cy5cIlxyXG4gICAgfSxcclxuICAgIHVybEVtcHR5RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImVtcHR5X3VybF9lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiVVJMIHdhcyBlbXB0eSBvciBudWxsLlwiXHJcbiAgICB9LFxyXG4gICAgZW1wdHlTY29wZXNFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwiZW1wdHlfaW5wdXRfc2NvcGVzX2Vycm9yXCIsXHJcbiAgICAgICAgZGVzYzogXCJTY29wZXMgY2Fubm90IGJlIHBhc3NlZCBhcyBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkgYXJyYXkgYmVjYXVzZSB0aGV5IGFyZSByZXF1aXJlZCB0byBvYnRhaW4gYW4gYWNjZXNzIHRva2VuLlwiXHJcbiAgICB9LFxyXG4gICAgbm9uQXJyYXlTY29wZXNFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwibm9uYXJyYXlfaW5wdXRfc2NvcGVzX2Vycm9yXCIsXHJcbiAgICAgICAgZGVzYzogXCJTY29wZXMgY2Fubm90IGJlIHBhc3NlZCBhcyBub24tYXJyYXkuXCJcclxuICAgIH0sXHJcbiAgICBjbGllbnRJZFNpbmdsZVNjb3BlRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBcImNsaWVudGlkX2lucHV0X3Njb3Blc19lcnJvclwiLFxyXG4gICAgICAgIGRlc2M6IFwiQ2xpZW50IElEIGNhbiBvbmx5IGJlIHByb3ZpZGVkIGFzIGEgc2luZ2xlIHNjb3BlLlwiXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZFByb21wdDoge1xyXG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF9wcm9tcHRfdmFsdWVcIixcclxuICAgICAgICBkZXNjOiBcIlN1cHBvcnRlZCBwcm9tcHQgdmFsdWVzIGFyZSAnbG9naW4nLCAnc2VsZWN0X2FjY291bnQnLCAnY29uc2VudCcgYW5kICdub25lJy4gIFBsZWFzZSBzZWUgaGVyZSBmb3IgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb25zOiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9henVyZS9hY3RpdmUtZGlyZWN0b3J5L2RldmVsb3AvbXNhbC1qcy1pbml0aWFsaXppbmctY2xpZW50LWFwcGxpY2F0aW9ucyNjb25maWd1cmF0aW9uLW9wdGlvbnNcIixcclxuICAgIH0sXHJcbiAgICB0b2tlblJlcXVlc3RFbXB0eUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogXCJ0b2tlbl9yZXF1ZXN0X2VtcHR5XCIsXHJcbiAgICAgICAgZGVzYzogXCJUb2tlbiByZXF1ZXN0IHdhcyBlbXB0eSBhbmQgbm90IGZvdW5kIGluIGNhY2hlLlwiXHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgaW4gY29uZmlndXJhdGlvbiBvZiB0aGUgTVNBTC5qcyBsaWJyYXJ5LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENsaWVudENvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIENsaWVudEF1dGhFcnJvciB7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZTogc3RyaW5nLCBlcnJvck1lc3NhZ2U/OiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDbGllbnRDb25maWd1cmF0aW9uRXJyb3JcIjtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biB3aGVuIHRoZSByZWRpcmVjdCB1cmkgaXMgZW1wdHkgKG5vdCBzZXQgYnkgY2FsbGVyKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlUmVkaXJlY3RVcmlFbXB0eUVycm9yKCk6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS5yZWRpcmVjdFVyaU5vdFNldC5jb2RlLFxyXG4gICAgICAgICAgICBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLnJlZGlyZWN0VXJpTm90U2V0LmRlc2MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgcG9zdC1sb2dvdXQgcmVkaXJlY3QgdXJpIGlzIGVtcHR5IChub3Qgc2V0IGJ5IGNhbGxlcilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVBvc3RMb2dvdXRSZWRpcmVjdFVyaUVtcHR5RXJyb3IoKTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb25FcnJvcihDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLnBvc3RMb2dvdXRVcmlOb3RTZXQuY29kZSxcclxuICAgICAgICAgICAgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS5wb3N0TG9nb3V0VXJpTm90U2V0LmRlc2MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgY2xhaW1zIHJlcXVlc3QgY291bGQgbm90IGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3IoY2xhaW1zUmVxdWVzdFBhcnNlRXJyb3I6IHN0cmluZyk6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS5jbGFpbXNSZXF1ZXN0UGFyc2luZ0Vycm9yLmNvZGUsXHJcbiAgICAgICAgICAgIGAke0NsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UuY2xhaW1zUmVxdWVzdFBhcnNpbmdFcnJvci5kZXNjfSBHaXZlbiB2YWx1ZTogJHtjbGFpbXNSZXF1ZXN0UGFyc2VFcnJvcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIGF1dGhvcml0eSB1cmkgaXMgZ2l2ZW4gYW4gaW5zZWN1cmUgcHJvdG9jb2wuXHJcbiAgICAgKiBAcGFyYW0gdXJsU3RyaW5nIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmVBdXRob3JpdHlVcmlFcnJvcih1cmxTdHJpbmc6IHN0cmluZyk6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS5hdXRob3JpdHlVcmlJbnNlY3VyZS5jb2RlLFxyXG4gICAgICAgICAgICBgJHtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLmF1dGhvcml0eVVyaUluc2VjdXJlLmRlc2N9IEdpdmVuIFVSSTogJHt1cmxTdHJpbmd9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biBpZiBVUkwgc3RyaW5nIGRvZXMgbm90IHBhcnNlIGludG8gc2VwYXJhdGUgc2VnbWVudHMuXHJcbiAgICAgKiBAcGFyYW0gdXJsU3RyaW5nIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlVXJsUGFyc2VFcnJvcih1cmxQYXJzZUVycm9yOiBzdHJpbmcpOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UudXJsUGFyc2VFcnJvci5jb2RlLFxyXG4gICAgICAgICAgICBgJHtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLnVybFBhcnNlRXJyb3IuZGVzY30gR2l2ZW4gRXJyb3I6ICR7dXJsUGFyc2VFcnJvcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIFVSTCBzdHJpbmcgaXMgZW1wdHkgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSB1cmxTdHJpbmcgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVVcmxFbXB0eUVycm9yKCk6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS51cmxFbXB0eUVycm9yLmNvZGUsIENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UudXJsRW1wdHlFcnJvci5kZXNjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVycm9yIHRocm93biB3aGVuIHNjb3BlcyBhcmUgbm90IGFuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gaW5wdXRTY29wZXMgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVTY29wZXNOb25BcnJheUVycm9yKGlucHV0U2NvcGVzOiBBcnJheTxzdHJpbmc+KTogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb25FcnJvcihDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLm5vbkFycmF5U2NvcGVzRXJyb3IuY29kZSxcclxuICAgICAgICAgICAgYCR7Q2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZS5ub25BcnJheVNjb3Blc0Vycm9yLmRlc2N9IEdpdmVuIFNjb3BlczogJHtpbnB1dFNjb3Blc31gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVycm9yIHRocm93biB3aGVuIHNjb3BlcyBhcmUgZW1wdHkuXHJcbiAgICAgKiBAcGFyYW0gc2NvcGVzVmFsdWUgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVFbXB0eVNjb3Blc0FycmF5RXJyb3IoaW5wdXRTY29wZXM6IEFycmF5PHN0cmluZz4pOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UuZW1wdHlTY29wZXNFcnJvci5jb2RlLFxyXG4gICAgICAgICAgICBgJHtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLmVtcHR5U2NvcGVzRXJyb3IuZGVzY30gR2l2ZW4gU2NvcGVzOiAke2lucHV0U2NvcGVzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXJyb3IgdGhyb3duIHdoZW4gY2xpZW50IGlkIHNjb3BlIGlzIG5vdCBwcm92aWRlZCBhcyBzaW5nbGUgc2NvcGUuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXRTY29wZXMgXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVDbGllbnRJZFNpbmdsZVNjb3BlRXJyb3IoaW5wdXRTY29wZXM6IEFycmF5PHN0cmluZz4pOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UuY2xpZW50SWRTaW5nbGVTY29wZUVycm9yLmNvZGUsXHJcbiAgICAgICAgICAgIGAke0NsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UuY2xpZW50SWRTaW5nbGVTY29wZUVycm9yLmRlc2N9IEdpdmVuIFNjb3BlczogJHtpbnB1dFNjb3Blc31gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVycm9yIHRocm93biB3aGVuIHByb21wdCBpcyBub3QgYW4gYWxsb3dlZCB0eXBlLlxyXG4gICAgICogQHBhcmFtIHByb21wdFZhbHVlIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlSW52YWxpZFByb21wdEVycm9yKHByb21wdFZhbHVlOiBzdHJpbmcpOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UuaW52YWxpZFByb21wdC5jb2RlLFxyXG4gICAgICAgICAgICBgJHtDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLmludmFsaWRQcm9tcHQuZGVzY30gR2l2ZW4gdmFsdWU6ICR7cHJvbXB0VmFsdWV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaHJvd3MgZXJyb3Igd2hlbiB0b2tlbiByZXF1ZXN0IGlzIGVtcHR5IGFuZCBub3RoaW5nIGNhY2hlZCBpbiBzdG9yYWdlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRW1wdHlUb2tlblJlcXVlc3RFcnJvcigpOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UudG9rZW5SZXF1ZXN0RW1wdHlFcnJvci5jb2RlLCBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlLnRva2VuUmVxdWVzdEVtcHR5RXJyb3IuZGVzYyk7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JcIjtcclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeyBDbGllbnRBdXRoRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIFNjb3BlU2V0IGNsYXNzIGNyZWF0ZXMgYSBzZXQgb2Ygc2NvcGVzLiBTY29wZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUsIHVuaXF1ZSB2YWx1ZXMsIHNvIHRoZSBTZXQgb2JqZWN0IGluIEpTIG1ha2VzXHJcbiAqIHRoZSBtb3N0IHNlbnNlIHRvIGltcGxlbWVudCBmb3IgdGhpcyBjbGFzcy4gQWxsIHNjb3BlcyBhcmUgdHJpbW1lZCBhbmQgY29udmVydGVkIHRvIGxvd2VyIGNhc2Ugc3RyaW5ncyB0byBlbnN1cmUgdW5pcXVlbmVzcyBvZiBzdHJpbmdzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNjb3BlU2V0IHtcclxuICAgIC8vIENsaWVudCBJRCBvZiBhcHBsaWNhdGlvblxyXG4gICAgcHJpdmF0ZSBjbGllbnRJZDogc3RyaW5nO1xyXG4gICAgLy8gU2NvcGVzIGFzIGEgU2V0IG9mIHN0cmluZ3NcclxuICAgIHByaXZhdGUgc2NvcGVzOiBTZXQ8c3RyaW5nPjtcclxuICAgIC8vIE9yaWdpbmFsIHNjb3BlcyBwYXNzZWQgdG8gY29uc3RydWN0b3IuIFVzdWFsbHkgdXNlZCBmb3IgY2FjaGluZyBvciB0ZWxlbWV0cnkuXHJcbiAgICBwcml2YXRlIG9yaWdpbmFsU2NvcGVzOiBTZXQ8c3RyaW5nPjtcclxuICAgIC8vIEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciBzY29wZXMgYXJlIHJlcXVpcmVkLiBVc3VhbGx5IHVzZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAgICBwcml2YXRlIHNjb3Blc1JlcXVpcmVkOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGlucHV0U2NvcGVzOiBBcnJheTxzdHJpbmc+LCBhcHBDbGllbnRJZDogc3RyaW5nLCBzY29wZXNSZXF1aXJlZDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBhcHBDbGllbnRJZDtcclxuICAgICAgICB0aGlzLnNjb3Blc1JlcXVpcmVkID0gc2NvcGVzUmVxdWlyZWQ7XHJcbiAgICAgICAgLy8gRmlsdGVyIGVtcHR5IHN0cmluZyBhbmQgbnVsbC91bmRlZmluZWQgYXJyYXkgaXRlbXNcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZElucHV0ID0gaW5wdXRTY29wZXMgPyBTdHJpbmdVdGlscy5yZW1vdmVFbXB0eVN0cmluZ3NGcm9tQXJyYXkoaW5wdXRTY29wZXMpIDogaW5wdXRTY29wZXM7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgYW5kIGZpbHRlciBzY29wZXMgKHZhbGlkYXRlIGZ1bmN0aW9uIHRocm93cyBpZiB2YWxpZGF0aW9uIGZhaWxzKVxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVJbnB1dFNjb3BlcyhmaWx0ZXJlZElucHV0KTtcclxuICAgICAgICBjb25zdCBzY29wZUFyciA9IGZpbHRlcmVkSW5wdXQgPyBTdHJpbmdVdGlscy50cmltQW5kQ29udmVydEFycmF5RW50cmllc1RvTG93ZXJDYXNlKFsuLi5maWx0ZXJlZElucHV0XSkgOiBbXTtcclxuICAgICAgICB0aGlzLnNjb3BlcyA9IG5ldyBTZXQ8c3RyaW5nPihzY29wZUFycik7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blc1JlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kU2NvcGUodGhpcy5jbGllbnRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTY29wZXMgPSBuZXcgU2V0PHN0cmluZz4odGhpcy5zY29wZXMpO1xyXG4gICAgICAgIHRoaXMucmVwbGFjZURlZmF1bHRTY29wZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBTY29wZVNldCBmcm9tIHNwYWNlLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBpbnB1dFNjb3BlU3RyaW5nIFxyXG4gICAgICogQHBhcmFtIGFwcENsaWVudElkIFxyXG4gICAgICogQHBhcmFtIHNjb3Blc1JlcXVpcmVkIFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVN0cmluZyhpbnB1dFNjb3BlU3RyaW5nOiBzdHJpbmcsIGFwcENsaWVudElkOiBzdHJpbmcsIHNjb3Blc1JlcXVpcmVkOiBib29sZWFuKTogU2NvcGVTZXQge1xyXG4gICAgICAgIGlucHV0U2NvcGVTdHJpbmcgPSBpbnB1dFNjb3BlU3RyaW5nIHx8IFwiXCI7XHJcbiAgICAgICAgY29uc3QgaW5wdXRTY29wZXM6IEFycmF5PHN0cmluZz4gPSBpbnB1dFNjb3BlU3RyaW5nLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNjb3BlU2V0KGlucHV0U2NvcGVzLCBhcHBDbGllbnRJZCwgc2NvcGVzUmVxdWlyZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSBjbGllbnQgaWQgd2l0aCB0aGUgZGVmYXVsdCBzY29wZXMgdXNlZCBmb3IgdG9rZW4gYWNxdWlzaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVwbGFjZURlZmF1bHRTY29wZXMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVzLmhhcyh0aGlzLmNsaWVudElkKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjb3BlKHRoaXMuY2xpZW50SWQpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZFNjb3BlKENvbnN0YW50cy5PUEVOSURfU0NPUEUpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZFNjb3BlKENvbnN0YW50cy5QUk9GSUxFX1NDT1BFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBlbmRTY29wZShDb25zdGFudHMuT0ZGTElORV9BQ0NFU1NfU0NPUEUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB2YWxpZGF0ZSB0aGUgc2NvcGVzIGlucHV0IHBhcmFtZXRlciByZXF1ZXN0ZWQgIGJ5IHRoZSBkZXZlbG9wZXIuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlucHV0U2NvcGVzIC0gRGV2ZWxvcGVyIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy4gTm90IGFsbCBzY29wZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGFjY2VzcyB0b2tlbiByZXR1cm5lZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2NvcGVzUmVxdWlyZWQgLSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2NvcGVzIGFycmF5IGlzIHJlcXVpcmVkIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlSW5wdXRTY29wZXMoaW5wdXRTY29wZXM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zY29wZXNSZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzY29wZXMgYXJlIHJlcXVpcmVkIGJ1dCBub3QgZ2l2ZW4gb3IgaXMgYW4gZW1wdHkgYXJyYXlcclxuICAgICAgICAgICAgaWYgKCFpbnB1dFNjb3BlcyB8fCBpbnB1dFNjb3Blcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlRW1wdHlTY29wZXNBcnJheUVycm9yKGlucHV0U2NvcGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzY29wZXMgaXMgYW4gYXJyYXkgb2JqZWN0XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0U2NvcGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlU2NvcGVzTm9uQXJyYXlFcnJvcihpbnB1dFNjb3Blcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSBnaXZlbiBzY29wZSBpcyBwcmVzZW50IGluIHRoaXMgc2V0IG9mIHNjb3Blcy5cclxuICAgICAqIEBwYXJhbSBzY29wZSBcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNTY29wZShzY29wZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICFTdHJpbmdVdGlscy5pc0VtcHR5KHNjb3BlKSA/IHRoaXMuc2NvcGVzLmhhcyhzY29wZSkgOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgc2V0IG9mIHNjb3BlcyBpcyBwcmVzZW50IGluIHRoaXMgc2V0IG9mIHNjb3Blcy5cclxuICAgICAqIEBwYXJhbSBzY29wZVNldCBcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNTY29wZVNldChzY29wZVNldDogU2NvcGVTZXQpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIXNjb3BlU2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzLnNpemUgPj0gc2NvcGVTZXQuc2NvcGVzLnNpemUgJiYgc2NvcGVTZXQuYXNBcnJheSgpLmV2ZXJ5KHNjb3BlID0+IHRoaXMuY29udGFpbnNTY29wZShzY29wZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBzaW5nbGUgc2NvcGUgaWYgcGFzc2VkXHJcbiAgICAgKiBAcGFyYW0gbmV3U2NvcGUgXHJcbiAgICAgKi9cclxuICAgIGFwcGVuZFNjb3BlKG5ld1Njb3BlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZiAoU3RyaW5nVXRpbHMuaXNFbXB0eShuZXdTY29wZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUFwcGVuZEVtcHR5U2NvcGVUb1NldEVycm9yKG5ld1Njb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY29wZXMuYWRkKG5ld1Njb3BlLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgbXVsdGlwbGUgc2NvcGVzIGlmIHBhc3NlZFxyXG4gICAgICogQHBhcmFtIG5ld1Njb3BlcyBcclxuICAgICAqL1xyXG4gICAgYXBwZW5kU2NvcGVzKG5ld1Njb3BlczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlU2V0ID0gbmV3IFNjb3BlU2V0KG5ld1Njb3BlcywgdGhpcy5jbGllbnRJZCwgdGhpcy5zY29wZXNSZXF1aXJlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzID0gdGhpcy51bmlvblNjb3BlU2V0cyhuZXdTY29wZVNldCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlQXBwZW5kU2NvcGVTZXRFcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnQgZnJvbSBzZXQgb2Ygc2NvcGVzLlxyXG4gICAgICogQHBhcmFtIHNjb3BlIFxyXG4gICAgICovXHJcbiAgICByZW1vdmVTY29wZShzY29wZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmlzRW1wdHkoc2NvcGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVSZW1vdmVFbXB0eVNjb3BlRnJvbVNldEVycm9yKHNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY29wZXMuZGVsZXRlKHNjb3BlLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIGFuIGFycmF5IG9mIHNjb3BlcyB3aXRoIHRoZSBjdXJyZW50IHNldCBvZiBzY29wZXMuXHJcbiAgICAgKiBAcGFyYW0gb3RoZXJTY29wZXMgXHJcbiAgICAgKi9cclxuICAgIHVuaW9uU2NvcGVTZXRzKG90aGVyU2NvcGVzOiBTY29wZVNldCk6IFNldDxzdHJpbmc+IHtcclxuICAgICAgICBpZiAoIW90aGVyU2NvcGVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVFbXB0eUlucHV0U2NvcGVTZXRFcnJvcihvdGhlclNjb3Blcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2V0PHN0cmluZz4oWy4uLm90aGVyU2NvcGVzLmFzQXJyYXkoKSwgLi4uQXJyYXkuZnJvbSh0aGlzLnNjb3BlcyldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHNjb3BlcyBpbnRlcnNlY3QgYmV0d2VlbiB0aGlzIHNldCBhbmQgYW5vdGhlci5cclxuICAgICAqIEBwYXJhbSBvdGhlclNjb3BlcyBcclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0aW5nU2NvcGVTZXRzKG90aGVyU2NvcGVzOiBTY29wZVNldCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICghb3RoZXJTY29wZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUVtcHR5SW5wdXRTY29wZVNldEVycm9yKG90aGVyU2NvcGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pb25TY29wZVNldHMob3RoZXJTY29wZXMpLnNpemUgPCAodGhpcy5zY29wZXMuc2l6ZSArIG90aGVyU2NvcGVzLmdldFNjb3BlQ291bnQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHNpemUgb2Ygc2V0IG9mIHNjb3Blcy5cclxuICAgICAqL1xyXG4gICAgZ2V0U2NvcGVDb3VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZXQgb2Ygb3JpZ2luYWwgc2NvcGVzIG9ubHkgY29udGFpbmVkIGNsaWVudC1pZFxyXG4gICAgICovXHJcbiAgICBpc0xvZ2luU2NvcGVTZXQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgaGFzTG9naW5TY29wZXMgPSAoXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxTY29wZXMuaGFzKHRoaXMuY2xpZW50SWQpIHx8XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxTY29wZXMuaGFzKENvbnN0YW50cy5PUEVOSURfU0NPUEUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxTY29wZXMuaGFzKENvbnN0YW50cy5QUk9GSUxFX1NDT1BFKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxTY29wZXMgJiYgaGFzTG9naW5TY29wZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzY29wZXMgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBhc0FycmF5KCk6IEFycmF5PHN0cmluZz4ge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc2NvcGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNjb3BlcyBhcyBhbiBhcnJheSAobm8gZXh0cmEgc2NvcGVzIHRvIGNvbnNlbnQpXHJcbiAgICAgKi9cclxuICAgIGdldE9yaWdpbmFsU2NvcGVzQXNBcnJheSgpOiBBcnJheTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm9yaWdpbmFsU2NvcGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaW50cyBzY29wZXMgaW50byBhIHNwYWNlLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgcHJpbnRTY29wZXMoKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcGVBcnIgPSB0aGlzLmFzQXJyYXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlQXJyLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgQ2xpZW50UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tIFwiLi9DbGllbnRSZXF1ZXN0UGFyYW1ldGVyc1wiO1xyXG5pbXBvcnQgeyBBY2NvdW50IH0gZnJvbSBcIi4uL2F1dGgvQWNjb3VudFwiO1xyXG5pbXBvcnQgeyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yXCI7XHJcblxyXG4vKipcclxuICogQXV0aGVudGljYXRpb25QYXJhbWV0ZXJzIHBhc3NlZCBieSB1c2VyIHRvIHJldHJpZXZlIGEgdG9rZW4gZnJvbSB0aGUgc2VydmVyLlxyXG4gKiAtIHNjb3BlczogcmVxdWVzdGVkIHRva2VuIHNjb3Blc1xyXG4gKiAtIHJlc291cmNlOiByZXF1ZXN0ZWQgcmVzb3VyY2UgdXJpXHJcbiAqIC0gZXh0cmFTY29wZXNUb0NvbnNlbnQ6IGFkZGl0aW9uYWwgc2NvcGVzIHRvIGNvbnNlbnQgXHJcbiAqIC0gcHJvbXB0OiB0aGUgdmFsdWUgb2YgdGhlIE9BdXRoIHByb21wdCBwYXJhbWV0ZXJcclxuICogLSBleHRyYVF1ZXJ5UGFyYW1ldGVyczogc3RyaW5nIHRvIHN0cmluZyBtYXAgb2YgY3VzdG9tIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICogLSBjbGFpbXNSZXF1ZXN0OiBzdHJpbmdpZmllZCBjbGFpbXMgb2JqZWN0IHRvIHJlcXVlc3QgYWRkaXRpb25hbCBjbGFpbXMgaW4gYSB0b2tlblxyXG4gKiAtIGF1dGhvcml0eTogYXV0aG9yaXR5IHRvIHJlcXVlc3QgdG9rZW5zIGZyb21cclxuICogLSB1c2VyUmVxdWVzdFN0YXRlOiBzdGF0ZSBwYXJhbWV0ZXIgdG8gZW5zdXJlIHJlcXVlc3QvcmVzcG9uc2UgaW50ZWdyaXR5XHJcbiAqIC0gY29ycmVsYXRpb25JZDogY3VzdG9tIGNvcnJlbGF0aW9uSWQgZ2l2ZW4gYnkgdXNlclxyXG4gKiAtIGFjY291bnQ6IEFjY291bnQgb2JqZWN0IHRvIHBlcmZvcm0gU1NPXHJcbiAqIC0gc2lkOiBzZXNzaW9uIGlkIGZvciBTU09cclxuICogLSBsb2dpbkhpbnQ6IGxvZ2luIGhpbnQgZm9yIFNTT1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXV0aGVudGljYXRpb25QYXJhbWV0ZXJzID0gQ2xpZW50UmVxdWVzdFBhcmFtZXRlcnMgJiB7XHJcbiAgICBleHRyYVNjb3Blc1RvQ29uc2VudD86IEFycmF5PHN0cmluZz47XHJcbiAgICBwcm9tcHQ/OiBzdHJpbmc7XHJcbiAgICBjbGFpbXNSZXF1ZXN0Pzogc3RyaW5nO1xyXG4gICAgdXNlclJlcXVlc3RTdGF0ZT86IHN0cmluZztcclxuICAgIGFjY291bnQ/OiBBY2NvdW50O1xyXG4gICAgc2lkPzogc3RyaW5nO1xyXG4gICAgbG9naW5IaW50Pzogc3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHdoaWNoIHZhbGlkYXRlcyBjbGFpbXMgcmVxdWVzdCBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuXHJcbiAqIEBwYXJhbSByZXF1ZXN0IFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ2xhaW1zUmVxdWVzdChyZXF1ZXN0OiBBdXRoZW50aWNhdGlvblBhcmFtZXRlcnMpOiB2b2lkIHtcclxuICAgIGlmICghcmVxdWVzdC5jbGFpbXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBKU09OLnBhcnNlKHJlcXVlc3QuY2xhaW1zUmVxdWVzdCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmNyZWF0ZUNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3IoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogTW9yZSB2YWxpZGF0aW9uIHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VydmVyIHRlYW0gdGVsbHMgdXMgaG93IHRoZXkgaGF2ZSBhY3R1YWxseSBpbXBsZW1lbnRlZCBjbGFpbXNcclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tIFwiLi9Db25zdGFudHNcIjtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB3aGljaCBwcm92aWRlcyBoZWxwZXJzIGZvciBPQXV0aCAyLjAgcHJvdG9jb2wgc3BlY2lmaWMgdmFsdWVzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJvdG9jb2xVdGlscyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHVzZXIgc3RhdGUgd2l0aCByYW5kb20gZ3VpZCwgb3IgcmV0dXJucyByYW5kb20gZ3VpZC5cclxuICAgICAqIEBwYXJhbSB1c2VyU3RhdGUgXHJcbiAgICAgKiBAcGFyYW0gcmFuZG9tR3VpZCBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNldFJlcXVlc3RTdGF0ZSh1c2VyU3RhdGU6IHN0cmluZywgcmFuZG9tR3VpZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gIVN0cmluZ1V0aWxzLmlzRW1wdHkodXNlclN0YXRlKSA/IGAke3JhbmRvbUd1aWR9JHtDb25zdGFudHMuUkVTT1VSQ0VfREVMSU19JHt1c2VyU3RhdGV9YCA6IHJhbmRvbUd1aWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogRXh0cmFjdHMgdXNlciBzdGF0ZSB2YWx1ZSBmcm9tIHRoZSBzdGF0ZSBzZW50IHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzY29wZS5cclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFVzZXJSZXF1ZXN0U3RhdGUoc2VydmVyUmVzcG9uc2VTdGF0ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkoc2VydmVyUmVzcG9uc2VTdGF0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHNlcnZlclJlc3BvbnNlU3RhdGUuaW5kZXhPZihDb25zdGFudHMuUkVTT1VSQ0VfREVMSU0pO1xyXG4gICAgICAgICAgICBpZiAoc3BsaXRJbmRleCA+IC0xICYmIHNwbGl0SW5kZXggKyAxIDwgc2VydmVyUmVzcG9uc2VTdGF0ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZVN0YXRlLnN1YnN0cmluZyhzcGxpdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCBwa2cgZnJvbSBcIi4uLy4uL3BhY2thZ2UuanNvblwiO1xyXG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi4vYXV0aC9hdXRob3JpdHkvQXV0aG9yaXR5XCI7XHJcbmltcG9ydCB7IEFjY291bnQgfSBmcm9tIFwiLi4vYXV0aC9BY2NvdW50XCI7XHJcbmltcG9ydCB7IElDcnlwdG8sIFBrY2VDb2RlcyB9IGZyb20gXCIuLi9jcnlwdG8vSUNyeXB0b1wiO1xyXG5pbXBvcnQgeyBTY29wZVNldCB9IGZyb20gXCIuLi9hdXRoL1Njb3BlU2V0XCI7XHJcbmltcG9ydCB7IElkVG9rZW4gfSBmcm9tIFwiLi4vYXV0aC9JZFRva2VuXCI7XHJcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycywgdmFsaWRhdGVDbGFpbXNSZXF1ZXN0IH0gZnJvbSBcIi4uL3JlcXVlc3QvQXV0aGVudGljYXRpb25QYXJhbWV0ZXJzXCI7XHJcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JcIjtcclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IHsgUHJvdG9jb2xVdGlscyB9IGZyb20gXCIuLi91dGlscy9Qcm90b2NvbFV0aWxzXCI7XHJcbmltcG9ydCB7IENvbnN0YW50cywgQmxhY2tsaXN0ZWRFUVBhcmFtcywgU1NPVHlwZXMsIFByb21wdFZhbHVlLCBBQURTZXJ2ZXJQYXJhbUtleXMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IFN0cmluZ0RpY3QgfSBmcm9tIFwiLi4vdXRpbHMvTXNhbFR5cGVzXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBTZXJ2ZXJSZXF1ZXN0UGFyYW1ldGVycyBjbGFzcy4gVGhpcyBjbGFzcyB2YWxpZGF0ZXMgVVJMIHJlcXVlc3QgcGFyYW1ldGVycywgY2hlY2tzIGZvciBTU08gYW5kIGdlbmVyYXRlcyByZXF1aXJlZCBVUkwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VydmVyQ29kZVJlcXVlc3RQYXJhbWV0ZXJzIHtcclxuXHJcbiAgICAvLyBDcnlwdG8gZnVuY3Rpb25zXHJcbiAgICBwcml2YXRlIGNyeXB0b09iajogSUNyeXB0bzsgICAgXHJcblxyXG4gICAgLy8gVGVsZW1ldHJ5IEluZm9cclxuICAgIHhDbGllbnRWZXI6IHN0cmluZztcclxuICAgIHhDbGllbnRTa3U6IHN0cmluZztcclxuICAgIGNvcnJlbGF0aW9uSWQ6IHN0cmluZztcclxuXHJcbiAgICAvLyBQYXJhbXNcclxuICAgIGNsaWVudElkOiBzdHJpbmc7XHJcbiAgICBzY29wZXM6IFNjb3BlU2V0O1xyXG4gICAgcmVkaXJlY3RVcmk6IHN0cmluZztcclxuICAgIGF1dGhvcml0eUluc3RhbmNlOiBBdXRob3JpdHk7XHJcbiAgICByZXNwb25zZVR5cGU6IHN0cmluZztcclxuICAgIHVzZXJSZXF1ZXN0OiBBdXRoZW50aWNhdGlvblBhcmFtZXRlcnM7XHJcbiAgICBxdWVyeVBhcmFtZXRlcnM6IHN0cmluZztcclxuICAgIGV4dHJhUXVlcnlQYXJhbWV0ZXJzOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gR2VuZXJhdGVkIFBhcmFtc1xyXG4gICAgZ2VuZXJhdGVkUGtjZTogUGtjZUNvZGVzO1xyXG4gICAgXHJcbiAgICAvLyBWYWxpZGl0eSBjaGVja3NcclxuICAgIHN0YXRlOiBzdHJpbmc7XHJcbiAgICBub25jZTogc3RyaW5nO1xyXG5cclxuICAgIC8vIEFjY291bnRcclxuICAgIGFjY291bnQ6IEFjY291bnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYXV0aG9yaXR5OiBBdXRob3JpdHksIGNsaWVudElkOiBzdHJpbmcsIHVzZXJSZXF1ZXN0OiBBdXRoZW50aWNhdGlvblBhcmFtZXRlcnMsIGNhY2hlZEFjY291bnQ6IEFjY291bnQsIHJlZGlyZWN0VXJpOiBzdHJpbmcsIGNyeXB0b0ltcGw6IElDcnlwdG8sIGlzTG9naW5DYWxsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMuY3J5cHRvT2JqID0gY3J5cHRvSW1wbDtcclxuICAgICAgICB0aGlzLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmk7XHJcblxyXG4gICAgICAgIC8vIFRlbGVtZXRyeSBJbmZvXHJcbiAgICAgICAgdGhpcy54Q2xpZW50U2t1ID0gQ29uc3RhbnRzLkxJQlJBUllfTkFNRTtcclxuICAgICAgICB0aGlzLnhDbGllbnRWZXIgPSBwa2cudmVyc2lvbjtcclxuXHJcbiAgICAgICAgdGhpcy5hdXRob3JpdHlJbnN0YW5jZSA9IGF1dGhvcml0eTtcclxuICAgICAgICB0aGlzLnVzZXJSZXF1ZXN0ID0gdXNlclJlcXVlc3Q7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSBDb25zdGFudHMuQ09ERV9SRVNQT05TRV9UWVBFO1xyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9ICh1c2VyUmVxdWVzdCAmJiB1c2VyUmVxdWVzdC5hY2NvdW50KSB8fCBjYWNoZWRBY2NvdW50O1xyXG5cclxuICAgICAgICAvLyBTZXQgc2NvcGVzLCBhcHBlbmQgZXh0cmEgc2NvcGVzIGlmIHRoZXJlIGlzIGEgbG9naW4gY2FsbC5cclxuICAgICAgICB0aGlzLnNjb3BlcyA9IG5ldyBTY29wZVNldChcclxuICAgICAgICAgICAgKHRoaXMudXNlclJlcXVlc3QgJiYgdGhpcy51c2VyUmVxdWVzdC5zY29wZXMpIHx8IFtdLCBcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRJZCwgXHJcbiAgICAgICAgICAgICFpc0xvZ2luQ2FsbFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGlzTG9naW5DYWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXh0cmFTY29wZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCByYW5kb20gdmFyc1xyXG4gICAgICAgIGNvbnN0IHJhbmRvbUd1aWQgPSB0aGlzLmNyeXB0b09iai5jcmVhdGVOZXdHdWlkKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFByb3RvY29sVXRpbHMuc2V0UmVxdWVzdFN0YXRlKHRoaXMudXNlclJlcXVlc3QgJiYgdGhpcy51c2VyUmVxdWVzdC51c2VyUmVxdWVzdFN0YXRlLCByYW5kb21HdWlkKTtcclxuICAgICAgICB0aGlzLm5vbmNlID0gdGhpcy5jcnlwdG9PYmouY3JlYXRlTmV3R3VpZCgpO1xyXG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IHRoaXMudXNlclJlcXVlc3QuY29ycmVsYXRpb25JZCB8fCB0aGlzLmNyeXB0b09iai5jcmVhdGVOZXdHdWlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIGV4dHJhU2NvcGVzVG9Db25zZW50IGlmIHBhc3NlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFwcGVuZEV4dHJhU2NvcGVzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnVzZXJSZXF1ZXN0ICYmIHRoaXMuc2NvcGVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJSZXF1ZXN0LmV4dHJhU2NvcGVzVG9Db25zZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3Blcy5hcHBlbmRTY29wZXModGhpcy51c2VyUmVxdWVzdC5leHRyYVNjb3Blc1RvQ29uc2VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlcmUgYXJlIFNTTyBwYXJhbXMgc2V0IGluIHRoZSBSZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBoYXNTU09QYXJhbSgpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBpc1NTT1JlcXVlc3QgPSB0aGlzLnVzZXJSZXF1ZXN0ICYmICh0aGlzLmFjY291bnQgfHwgdGhpcy51c2VyUmVxdWVzdC5zaWQgfHwgdGhpcy51c2VyUmVxdWVzdC5sb2dpbkhpbnQpO1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuYWNjb3VudCB8fCAhIWlzU1NPUmVxdWVzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgU1NPIHBhcmFtZXRlciB0byBxdWVyeSBwYXJhbWV0ZXJzOlxyXG4gICAgICogLSBzaWQgb2YgdGhlIGFjY291bnQgb2JqZWN0IHVzZWQgdG8gaWRlbnRpZnkgdGhlIHNlc3Npb24gb2YgdGhlIHVzZXIgb24gdGhlIHNlcnZpY2VcclxuICAgICAqIC0gbG9naW5faGludCB0byBhdXRob3JpemF0aW9uIFVSTCB3aGljaCBpcyB1c2VkIHRvIHByZS1maWxsIHRoZSB1c2VybmFtZSBmaWVsZCBvZiBzaWduIGluIHBhZ2UgZm9yIHRoZSB1c2VyIGlmIGtub3duIGFoZWFkIG9mIHRpbWVcclxuICAgICAqIEFsc28gZG9lcyBhIHNhbml0eSBjaGVjayBmb3IgZXh0cmFRdWVyeVBhcmFtZXRlcnMgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIGVuc3VyZSBubyByZXBlYXQgcXVlcnlQYXJhbWV0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtAbGluayBBY2NvdW50fSBhY2NvdW50IC0gQWNjb3VudCBmb3Igd2hpY2ggdGhlIHRva2VuIGlzIHJlcXVlc3RlZFxyXG4gICAgICogQHBhcmFtIHF1ZXJ5cGFyYW1zXHJcbiAgICAgKiBAcGFyYW0ge0BsaW5rIFNlcnZlclJlcXVlc3RQYXJhbWV0ZXJzfVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZFNTT1F1ZXJ5UGFyYW1ldGVycyhhZGFsSWRUb2tlbjogSWRUb2tlbik6IFN0cmluZ0RpY3Qge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpbmFsIGNoZWNrIGZvciBhbGwgcXVlcnlQYXJhbXMgYWRkZWQgc28gZmFyOyBwcmVmZXJlbmNlIG9yZGVyOiBzaWQgPiBsb2dpbl9oaW50XHJcbiAgICAgICAgICogc2lkIGNhbm5vdCBiZSBwYXNzZWQgYWxvbmcgd2l0aCBsb2dpbl9oaW50IG9yIGRvbWFpbl9oaW50LCBoZW5jZSB3ZSBjaGVjayBib3RoIGFyZSBub3QgcG9wdWxhdGVkIHlldCBpbiBxdWVyeVBhcmFtZXRlcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBwcmVmZXJlbmNlIG9yZGVyOiBhY2NvdW50ID4gc2lkID4gbG9naW5faGludFxyXG4gICAgICAgIGNvbnN0IHNlcnZlclJlcVBhcmFtOiBTdHJpbmdEaWN0ID0ge307XHJcblxyXG4gICAgICAgIC8vIGlmIGFjY291bnQgaW5mbyBpcyBwYXNzZWQsIGFjY291bnQuc2lkID4gYWNjb3VudC5sb2dpbl9oaW50XHJcbiAgICAgICAgaWYgKHRoaXMuYWNjb3VudCkge1xyXG4gICAgICAgICAgICAvLyBzaWQgY2FuIG9ubHkgYmUgcGFzc2VkIGlmIHByb21wdCA9IG5vbmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjb3VudC5zaWQgJiYgdGhpcy51c2VyUmVxdWVzdCAmJiB0aGlzLnVzZXJSZXF1ZXN0LnByb21wdCA9PT0gUHJvbXB0VmFsdWUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyUmVxUGFyYW1bU1NPVHlwZXMuU0lEXSA9IHRoaXMuYWNjb3VudC5zaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hY2NvdW50LnVzZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXFQYXJhbVtTU09UeXBlcy5MT0dJTl9ISU5UXSA9IHRoaXMuYWNjb3VudC51c2VyTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBubyBhY2NvdW50IGluZm8gYXZhaWxhYmxlLCByZXF1ZXN0LnNpZCA+IHJlcXVlc3QubG9naW5faGludFxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudXNlclJlcXVlc3QpIHtcclxuICAgICAgICAgICAgLy8gc2lkIGZyb20gcmVxdWVzdCAtIGNhbiBvbmx5IGJlIHBhc3NlZCBpZiBwcm9tcHQgPSBub25lXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJSZXF1ZXN0LnNpZCAmJiB0aGlzLnVzZXJSZXF1ZXN0LnByb21wdCA9PT0gUHJvbXB0VmFsdWUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyUmVxUGFyYW1bU1NPVHlwZXMuU0lEXSA9IHRoaXMudXNlclJlcXVlc3Quc2lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxvZ2luSGludCBmcm9tIHJlcXVlc3RcclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51c2VyUmVxdWVzdC5sb2dpbkhpbnQpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlclJlcVBhcmFtW1NTT1R5cGVzLkxPR0lOX0hJTlRdID0gdGhpcy51c2VyUmVxdWVzdC5sb2dpbkhpbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRhbElkVG9rZW4gcmV0cmlldmVkIGZyb20gY2FjaGVcclxuICAgICAgICBpZiAoYWRhbElkVG9rZW4gJiYgU3RyaW5nVXRpbHMuaXNFbXB0eShzZXJ2ZXJSZXFQYXJhbVtTU09UeXBlcy5TSURdKSAmJiBTdHJpbmdVdGlscy5pc0VtcHR5KHNlcnZlclJlcVBhcmFtW1NTT1R5cGVzLkxPR0lOX0hJTlRdKSkge1xyXG4gICAgICAgICAgICBpZiAoYWRhbElkVG9rZW4uY2xhaW1zICYmIGFkYWxJZFRva2VuLmNsYWltcy51cG4pIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlclJlcVBhcmFtW1NTT1R5cGVzLkxPR0lOX0hJTlRdID0gYWRhbElkVG9rZW4uY2xhaW1zLnVwbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlcnZlclJlcVBhcmFtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSB0byBwb3B1bGF0ZSBRdWVyeVBhcmFtZXRlcnMgYW5kIEV4dHJhUXVlcnlQYXJhbWV0ZXJzIHRvIFNlcnZlclJlcXVlc3RQYXJhbWVyZXJzXHJcbiAgICAgKiBAcGFyYW0gYWRhbElkVG9rZW5PYmplY3QgXHJcbiAgICAgKi9cclxuICAgIHBvcHVsYXRlUXVlcnlQYXJhbXMoYWRhbElkVG9rZW5PYmplY3Q/OiBJZFRva2VuKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1ldGVyczogU3RyaW5nRGljdCA9IHt9O1xyXG5cclxuICAgICAgICBpZiAodGhpcy51c2VyUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHByb21wdCBwYXJhbWV0ZXIgdG8gc2VydmVyUmVxdWVzdFBhcmFtZXRlcnMgaWYgcGFzc2VkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJSZXF1ZXN0LnByb21wdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVByb21wdFBhcmFtZXRlcih0aGlzLnVzZXJSZXF1ZXN0LnByb21wdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBjbGFpbXMgY2hhbGxlbmdlIHRvIHNlcnZlclJlcXVlc3RQYXJhbWV0ZXJzIGlmIHBhc3NlZFxyXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyUmVxdWVzdC5jbGFpbXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNsYWltc1JlcXVlc3QodGhpcy51c2VyUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogYWRkcyBzaWQvbG9naW5faGludCBpZiBhbiBTU08gUGFyYW1ldGVyIGlzIGF2YWlsYWJsZVxyXG4gICAgICAgICAqIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJDYWxsaW5nIGFkZEhpbnQgcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAodGhpcy5oYXNTU09QYXJhbSgpIHx8IGFkYWxJZFRva2VuT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuYWRkU1NPUXVlcnlQYXJhbWV0ZXJzKGFkYWxJZFRva2VuT2JqZWN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNhbml0eSBjaGVjayBmb3IgZGV2ZWxvcGVyIHBhc3NlZCBleHRyYVF1ZXJ5UGFyYW1ldGVyc1xyXG4gICAgICAgIGxldCBlUVBhcmFtczogU3RyaW5nRGljdDtcclxuICAgICAgICBpZiAodGhpcy51c2VyUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBlUVBhcmFtcyA9IHRoaXMuc2FuaXRpemVFUVBhcmFtcyh0aGlzLnVzZXJSZXF1ZXN0LCBxdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGV4dHJhUXVlcnlQYXJhbWV0ZXJzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gICAgICAgIHRoaXMucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5nZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVyc1N0cmluZyhxdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuZXh0cmFRdWVyeVBhcmFtZXRlcnMgPSB0aGlzLmdlbmVyYXRlUXVlcnlQYXJhbWV0ZXJzU3RyaW5nKGVRUGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBuYXZpZ2F0aW9uIHVybC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlTmF2aWdhdGVVcmwoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBwYXJhbVN0cmluZ3MgPSBhd2FpdCB0aGlzLmNyZWF0ZVBhcmFtU3RyaW5nKCk7XHJcbiAgICAgICAgbGV0IGF1dGhFbmRwb2ludDogc3RyaW5nID0gdGhpcy5hdXRob3JpdHlJbnN0YW5jZS5hdXRob3JpemF0aW9uRW5kcG9pbnQ7XHJcbiAgICAgICAgLy8gaWYgdGhlIGVuZHBvaW50IGFscmVhZHkgaGFzIHF1ZXJ5cGFyYW1zLCBsZXRzIGFkZCB0byBpdCwgb3RoZXJ3aXNlIGFkZCB0aGUgZmlyc3Qgb25lXHJcbiAgICAgICAgaWYgKGF1dGhFbmRwb2ludC5pbmRleE9mKFwiP1wiKSA8IDApIHtcclxuICAgICAgICAgICAgYXV0aEVuZHBvaW50ICs9IFwiP1wiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF1dGhFbmRwb2ludCArPSBcIiZcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmw6IHN0cmluZyA9IGAke2F1dGhFbmRwb2ludH0ke3BhcmFtU3RyaW5ncy5qb2luKFwiJlwiKX1gO1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0VXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgcXVlcnkgcGFyYW1ldGVyIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVQYXJhbVN0cmluZygpOiBQcm9taXNlPEFycmF5PHN0cmluZz4+IHtcclxuICAgICAgICBjb25zdCBzdHI6IEFycmF5PHN0cmluZz4gPSBbXTtcclxuICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfVFlQRX09JHt0aGlzLnJlc3BvbnNlVHlwZX1gKTtcclxuICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuU0NPUEV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc2NvcGVzLnByaW50U2NvcGVzKCkpfWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSUR9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY2xpZW50SWQpfWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5SRURJUkVDVF9VUkl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMucmVkaXJlY3RVcmkpfWApO1xyXG5cclxuICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuU1RBVEV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RhdGUpfWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5OT05DRX09JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5ub25jZSl9YCk7XHJcblxyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSU5GT309MWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5YX0NMSUVOVF9TS1V9PSR7dGhpcy54Q2xpZW50U2t1fWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5YX0NMSUVOVF9WRVJ9PSR7dGhpcy54Q2xpZW50VmVyfWApO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29kZXMgaGVyZS4gTWF5IHdhbnQgdG8gYWRkIG9wdGlvbmFsIHN0ZXAgdG8gYWxsb3cgZm9yIG5vbi1QS0NFIGF1dGggY29kZSBmbG93c1xyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkUGtjZSA9IGF3YWl0IHRoaXMuY3J5cHRvT2JqLmdlbmVyYXRlUGtjZUNvZGVzKCk7XHJcbiAgICAgICAgc3RyLnB1c2goYCR7QUFEU2VydmVyUGFyYW1LZXlzLkNPREVfQ0hBTExFTkdFfT0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLmdlbmVyYXRlZFBrY2UuY2hhbGxlbmdlKX1gKTtcclxuICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuQ09ERV9DSEFMTEVOR0VfTUVUSE9EfT0ke0NvbnN0YW50cy5TMjU2X0NPREVfQ0hBTExFTkdFX01FVEhPRH1gKTtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHJlc291cmNlXHJcbiAgICAgICAgaWYgKHRoaXMudXNlclJlcXVlc3QgJiYgdGhpcy51c2VyUmVxdWVzdC5yZXNvdXJjZSkge1xyXG4gICAgICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuUkVTT1VSQ0V9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXNlclJlcXVlc3QucmVzb3VyY2UpfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHByb21wdFxyXG4gICAgICAgIGlmICh0aGlzLnVzZXJSZXF1ZXN0ICYmIHRoaXMudXNlclJlcXVlc3QucHJvbXB0KSB7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5QUk9NUFR9PSR7KGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnVzZXJSZXF1ZXN0LnByb21wdCkpfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGNsYWltcyByZXF1ZXN0XHJcbiAgICAgICAgaWYgKHRoaXMudXNlclJlcXVlc3QgJiYgdGhpcy51c2VyUmVxdWVzdC5jbGFpbXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DTEFJTVN9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudXNlclJlcXVlc3QuY2xhaW1zUmVxdWVzdCl9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgcXVlcnkgcGFyYW1zXHJcbiAgICAgICAgaWYgKHRoaXMucXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKHRoaXMucXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBleHRyYSBxdWVyeSBwYXJhbXNcclxuICAgICAgICBpZiAodGhpcy5leHRyYVF1ZXJ5UGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBzdHIucHVzaCh0aGlzLmV4dHJhUXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfUkVRVUVTVF9JRH09JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5jb3JyZWxhdGlvbklkKX1gKTtcclxuICAgICAgICBzdHIucHVzaChgJHtBQURTZXJ2ZXJQYXJhbUtleXMuUkVTUE9OU0VfTU9ERX09JHtDb25zdGFudHMuRlJBR01FTlRfUkVTUE9OU0VfTU9ERX1gKTtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSB0byB0ZXN0IGlmIHZhbGlkIHByb21wdCB2YWx1ZSBpcyBwYXNzZWQgaW4gdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdmFsaWRhdGVQcm9tcHRQYXJhbWV0ZXIocHJvbXB0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZiAoW1Byb21wdFZhbHVlLkxPR0lOLCBQcm9tcHRWYWx1ZS5TRUxFQ1RfQUNDT1VOVCwgUHJvbXB0VmFsdWUuQ09OU0VOVCwgUHJvbXB0VmFsdWUuTk9ORV0uaW5kZXhPZihwcm9tcHQpIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlSW52YWxpZFByb21wdEVycm9yKHByb21wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB1bm5lY2Vzc2FyeSBvciBkdXBsaWNhdGUgcXVlcnkgcGFyYW1ldGVycyBmcm9tIGV4dHJhUXVlcnlQYXJhbWV0ZXJzXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNhbml0aXplRVFQYXJhbXMocmVxdWVzdDogQXV0aGVudGljYXRpb25QYXJhbWV0ZXJzLCBzc29RdWVyeVBhcmFtczogU3RyaW5nRGljdCkgOiBTdHJpbmdEaWN0IHtcclxuICAgICAgICBjb25zdCBlUVBhcmFtcyA6IFN0cmluZ0RpY3QgPSByZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzO1xyXG4gICAgICAgIGlmICghZVFQYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVxdWVzdC5jbGFpbXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMubG9nZ2VyLmVycm9yKFwiUmVtb3ZlZCBkdXBsaWNhdGUgY2xhaW1zIGZyb20gZXh0cmFRdWVyeVBhcmFtZXRlcnMuIFBsZWFzZSB1c2UgZWl0aGVyIHRoZSBjbGFpbXNSZXF1ZXN0IGZpZWxkIE9SIHBhc3MgYXMgZXh0cmFRdWVyeVBhcmFtZXRlciAtIG5vdCBib3RoLlwiKTtcclxuICAgICAgICAgICAgZGVsZXRlIGVRUGFyYW1zW0NvbnN0YW50cy5DTEFJTVNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBxdWVyeSBwYXJhbWV0ZXJzIHRoYXQgYXJlIGJsYWNrbGlzdGVkXHJcbiAgICAgICAgQmxhY2tsaXN0ZWRFUVBhcmFtcy5mb3JFYWNoKHBhcmFtID0+IHtcclxuICAgICAgICAgICAgaWYgKGVRUGFyYW1zW3BhcmFtXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcy5sb2dnZXIuZXJyb3IoXCJSZW1vdmVkIGR1cGxpY2F0ZSBcIiArIHBhcmFtICsgXCIgZnJvbSBleHRyYVF1ZXJ5UGFyYW1ldGVycy4gUGxlYXNlIHVzZSB0aGUgXCIgKyBwYXJhbSArIFwiIGZpZWxkIGluIHJlcXVlc3Qgb2JqZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlUVBhcmFtc1twYXJhbV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBxdWVyeSBwYXJhbWV0ZXJzIGFscmVhZHkgaW5jbHVkZWQgaW4gU1NPIHBhcmFtc1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHNzb1F1ZXJ5UGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlUVBhcmFtc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzLmxvZ2dlci5lcnJvcihcIlJlbW92ZWQgcGFyYW0gXCIgKyBrZXkgKyBcIiBmcm9tIGV4dHJhUXVlcnlQYXJhbWV0ZXJzIHNpbmNlIGl0IHdhcyBhbHJlYWR5IHByZXNlbnQgaW4gbGlicmFyeSBxdWVyeSBwYXJhbWV0ZXJzLlwiKVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVRUGFyYW1zW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFNTT1R5cGVzLlNJRCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcy5sb2dnZXIuZXJyb3IoXCJSZW1vdmVkIGRvbWFpbiBoaW50IHNpbmNlIHNpZCB3YXMgcHJvdmlkZWQuXCIpXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZVFQYXJhbXNbU1NPVHlwZXMuRE9NQUlOX0hJTlRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBlUVBhcmFtcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgdG8gZ2VuZXJhdGUgYSBRdWVyeVBhcmFtZXRlclN0cmluZyBmcm9tIGEgS2V5LVZhbHVlIG1hcHBpbmcgb2YgZXh0cmFRdWVyeVBhcmFtZXRlcnMgcGFzc2VkXHJcbiAgICAgKiBAcGFyYW0gZXh0cmFRdWVyeVBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVF1ZXJ5UGFyYW1ldGVyc1N0cmluZyhxdWVyeVBhcmFtZXRlcnM6IFN0cmluZ0RpY3QpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBwYXJhbXNTdHJpbmc6IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbWV0ZXJzKS5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmlzRW1wdHkocGFyYW1zU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1N0cmluZyA9IGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnlQYXJhbWV0ZXJzW2tleV0pfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdHJpbmcgKz0gYCYke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnlQYXJhbWV0ZXJzW2tleV0pfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtc1N0cmluZztcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHBrZyBmcm9tIFwiLi4vLi4vcGFja2FnZS5qc29uXCI7XHJcbmltcG9ydCB7IFNjb3BlU2V0IH0gZnJvbSBcIi4uL2F1dGgvU2NvcGVTZXRcIjtcclxuaW1wb3J0IHsgVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vcmVxdWVzdC9Ub2tlbkV4Y2hhbmdlUGFyYW1ldGVyc1wiO1xyXG5pbXBvcnQgeyBDb2RlUmVzcG9uc2UgfSBmcm9tIFwiLi4vcmVzcG9uc2UvQ29kZVJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IENsaWVudEF1dGhFcnJvciB9IGZyb20gXCIuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JcIjtcclxuaW1wb3J0IHsgSUNyeXB0byB9IGZyb20gXCIuLi9jcnlwdG8vSUNyeXB0b1wiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBDb25zdGFudHMsIEhFQURFUl9OQU1FUywgQUFEU2VydmVyUGFyYW1LZXlzIH0gZnJvbSBcIi4uL3V0aWxzL0NvbnN0YW50c1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUgU2VydmVyUmVxdWVzdFBhcmFtZXRlcnMgY2xhc3MuIFRoaXMgY2xhc3MgdmFsaWRhdGVzIHRva2VuIHJlcXVlc3QgcGFyYW1ldGVycyBhbmQgZ2VuZXJhdGVzIGEgZm9ybSBib2R5IGFuZCBoZWFkZXJzIHJlcXVpcmVkIGZvciB0aGUgcmVxdWVzdC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZXJ2ZXJUb2tlblJlcXVlc3RQYXJhbWV0ZXJzIHtcclxuXHJcbiAgICAvLyBDcnlwdG8gZnVuY3Rpb25zXHJcbiAgICBwcml2YXRlIGNyeXB0b09iajogSUNyeXB0bztcclxuXHJcbiAgICAvLyBUZWxlbWV0cnkgSW5mb1xyXG4gICAgeENsaWVudFZlcjogc3RyaW5nO1xyXG4gICAgeENsaWVudFNrdTogc3RyaW5nO1xyXG4gICAgY29ycmVsYXRpb25JZDogc3RyaW5nO1xyXG5cclxuICAgIC8vIFBhcmFtc1xyXG4gICAgY2xpZW50SWQ6IHN0cmluZztcclxuICAgIHNjb3BlczogU2NvcGVTZXQ7XHJcbiAgICByZWRpcmVjdFVyaTogc3RyaW5nO1xyXG4gICAgdG9rZW5SZXF1ZXN0OiBUb2tlbkV4Y2hhbmdlUGFyYW1ldGVycztcclxuICAgIGNvZGVSZXNwb25zZTogQ29kZVJlc3BvbnNlO1xyXG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQ6IHN0cmluZywgdG9rZW5SZXF1ZXN0OiBUb2tlbkV4Y2hhbmdlUGFyYW1ldGVycywgY29kZVJlc3BvbnNlOiBDb2RlUmVzcG9uc2UsIHJlZGlyZWN0VXJpOiBzdHJpbmcsIGNyeXB0b0ltcGw6IElDcnlwdG8sIHJlZnJlc2hUb2tlbj86IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLmNyeXB0b09iaiA9IGNyeXB0b0ltcGw7XHJcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVyaSA9IHJlZGlyZWN0VXJpO1xyXG5cclxuICAgICAgICAvLyBUZWxlbWV0cnkgSW5mb1xyXG4gICAgICAgIHRoaXMueENsaWVudFNrdSA9IENvbnN0YW50cy5MSUJSQVJZX05BTUU7XHJcbiAgICAgICAgdGhpcy54Q2xpZW50VmVyID0gcGtnLnZlcnNpb247XHJcblxyXG4gICAgICAgIHRoaXMudG9rZW5SZXF1ZXN0ID0gdG9rZW5SZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMuY29kZVJlc3BvbnNlID0gY29kZVJlc3BvbnNlO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuO1xyXG5cclxuICAgICAgICAvLyBTZXQgc2NvcGVzLCBhbHdheXMgcmVxdWlyZWQgZm9yIHRva2VuIHJlcXVlc3QvZXhjaGFuZ2VcclxuICAgICAgICB0aGlzLnNjb3BlcyA9IG5ldyBTY29wZVNldChcclxuICAgICAgICAgICAgKHRoaXMudG9rZW5SZXF1ZXN0ICYmIHRoaXMudG9rZW5SZXF1ZXN0LnNjb3BlcykgfHwgW10sIFxyXG4gICAgICAgICAgICB0aGlzLmNsaWVudElkLCBcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIFNldCBjb3JyZWxhdGlvbiBpZFxyXG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IHRoaXMudG9rZW5SZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jcnlwdG9PYmouY3JlYXRlTmV3R3VpZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBoZWFkZXJzIHJlcXVpcmVkIGZvciB0b2tlbiByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZXF1ZXN0SGVhZGVycygpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgICAgICBoZWFkZXJzLnNldChIRUFERVJfTkFNRVMuQ09OVEVOVF9UWVBFLCBDb25zdGFudHMuVVJMX0ZPUk1fQ09OVEVOVF9UWVBFKTtcclxuICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgc3RyaW5nIG9mIHBhcmFtZXRlcnMgdG8gc2VuZCB0byBzZXJ2ZXIgaW4gcmVxdWVzdCBib2R5LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZXF1ZXN0Qm9keSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtU3RyaW5nID0gdGhpcy5jcmVhdGVQYXJhbVN0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbVN0cmluZy5qb2luKFwiJlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBjcmVhdGVzIGFuIGFycmF5IG9mIGtleSB2YWx1ZSBzdHJpbmcgcGFpcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlUGFyYW1TdHJpbmcoKTogQXJyYXk8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3Qgc3RyOiBBcnJheTxzdHJpbmc+ID0gW107XHJcblxyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DTElFTlRfSUR9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY2xpZW50SWQpfWApO1xyXG4gICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5TQ09QRX09JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5zY29wZXMucHJpbnRTY29wZXMoKSl9YCk7XHJcbiAgICAgICAgc3RyLnB1c2goYCR7QUFEU2VydmVyUGFyYW1LZXlzLlJFRElSRUNUX1VSSX09JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5yZWRpcmVjdFVyaSl9YCk7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBjb2RlIHJlc3BvbnNlIG9yIHJlZnJlc2ggdG9rZW4sIHB1c2ggcmVsZXZhbnQgdmFyaWFibGVzLiBUaHJvdyBlcnJvciBvdGhlcndpc2UuXHJcbiAgICAgICAgaWYgKHRoaXMuY29kZVJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5DT0RFfT0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNvZGVSZXNwb25zZS5jb2RlKX1gKTtcclxuICAgICAgICAgICAgc3RyLnB1c2goYCR7QUFEU2VydmVyUGFyYW1LZXlzLkNPREVfVkVSSUZJRVJ9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudG9rZW5SZXF1ZXN0LmNvZGVWZXJpZmllcil9YCk7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5HUkFOVF9UWVBFfT0ke0NvbnN0YW50cy5DT0RFX0dSQU5UX1RZUEV9YCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghU3RyaW5nVXRpbHMuaXNFbXB0eSh0aGlzLnJlZnJlc2hUb2tlbikpIHtcclxuICAgICAgICAgICAgc3RyLnB1c2goYCR7QUFEU2VydmVyUGFyYW1LZXlzLlJFRlJFU0hfVE9LRU59PSR7dGhpcy5yZWZyZXNoVG9rZW59YCk7XHJcbiAgICAgICAgICAgIHN0ci5wdXNoKGAke0FBRFNlcnZlclBhcmFtS2V5cy5HUkFOVF9UWVBFfT0ke0NvbnN0YW50cy5SVF9HUkFOVF9UWVBFfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVUb2tlblJlcXVlc3RDYW5ub3RCZU1hZGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGNsYXNzIHdoaWNoIGV4cG9zZXMgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBkYXRlIGFuZCB0aW1lIG9wZXJhdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGltZVV0aWxzIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIFVuaXggdGltZSAoc2Vjb25kcykuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBub3dTZWNvbmRzKCk6IG51bWJlciB7XHJcbiAgICAgICAgLy8gRGF0ZS5nZXRUaW1lKCkgcmV0dXJucyBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwLjApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBTZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlIH0gZnJvbSBcIi4uL3NlcnZlci9TZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JcIjtcclxuaW1wb3J0IHsgQ2xpZW50QXV0aEVycm9yIH0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvclwiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBJVXJpIH0gZnJvbSBcIi4vSVVyaVwiO1xyXG5pbXBvcnQgeyBBQURBdXRob3JpdHlDb25zdGFudHMgfSBmcm9tIFwiLi4vdXRpbHMvQ29uc3RhbnRzXCI7XHJcblxyXG4vKipcclxuICogVXJsIG9iamVjdCBjbGFzcyB3aGljaCBjYW4gcGVyZm9ybSB2YXJpb3VzIHRyYW5zZm9ybWF0aW9ucyBvbiB1cmwgc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVcmxTdHJpbmcge1xyXG5cclxuICAgIC8vIGludGVybmFsIHVybCBzdHJpbmcgZmllbGRcclxuICAgIHByaXZhdGUgX3VybFN0cmluZzogc3RyaW5nO1xyXG4gICAgcHVibGljIGdldCB1cmxTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXJsU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3VybFN0cmluZyA9IHVybDtcclxuICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkodGhpcy5fdXJsU3RyaW5nKSAmJiBTdHJpbmdVdGlscy5pc0VtcHR5KHRoaXMuZ2V0SGFzaCgpKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cmxTdHJpbmcgPSB0aGlzLmNhbm9uaWNhbGl6ZVVyaSh1cmwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoU3RyaW5nVXRpbHMuaXNFbXB0eSh0aGlzLl91cmxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93cyBlcnJvciBpZiB1cmwgaXMgZW1wdHlcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmNyZWF0ZVVybEVtcHR5RXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdXJscyBhcmUgbG93ZXIgY2FzZSBhbmQgZW5kIHdpdGggYSAvIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB1cmwgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2Fub25pY2FsaXplVXJpKHVybDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHVybC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHVybCAmJiAhdXJsLmVuZHNXaXRoKFwiL1wiKSkge1xyXG4gICAgICAgICAgICB1cmwgKz0gXCIvXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGlmIHVybFN0cmluZyBwYXNzZWQgaXMgbm90IGEgdmFsaWQgYXV0aG9yaXR5IFVSSSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlQXNVcmkoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQXR0ZW1wdHMgdG8gcGFyc2UgdXJsIGZvciB1cmkgY29tcG9uZW50c1xyXG4gICAgICAgIGxldCBjb21wb25lbnRzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB0aGlzLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudENvbmZpZ3VyYXRpb25FcnJvci5jcmVhdGVVcmxQYXJzZUVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgVVJJIG9yIHBhdGggc2VnbWVudHMgYXJlIG5vdCBwYXJzZWFibGUuXHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydCB8fCAhY29tcG9uZW50cy5QYXRoU2VnbWVudHMgfHwgY29tcG9uZW50cy5QYXRoU2VnbWVudHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlVXJsUGFyc2VFcnJvcihgR2l2ZW4gdXJsIHN0cmluZzogJHt0aGlzLnVybFN0cmluZ31gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRocm93IGVycm9yIGlmIHVyaSBpcyBpbnNlY3VyZS5cclxuICAgICAgICBpZighY29tcG9uZW50cy5Qcm90b2NvbCB8fCBjb21wb25lbnRzLlByb3RvY29sLnRvTG93ZXJDYXNlKCkgIT09IFwiaHR0cHM6XCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmNyZWF0ZUluc2VjdXJlQXV0aG9yaXR5VXJpRXJyb3IodGhpcy51cmxTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIHJlbW92ZSBxdWVyeSBzdHJpbmcgcGFyYW1zIGZyb20gdXJsLiBSZXR1cm5zIHRoZSBuZXcgdXJsLlxyXG4gICAgICogQHBhcmFtIHVybFxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqL1xyXG4gICAgdXJsUmVtb3ZlUXVlcnlTdHJpbmdQYXJhbWV0ZXIobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKFwiKFxcXFwmXCIgKyBuYW1lICsgXCI9KVteXFwmXStcIik7XHJcbiAgICAgICAgdGhpcy5fdXJsU3RyaW5nID0gdGhpcy51cmxTdHJpbmcucmVwbGFjZShyZWdleCwgXCJcIik7XHJcbiAgICAgICAgLy8gbmFtZT12YWx1ZSZcclxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoXCIoXCIgKyBuYW1lICsgXCI9KVteXFwmXSsmXCIpO1xyXG4gICAgICAgIHRoaXMuX3VybFN0cmluZyA9IHRoaXMudXJsU3RyaW5nLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xyXG4gICAgICAgIC8vIG5hbWU9dmFsdWVcclxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoXCIoXCIgKyBuYW1lICsgXCI9KVteXFwmXStcIik7XHJcbiAgICAgICAgdGhpcy5fdXJsU3RyaW5nID0gdGhpcy51cmxTdHJpbmcucmVwbGFjZShyZWdleCwgXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSB1cmwgbGlrZSBodHRwczovL2E6Yi9jb21tb24vZD9lPWYjZywgYW5kIGEgdGVuYW50SWQsIHJldHVybnMgaHR0cHM6Ly9hOmIvdGVuYW50SWQvZFxyXG4gICAgICogQHBhcmFtIGhyZWYgVGhlIHVybFxyXG4gICAgICogQHBhcmFtIHRlbmFudElkIFRoZSB0ZW5hbnQgaWQgdG8gcmVwbGFjZVxyXG4gICAgICovXHJcbiAgICByZXBsYWNlVGVuYW50UGF0aCh0ZW5hbnRJZDogc3RyaW5nKTogVXJsU3RyaW5nIHtcclxuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSB0aGlzLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICBjb25zdCBwYXRoQXJyYXkgPSB1cmxPYmplY3QuUGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIGlmICh0ZW5hbnRJZCAmJiAocGF0aEFycmF5Lmxlbmd0aCAhPT0gMCAmJiAocGF0aEFycmF5WzBdID09PSBBQURBdXRob3JpdHlDb25zdGFudHMuQ09NTU9OIHx8IHBhdGhBcnJheVswXSA9PT0gQUFEQXV0aG9yaXR5Q29uc3RhbnRzLk9SR0FOSVpBVElPTlMpKSkge1xyXG4gICAgICAgICAgICBwYXRoQXJyYXlbMF0gPSB0ZW5hbnRJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVybFN0cmluZy5jb25zdHJ1Y3RBdXRob3JpdHlVcmlGcm9tT2JqZWN0KHVybE9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmNob3IgcGFydCgjKSBvZiB0aGUgVVJMXHJcbiAgICAgKi9cclxuICAgIGdldEhhc2goKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBoYXNoSW5kZXgxID0gdGhpcy51cmxTdHJpbmcuaW5kZXhPZihcIiNcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaEluZGV4MiA9IHRoaXMudXJsU3RyaW5nLmluZGV4T2YoXCIjL1wiKTtcclxuICAgICAgICBpZiAoaGFzaEluZGV4MiA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVybFN0cmluZy5zdWJzdHJpbmcoaGFzaEluZGV4MiArIDIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFzaEluZGV4MSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVybFN0cmluZy5zdWJzdHJpbmcoaGFzaEluZGV4MSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgZGVzZXJpYWxpemVkIHBvcnRpb24gb2YgVVJMIGhhc2hcclxuICAgICAqL1xyXG4gICAgZ2V0RGVzZXJpYWxpemVkSGFzaDxUPigpOiBUIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5nZXRIYXNoKCk7XHJcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkSGFzaDogVCA9IFN0cmluZ1V0aWxzLnF1ZXJ5U3RyaW5nVG9PYmplY3Q8VD4oaGFzaCk7XHJcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRIYXNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVIYXNoTm90RGVzZXJpYWxpemVkRXJyb3IoSlNPTi5zdHJpbmdpZnkoZGVzZXJpYWxpemVkSGFzaCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkSGFzaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBvdXQgdGhlIGNvbXBvbmVudHMgZnJvbSBhIHVybCBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgdmFyaW91cyBjb21wb25lbnRzLiBQbGVhc2UgY2FjaGUgdGhpcyB2YWx1ZSBpbnN0ZWQgb2YgY2FsbGluZyB0aGlzIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHVybC5cclxuICAgICAqL1xyXG4gICAgZ2V0VXJsQ29tcG9uZW50cygpOiBJVXJpIHtcclxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9jdXJ0aXN6LzExMTM5YjJjZmNhZWY0YTI2MWUwXHJcbiAgICAgICAgY29uc3QgcmVnRXggPSBSZWdFeHAoXCJeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcXFw/KFteI10qKSk/KCMoLiopKT9cIik7XHJcblxyXG4gICAgICAgIC8vIElmIHVybCBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggcmVnRXgsIHdlIHRocm93IGFuIGVycm9yXHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLnVybFN0cmluZy5tYXRjaChyZWdFeCk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlVXJsUGFyc2VFcnJvcihgR2l2ZW4gdXJsIHN0cmluZzogJHt0aGlzLnVybFN0cmluZ31gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVybCBjb21wb25lbnQgb2JqZWN0XHJcbiAgICAgICAgY29uc3QgdXJsQ29tcG9uZW50cyA9IHtcclxuICAgICAgICAgICAgUHJvdG9jb2w6IG1hdGNoWzFdLFxyXG4gICAgICAgICAgICBIb3N0TmFtZUFuZFBvcnQ6IG1hdGNoWzRdLFxyXG4gICAgICAgICAgICBBYnNvbHV0ZVBhdGg6IG1hdGNoWzVdXHJcbiAgICAgICAgfSBhcyBJVXJpO1xyXG5cclxuICAgICAgICBsZXQgcGF0aFNlZ21lbnRzID0gdXJsQ29tcG9uZW50cy5BYnNvbHV0ZVBhdGguc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgIHBhdGhTZWdtZW50cyA9IHBhdGhTZWdtZW50cy5maWx0ZXIoKHZhbCkgPT4gdmFsICYmIHZhbC5sZW5ndGggPiAwKTsgLy8gcmVtb3ZlIGVtcHR5IGVsZW1lbnRzXHJcbiAgICAgICAgdXJsQ29tcG9uZW50cy5QYXRoU2VnbWVudHMgPSBwYXRoU2VnbWVudHM7XHJcbiAgICAgICAgcmV0dXJuIHVybENvbXBvbmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNvbnN0cnVjdEF1dGhvcml0eVVyaUZyb21PYmplY3QodXJsT2JqZWN0OiBJVXJpKTogVXJsU3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVybFN0cmluZyh1cmxPYmplY3QuUHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxPYmplY3QuSG9zdE5hbWVBbmRQb3J0ICsgXCIvXCIgKyB1cmxPYmplY3QuUGF0aFNlZ21lbnRzLmpvaW4oXCIvXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBoYXNoIG9mIHRoZSBVUkwgc3RyaW5nIGNvbnRhaW5zIGtub3duIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc2hDb250YWluc0tub3duUHJvcGVydGllcyh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChTdHJpbmdVdGlscy5pc0VtcHR5KHVybCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1cmxTdHJpbmcgPSBuZXcgVXJsU3RyaW5nKHVybCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHVybFN0cmluZy5nZXREZXNlcmlhbGl6ZWRIYXNoPFNlcnZlckF1dGhvcml6YXRpb25Db2RlUmVzcG9uc2U+KCk7XHJcbiAgICAgICAgcmV0dXJuICEhKFxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVycm9yX2Rlc2NyaXB0aW9uIHx8XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZXJyb3IgfHxcclxuICAgICAgICAgICAgcGFyYW1ldGVycy5zdGF0ZVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vY3J5cHRvL0lDcnlwdG9cIjtcclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uL3VybC9VcmxTdHJpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBLZXkgdG8gY2FjaGUgYWNjZXNzIHRva2VucywgaWQgdG9rZW5zLCBhbmQgcmVmcmVzaCB0b2tlbnMuIEhlbHBzIG1hbmFnZSB0b2tlbiByZW5ld2FsLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFjY2Vzc1Rva2VuS2V5IHtcclxuXHJcbiAgICBhdXRob3JpdHk6IHN0cmluZztcclxuICAgIGNsaWVudElkOiBzdHJpbmc7XHJcbiAgICBzY29wZXM6IHN0cmluZztcclxuICAgIHJlc291cmNlOiBzdHJpbmc7XHJcbiAgICBob21lQWNjb3VudElkZW50aWZpZXI6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhdXRob3JpdHk6IHN0cmluZywgY2xpZW50SWQ6IHN0cmluZywgc2NvcGVzOiBzdHJpbmcsIHJlc291cmNlOiBzdHJpbmcsIHVpZDogc3RyaW5nLCB1dGlkOiBzdHJpbmcsIGNyeXB0b09iajogSUNyeXB0bykge1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eVVyaSA9IG5ldyBVcmxTdHJpbmcoYXV0aG9yaXR5KTtcclxuICAgICAgICB0aGlzLmF1dGhvcml0eSA9IGF1dGhvcml0eVVyaS51cmxTdHJpbmc7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcclxuICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkodWlkKSAmJiAhU3RyaW5nVXRpbHMuaXNFbXB0eSh1dGlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllciA9IGAke2NyeXB0b09iai5iYXNlNjRFbmNvZGUodWlkKX0uJHtjcnlwdG9PYmouYmFzZTY0RW5jb2RlKHV0aWQpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFZhbHVlIG9mIGFjY2VzcyB0b2tlbiBjYWNoZSBpdGVtIHdoaWNoIGlzIHN0b3JlZCBpbiBjYWNoZS4gSGVscHMgbWFuYWdlIHRva2VuIHJlbmV3YWwuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWNjZXNzVG9rZW5WYWx1ZSB7XHJcblxyXG4gICAgdG9rZW5UeXBlOiBzdHJpbmc7XHJcbiAgICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xyXG4gICAgaWRUb2tlbjogc3RyaW5nO1xyXG4gICAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XHJcbiAgICBleHBpcmVzT25TZWM6IHN0cmluZztcclxuICAgIGV4dEV4cGlyZXNPblNlYzogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRva2VuVHlwZTogc3RyaW5nLCBhY2Nlc3NUb2tlbjogc3RyaW5nLCBpZFRva2VuOiBzdHJpbmcsIHJlZnJlc2hUb2tlbjogc3RyaW5nLCBleHBpcmVzT246IHN0cmluZywgZXh0RXhwaXJlc09uOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcclxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XHJcbiAgICAgICAgdGhpcy5pZFRva2VuID0gaWRUb2tlbjtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbjtcclxuICAgICAgICB0aGlzLmV4cGlyZXNPblNlYyA9IGV4cGlyZXNPbjtcclxuICAgICAgICB0aGlzLmV4dEV4cGlyZXNPblNlYyA9IGV4dEV4cGlyZXNPbjtcclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSBcIi4vQXV0aEVycm9yXCI7XHJcblxyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3Igd2l0aCB0aGUgc2VydmVyIGNvZGUsIGZvciBleGFtcGxlLCB1bmF2YWlsYWJpbGl0eS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlOiBzdHJpbmcsIGVycm9yTWVzc2FnZT86IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNlcnZlckVycm9yXCI7XHJcblxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBTZXJ2ZXJFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBJZFRva2VuIH0gZnJvbSBcIi4uL2F1dGgvSWRUb2tlblwiO1xyXG5pbXBvcnQgeyBDYWNoZUhlbHBlcnMgfSBmcm9tIFwiLi4vY2FjaGUvQ2FjaGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlIH0gZnJvbSBcIi4uL3NlcnZlci9TZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZVwiO1xyXG5pbXBvcnQgeyBTY29wZVNldCB9IGZyb20gXCIuLi9hdXRoL1Njb3BlU2V0XCI7XHJcbmltcG9ydCB7IGJ1aWxkQ2xpZW50SW5mbywgQ2xpZW50SW5mbyB9IGZyb20gXCIuLi9hdXRoL0NsaWVudEluZm9cIjtcclxuaW1wb3J0IHsgQWNjb3VudCB9IGZyb20gXCIuLi9hdXRoL0FjY291bnRcIjtcclxuaW1wb3J0IHsgUHJvdG9jb2xVdGlscyB9IGZyb20gXCIuLi91dGlscy9Qcm90b2NvbFV0aWxzXCI7XHJcbmltcG9ydCB7IElDcnlwdG8gfSBmcm9tIFwiLi4vY3J5cHRvL0lDcnlwdG9cIjtcclxuaW1wb3J0IHsgSUNhY2hlU3RvcmFnZSB9IGZyb20gXCIuLi9jYWNoZS9JQ2FjaGVTdG9yYWdlXCI7XHJcbmltcG9ydCB7IFRva2VuUmVzcG9uc2UgfSBmcm9tIFwiLi9Ub2tlblJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IFBlcnNpc3RlbnRDYWNoZUtleXMsIFRlbXBvcmFyeUNhY2hlS2V5cyB9IGZyb20gXCIuLi91dGlscy9Db25zdGFudHNcIjtcclxuaW1wb3J0IHsgQ2xpZW50QXV0aEVycm9yIH0gZnJvbSBcIi4uL2Vycm9yL0NsaWVudEF1dGhFcnJvclwiO1xyXG5pbXBvcnQgeyBUaW1lVXRpbHMgfSBmcm9tIFwiLi4vdXRpbHMvVGltZVV0aWxzXCI7XHJcbmltcG9ydCB7IEFjY2Vzc1Rva2VuS2V5IH0gZnJvbSBcIi4uL2NhY2hlL0FjY2Vzc1Rva2VuS2V5XCI7XHJcbmltcG9ydCB7IEFjY2Vzc1Rva2VuVmFsdWUgfSBmcm9tIFwiLi4vY2FjaGUvQWNjZXNzVG9rZW5WYWx1ZVwiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBTZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlIH0gZnJvbSBcIi4uL3NlcnZlci9TZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IENvZGVSZXNwb25zZSB9IGZyb20gXCIuL0NvZGVSZXNwb25zZVwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gXCIuLi9lcnJvci9TZXJ2ZXJFcnJvclwiO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaGFuZGxlcyByZXNwb25zZSBwYXJzaW5nLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlc3BvbnNlSGFuZGxlciB7XHJcbiAgICBwcml2YXRlIGNsaWVudElkOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGNhY2hlU3RvcmFnZTogSUNhY2hlU3RvcmFnZTtcclxuICAgIHByaXZhdGUgY2FjaGVNYW5hZ2VyOiBDYWNoZUhlbHBlcnM7XHJcbiAgICBwcml2YXRlIGNyeXB0b09iajogSUNyeXB0bztcclxuICAgIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQ6IHN0cmluZywgY2FjaGVTdG9yYWdlOiBJQ2FjaGVTdG9yYWdlLCBjYWNoZU1hbmFnZXI6IENhY2hlSGVscGVycywgY3J5cHRvT2JqOiBJQ3J5cHRvLCBsb2dnZXI6IExvZ2dlcikge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZSA9IGNhY2hlU3RvcmFnZTtcclxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlciA9IGNhY2hlTWFuYWdlcjtcclxuICAgICAgICB0aGlzLmNyeXB0b09iaiA9IGNyeXB0b09iajtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgcmVzcG9uc2Ugd2l0aCB0aGUgZGF0YSBmcm9tIG9yaWdpbmFsIHJlc3BvbnNlIGZpbGxlZCB3aXRoIHRoZSByZWxldmFudCBJZFRva2VuIGRhdGEuXHJcbiAgICAgKiAtIHJhdyBpZCB0b2tlblxyXG4gICAgICogLSBpZCB0b2tlbiBjbGFpbXNcclxuICAgICAqIC0gdW5pcXVlIGlkIChvaWQgb3Igc3ViIGNsYWltIG9mIHRva2VuKVxyXG4gICAgICogLSB0ZW5hbnQgaWQgKHRpZCBjbGFpbSBvZiB0b2tlbilcclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbFJlc3BvbnNlIFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW5PYmogXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXRSZXNwb25zZUlkVG9rZW4ob3JpZ2luYWxSZXNwb25zZTogVG9rZW5SZXNwb25zZSwgaWRUb2tlbk9iajogSWRUb2tlbikgOiBUb2tlblJlc3BvbnNlIHtcclxuICAgICAgICBpZiAoIW9yaWdpbmFsUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaWRUb2tlbk9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBjb25zdCBleHBpcmVzU2Vjb25kcyA9IE51bWJlcihpZFRva2VuT2JqLmNsYWltcy5leHApO1xyXG4gICAgICAgIGlmIChleHBpcmVzU2Vjb25kcyAmJiAhb3JpZ2luYWxSZXNwb25zZS5leHBpcmVzT24pIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxSZXNwb25zZS5leHBpcmVzT24gPSBuZXcgRGF0ZShleHBpcmVzU2Vjb25kcyAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLm9yaWdpbmFsUmVzcG9uc2UsXHJcbiAgICAgICAgICAgIGlkVG9rZW46IGlkVG9rZW5PYmoucmF3SWRUb2tlbixcclxuICAgICAgICAgICAgaWRUb2tlbkNsYWltczogaWRUb2tlbk9iai5jbGFpbXMsXHJcbiAgICAgICAgICAgIHVuaXF1ZUlkOiBpZFRva2VuT2JqLmNsYWltcy5vaWQgfHwgaWRUb2tlbk9iai5jbGFpbXMuc3ViLFxyXG4gICAgICAgICAgICB0ZW5hbnRJZDogaWRUb2tlbk9iai5jbGFpbXMudGlkLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgYW5kIGhhbmRsZXMgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCByZXR1cm5zIGEgY29uc3RydWN0ZWQgb2JqZWN0IHdpdGggdGhlIGF1dGhvcml6YXRpb24gY29kZSBhbmQgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyUGFyYW1zIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFuZGxlU2VydmVyQ29kZVJlc3BvbnNlKHNlcnZlclBhcmFtczogU2VydmVyQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZSk6IENvZGVSZXNwb25zZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgaGFzaCBmcmFnbWVudCByZXNwb25zZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlKHNlcnZlclBhcmFtcywgdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbShUZW1wb3JhcnlDYWNoZUtleXMuUkVRVUVTVF9TVEFURSksIHRoaXMuY3J5cHRvT2JqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhY2hlIGNsaWVudCBpbmZvXHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJQYXJhbXMuY2xpZW50X2luZm8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLnNldEl0ZW0oUGVyc2lzdGVudENhY2hlS2V5cy5DTElFTlRfSU5GTywgc2VydmVyUGFyYW1zLmNsaWVudF9pbmZvKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHJlc3BvbnNlIG9iamVjdFxyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZTogQ29kZVJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICAgICAgY29kZTogc2VydmVyUGFyYW1zLmNvZGUsXHJcbiAgICAgICAgICAgICAgICB1c2VyUmVxdWVzdFN0YXRlOiBzZXJ2ZXJQYXJhbXMuc3RhdGVcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIucmVzZXRUZW1wQ2FjaGVJdGVtcyhzZXJ2ZXJQYXJhbXMgJiYgc2VydmVyUGFyYW1zLnN0YXRlKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB3aGljaCB2YWxpZGF0ZXMgc2VydmVyIGF1dGhvcml6YXRpb24gY29kZSByZXNwb25zZS5cclxuICAgICAqIEBwYXJhbSBzZXJ2ZXJSZXNwb25zZUhhc2ggXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVkU3RhdGUgXHJcbiAgICAgKiBAcGFyYW0gY3J5cHRvT2JqIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlU2VydmVyQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZShzZXJ2ZXJSZXNwb25zZUhhc2g6IFNlcnZlckF1dGhvcml6YXRpb25Db2RlUmVzcG9uc2UsIGNhY2hlZFN0YXRlOiBzdHJpbmcsIGNyeXB0b09iajogSUNyeXB0byk6IHZvaWQge1xyXG4gICAgICAgIGlmIChzZXJ2ZXJSZXNwb25zZUhhc2guc3RhdGUgIT09IGNhY2hlZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVTdGF0ZU1pc21hdGNoRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBDaGVjayBmb3IgZXJyb3JcclxuICAgICAgICBpZiAoc2VydmVyUmVzcG9uc2VIYXNoLmVycm9yIHx8IHNlcnZlclJlc3BvbnNlSGFzaC5lcnJvcl9kZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3Ioc2VydmVyUmVzcG9uc2VIYXNoLmVycm9yLCBzZXJ2ZXJSZXNwb25zZUhhc2guZXJyb3JfZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmIChzZXJ2ZXJSZXNwb25zZUhhc2guY2xpZW50X2luZm8pIHtcclxuICAgICAgICAgICAgYnVpbGRDbGllbnRJbmZvKHNlcnZlclJlc3BvbnNlSGFzaC5jbGllbnRfaW5mbywgY3J5cHRvT2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB3aGljaCB2YWxpZGF0ZXMgc2VydmVyIGF1dGhvcml6YXRpb24gdG9rZW4gcmVzcG9uc2UuXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyUmVzcG9uc2UgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB2YWxpZGF0ZVNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlKHNlcnZlclJlc3BvbnNlOiBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvclxyXG4gICAgICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5lcnJvciB8fCBzZXJ2ZXJSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJTdHJpbmcgPSBgJHtzZXJ2ZXJSZXNwb25zZS5lcnJvcl9jb2Rlc30gLSBbJHtzZXJ2ZXJSZXNwb25zZS50aW1lc3RhbXB9XTogJHtzZXJ2ZXJSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbn0gLSBDb3JyZWxhdGlvbiBJRDogJHtzZXJ2ZXJSZXNwb25zZS5jb3JyZWxhdGlvbl9pZH0gLSBUcmFjZSBJRDogJHtzZXJ2ZXJSZXNwb25zZS50cmFjZV9pZH1gO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3Ioc2VydmVyUmVzcG9uc2UuZXJyb3IsIGVyclN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHNhdmVzIG9yIHVwZGF0ZXMgdGhlIHRva2VuIGluIHRoZSBjYWNoZSBhbmQgY29uc3RydWN0cyB0aGUgZmluYWwgdG9rZW4gcmVzcG9uc2UgdG8gc2VuZCBiYWNrIHRvIHRoZSB1c2VyLlxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsVG9rZW5SZXNwb25zZSBcclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHkgXHJcbiAgICAgKiBAcGFyYW0gcmVzb3VyY2UgXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyVG9rZW5SZXNwb25zZSBcclxuICAgICAqIEBwYXJhbSBjbGllbnRJbmZvIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNhdmVUb2tlbihvcmlnaW5hbFRva2VuUmVzcG9uc2U6IFRva2VuUmVzcG9uc2UsIGF1dGhvcml0eTogc3RyaW5nLCByZXNvdXJjZTogc3RyaW5nLCBzZXJ2ZXJUb2tlblJlc3BvbnNlOiBTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZSwgY2xpZW50SW5mbzogQ2xpZW50SW5mbyk6IFRva2VuUmVzcG9uc2Uge1xyXG4gICAgICAgIC8vIFNldCBjb25zZW50ZWQgc2NvcGVzIGluIHJlc3BvbnNlXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VTY29wZXMgPSBTY29wZVNldC5mcm9tU3RyaW5nKHNlcnZlclRva2VuUmVzcG9uc2Uuc2NvcGUsIHRoaXMuY2xpZW50SWQsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlU2NvcGVBcnJheSA9IHJlc3BvbnNlU2NvcGVzLmFzQXJyYXkoKTtcclxuXHJcbiAgICAgICAgLy8gRXhwaXJhdGlvbiBjYWxjdWxhdGlvblxyXG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHNlcnZlclRva2VuUmVzcG9uc2UuZXhwaXJlc19pbjtcclxuICAgICAgICBjb25zdCBleHBpcmF0aW9uU2VjID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKSArIGV4cGlyZXNJbjtcclxuICAgICAgICBjb25zdCBleHRlbmRlZEV4cGlyYXRpb25TZWMgPSBleHBpcmF0aW9uU2VjICsgc2VydmVyVG9rZW5SZXNwb25zZS5leHRfZXhwaXJlc19pbjtcclxuXHJcbiAgICAgICAgLy8gR2V0IGlkIHRva2VuXHJcbiAgICAgICAgaWYgKCFTdHJpbmdVdGlscy5pc0VtcHR5KG9yaWdpbmFsVG9rZW5SZXNwb25zZS5pZFRva2VuKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5zZXRJdGVtKFBlcnNpc3RlbnRDYWNoZUtleXMuSURfVE9LRU4sIG9yaWdpbmFsVG9rZW5SZXNwb25zZS5pZFRva2VuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNhdmUgYWNjZXNzIHRva2VuIGluIGNhY2hlXHJcbiAgICAgICAgY29uc3QgbmV3QWNjZXNzVG9rZW5WYWx1ZSA9IG5ldyBBY2Nlc3NUb2tlblZhbHVlKHNlcnZlclRva2VuUmVzcG9uc2UudG9rZW5fdHlwZSwgc2VydmVyVG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4sIG9yaWdpbmFsVG9rZW5SZXNwb25zZS5pZFRva2VuLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLnJlZnJlc2hfdG9rZW4sIGV4cGlyYXRpb25TZWMudG9TdHJpbmcoKSwgZXh0ZW5kZWRFeHBpcmF0aW9uU2VjLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGNvbnN0IGhvbWVBY2NvdW50SWRlbnRpZmllciA9IG9yaWdpbmFsVG9rZW5SZXNwb25zZS5hY2NvdW50ICYmIG9yaWdpbmFsVG9rZW5SZXNwb25zZS5hY2NvdW50LmhvbWVBY2NvdW50SWRlbnRpZmllcjtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbkNhY2hlSXRlbXMgPSB0aGlzLmNhY2hlTWFuYWdlci5nZXRBbGxBY2Nlc3NUb2tlbnModGhpcy5jbGllbnRJZCwgYXV0aG9yaXR5IHx8IFwiXCIsIHJlc291cmNlIHx8IFwiXCIsIGhvbWVBY2NvdW50SWRlbnRpZmllciB8fCBcIlwiKTtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgaW4gY2FjaGUgd2l0aCB0aGVzZSBwYXJhbWV0ZXJzLCBzZXQgbmV3IGl0ZW0uXHJcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuQ2FjaGVJdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJObyB0b2tlbnMgZm91bmQsIGNyZWF0aW5nIG5ldyBpdGVtLlwiKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3VG9rZW5LZXkgPSBuZXcgQWNjZXNzVG9rZW5LZXkoXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHksIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRJZCwgXHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLnNjb3BlLCBcclxuICAgICAgICAgICAgICAgIHJlc291cmNlLCBcclxuICAgICAgICAgICAgICAgIGNsaWVudEluZm8gJiYgY2xpZW50SW5mby51aWQsIFxyXG4gICAgICAgICAgICAgICAgY2xpZW50SW5mbyAmJiBjbGllbnRJbmZvLnV0aWQsIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9PYmpcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2Uuc2V0SXRlbShKU09OLnN0cmluZ2lmeShuZXdUb2tlbktleSksIEpTT04uc3RyaW5naWZ5KG5ld0FjY2Vzc1Rva2VuVmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzY29wZXMgYXJlIGludGVyc2VjdGluZy4gSWYgdGhleSBhcmUsIGNvbWJpbmUgc2NvcGVzIGFuZCByZXBsYWNlIGNhY2hlIGl0ZW0uXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuQ2FjaGVJdGVtcy5mb3JFYWNoKGFjY2Vzc1Rva2VuQ2FjaGVJdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFNjb3BlcyA9IFNjb3BlU2V0LmZyb21TdHJpbmcoYWNjZXNzVG9rZW5DYWNoZUl0ZW0ua2V5LnNjb3BlcywgdGhpcy5jbGllbnRJZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZihjYWNoZWRTY29wZXMuaW50ZXJzZWN0aW5nU2NvcGVTZXRzKHJlc3BvbnNlU2NvcGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLnJlbW92ZUl0ZW0oSlNPTi5zdHJpbmdpZnkoYWNjZXNzVG9rZW5DYWNoZUl0ZW0ua2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2NvcGVzLmFwcGVuZFNjb3BlcyhyZXNwb25zZVNjb3BlQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuQ2FjaGVJdGVtLmtleS5zY29wZXMgPSBjYWNoZWRTY29wZXMucHJpbnRTY29wZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoU3RyaW5nVXRpbHMuaXNFbXB0eShuZXdBY2Nlc3NUb2tlblZhbHVlLmlkVG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FjY2Vzc1Rva2VuVmFsdWUuaWRUb2tlbiA9IGFjY2Vzc1Rva2VuQ2FjaGVJdGVtLnZhbHVlLmlkVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLnNldEl0ZW0oSlNPTi5zdHJpbmdpZnkoYWNjZXNzVG9rZW5DYWNoZUl0ZW0ua2V5KSwgSlNPTi5zdHJpbmdpZnkobmV3QWNjZXNzVG9rZW5WYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNhdmUgdG9rZW5zIGluIHJlc3BvbnNlIGFuZCByZXR1cm5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5vcmlnaW5hbFRva2VuUmVzcG9uc2UsXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogc2VydmVyVG9rZW5SZXNwb25zZS50b2tlbl90eXBlLFxyXG4gICAgICAgICAgICBzY29wZXM6IHJlc3BvbnNlU2NvcGVBcnJheSxcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHNlcnZlclRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF90b2tlbixcclxuICAgICAgICAgICAgZXhwaXJlc09uOiBuZXcgRGF0ZShleHBpcmF0aW9uU2VjICogMTAwMClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhY2NvdW50IGNhY2hlZCB3aXRoIGdpdmVuIGtleS4gUmV0dXJucyBudWxsIGlmIHBhcnNpbmcgY291bGQgbm90IGJlIGNvbXBsZXRlZC5cclxuICAgICAqIEBwYXJhbSBhY2NvdW50S2V5IFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENhY2hlZEFjY291bnQoYWNjb3VudEtleTogc3RyaW5nKTogQWNjb3VudCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbShhY2NvdW50S2V5KSkgYXMgQWNjb3VudDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm5pbmcoYEFjY291bnQgY291bGQgbm90IGJlIHBhcnNlZDogJHtKU09OLnN0cmluZ2lmeShlKX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvbnN0cnVjdGVkIHRva2VuIHJlc3BvbnNlIGJhc2VkIG9uIGdpdmVuIHN0cmluZy4gQWxzbyBtYW5hZ2VzIHRoZSBjYWNoZSB1cGRhdGVzIGFuZCBjbGVhbnVwcy5cclxuICAgICAqIEBwYXJhbSBzZXJ2ZXJUb2tlblJlc3BvbnNlIFxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVN0cmluZyBcclxuICAgICAqIEBwYXJhbSByZXNvdXJjZSBcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVRva2VuUmVzcG9uc2Uoc2VydmVyVG9rZW5SZXNwb25zZTogU2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2UsIGF1dGhvcml0eVN0cmluZzogc3RyaW5nLCByZXNvdXJjZTogc3RyaW5nLCBzdGF0ZT86IHN0cmluZyk6IFRva2VuUmVzcG9uc2Uge1xyXG4gICAgICAgIGxldCB0b2tlblJlc3BvbnNlOiBUb2tlblJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICB1bmlxdWVJZDogXCJcIixcclxuICAgICAgICAgICAgdGVuYW50SWQ6IFwiXCIsXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogXCJcIixcclxuICAgICAgICAgICAgaWRUb2tlbjogbnVsbCxcclxuICAgICAgICAgICAgaWRUb2tlbkNsYWltczogbnVsbCxcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IFwiXCIsXHJcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogXCJcIixcclxuICAgICAgICAgICAgc2NvcGVzOiBbXSxcclxuICAgICAgICAgICAgZXhwaXJlc09uOiBudWxsLFxyXG4gICAgICAgICAgICBhY2NvdW50OiBudWxsLFxyXG4gICAgICAgICAgICB1c2VyUmVxdWVzdFN0YXRlOiBcIlwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUmV0cmlldmUgY3VycmVudCBpZCB0b2tlbiBvYmplY3RcclxuICAgICAgICBsZXQgaWRUb2tlbk9iajogSWRUb2tlbjtcclxuICAgICAgICBjb25zdCBjYWNoZWRJZFRva2VuOiBzdHJpbmcgPSB0aGlzLmNhY2hlU3RvcmFnZS5nZXRJdGVtKFBlcnNpc3RlbnRDYWNoZUtleXMuSURfVE9LRU4pO1xyXG4gICAgICAgIGlmIChzZXJ2ZXJUb2tlblJlc3BvbnNlLmlkX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIGlkVG9rZW5PYmogPSBuZXcgSWRUb2tlbihzZXJ2ZXJUb2tlblJlc3BvbnNlLmlkX3Rva2VuLCB0aGlzLmNyeXB0b09iaik7XHJcbiAgICAgICAgICAgIHRva2VuUmVzcG9uc2UgPSBSZXNwb25zZUhhbmRsZXIuc2V0UmVzcG9uc2VJZFRva2VuKHRva2VuUmVzcG9uc2UsIGlkVG9rZW5PYmopO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgc3RhdGUgaXMgZW1wdHksIHJlZnJlc2ggdG9rZW4gaXMgYmVpbmcgdXNlZFxyXG4gICAgICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiU3RhdGUgd2FzIGRldGVjdGVkIC0gbm9uY2Ugc2hvdWxkIGJlIGF2YWlsYWJsZS5cIik7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBub25jZSBpbnRlZ3JpdHkgaWYgcmVmcmVzaCB0b2tlbiBpcyBub3QgdXNlZCAtIHRocm93IGFuIGVycm9yIGlmIG5vdCBtYXRjaGVkICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChTdHJpbmdVdGlscy5pc0VtcHR5KGlkVG9rZW5PYmouY2xhaW1zLm5vbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVJbnZhbGlkSWRUb2tlbkVycm9yKGlkVG9rZW5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmNhY2hlTWFuYWdlci5nZW5lcmF0ZU5vbmNlS2V5KHN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRUb2tlbk9iai5jbGFpbXMubm9uY2UgIT09IG5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZU5vbmNlTWlzbWF0Y2hFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjYWNoZWRJZFRva2VuKSB7XHJcbiAgICAgICAgICAgIGlkVG9rZW5PYmogPSBuZXcgSWRUb2tlbihjYWNoZWRJZFRva2VuLCB0aGlzLmNyeXB0b09iaik7XHJcbiAgICAgICAgICAgIHRva2VuUmVzcG9uc2UgPSBSZXNwb25zZUhhbmRsZXIuc2V0UmVzcG9uc2VJZFRva2VuKHRva2VuUmVzcG9uc2UsIGlkVG9rZW5PYmopO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlkVG9rZW5PYmogPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNsaWVudEluZm86IENsaWVudEluZm8gPSBudWxsO1xyXG4gICAgICAgIGxldCBjYWNoZWRBY2NvdW50OiBBY2NvdW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoaWRUb2tlbk9iaikge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBjbGllbnQgaW5mb1xyXG4gICAgICAgICAgICBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvKHRoaXMuY2FjaGVTdG9yYWdlLmdldEl0ZW0oUGVyc2lzdGVudENhY2hlS2V5cy5DTElFTlRfSU5GTyksIHRoaXMuY3J5cHRvT2JqKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhY2NvdW50IG9iamVjdCBmb3IgcmVxdWVzdFxyXG4gICAgICAgICAgICB0b2tlblJlc3BvbnNlLmFjY291bnQgPSBBY2NvdW50LmNyZWF0ZUFjY291bnQoaWRUb2tlbk9iaiwgY2xpZW50SW5mbywgdGhpcy5jcnlwdG9PYmopO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgYWNjZXNzIHRva2VuIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50S2V5ID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2VuZXJhdGVBY3F1aXJlVG9rZW5BY2NvdW50S2V5KHRva2VuUmVzcG9uc2UuYWNjb3VudC5ob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gR2V0IGNhY2hlZCBhY2NvdW50XHJcbiAgICAgICAgICAgIGNhY2hlZEFjY291bnQgPSB0aGlzLmdldENhY2hlZEFjY291bnQoYWNjb3VudEtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdXNlciBzZXQgc3RhdGUgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAgICAgdG9rZW5SZXNwb25zZS51c2VyUmVxdWVzdFN0YXRlID0gUHJvdG9jb2xVdGlscy5nZXRVc2VyUmVxdWVzdFN0YXRlKHN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIucmVzZXRUZW1wQ2FjaGVJdGVtcyhzdGF0ZSk7XHJcbiAgICAgICAgaWYgKCFjYWNoZWRBY2NvdW50IHx8ICF0b2tlblJlc3BvbnNlLmFjY291bnQgfHwgQWNjb3VudC5jb21wYXJlQWNjb3VudHMoY2FjaGVkQWNjb3VudCwgdG9rZW5SZXNwb25zZS5hY2NvdW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9rZW4odG9rZW5SZXNwb25zZSwgYXV0aG9yaXR5U3RyaW5nLCByZXNvdXJjZSwgc2VydmVyVG9rZW5SZXNwb25zZSwgY2xpZW50SW5mbyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJBY2NvdW50cyBkbyBub3QgbWF0Y2guXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvclBpaShgQ2FjaGVkIEFjY291bnQ6ICR7SlNPTi5zdHJpbmdpZnkoY2FjaGVkQWNjb3VudCl9LCBOZXcgQWNjb3VudDogJHtKU09OLnN0cmluZ2lmeSh0b2tlblJlc3BvbnNlLmFjY291bnQpfWApO1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlQWNjb3VudE1pc21hdGNoRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IEF1dGhvcml0eVR5cGUgfSBmcm9tIFwiLi9BdXRob3JpdHlUeXBlXCI7XHJcbmltcG9ydCB7IFRlbmFudERpc2NvdmVyeVJlc3BvbnNlIH0gZnJvbSBcIi4vVGVuYW50RGlzY292ZXJ5UmVzcG9uc2VcIjtcclxuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uLy4uL3VybC9VcmxTdHJpbmdcIjtcclxuaW1wb3J0IHsgSVVyaSB9IGZyb20gXCIuLi8uLi91cmwvSVVyaVwiO1xyXG5pbXBvcnQgeyBDbGllbnRBdXRoRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yXCI7XHJcbmltcG9ydCB7IElOZXR3b3JrTW9kdWxlIH0gZnJvbSBcIi4uLy4uL25ldHdvcmsvSU5ldHdvcmtNb2R1bGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYXV0aG9yaXR5IGNsYXNzIHZhbGlkYXRlcyB0aGUgYXV0aG9yaXR5IFVSSXMgdXNlZCBieSB0aGUgdXNlciwgYW5kIHJldHJpZXZlcyB0aGUgT3BlbklEIENvbmZpZ3VyYXRpb24gRGF0YSBmcm9tIHRoZVxyXG4gKiBlbmRwb2ludC4gSXQgd2lsbCBzdG9yZSB0aGUgcGVydGluZW50IGNvbmZpZyBkYXRhIGluIHRoaXMgb2JqZWN0IGZvciB1c2UgZHVyaW5nIHRva2VuIGNhbGxzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEF1dGhvcml0eSB7XHJcblxyXG4gICAgLy8gQ2Fub25pY2FsIGF1dGhvcml0eSB1cmwgc3RyaW5nXHJcbiAgICBwcml2YXRlIF9jYW5vbmljYWxBdXRob3JpdHk6IFVybFN0cmluZztcclxuICAgIC8vIENhbm9uaWNhbHkgYXV0aG9yaXR5IHVybCBjb21wb25lbnRzXHJcbiAgICBwcml2YXRlIF9jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzOiBJVXJpO1xyXG4gICAgLy8gVGVuYW50IGRpc2NvdmVyeSByZXNwb25zZSByZXRyaWV2ZWQgZnJvbSBPcGVuSUQgQ29uZmlndXJhdGlvbiBFbmRwb2ludFxyXG4gICAgcHJpdmF0ZSB0ZW5hbnREaXNjb3ZlcnlSZXNwb25zZTogVGVuYW50RGlzY292ZXJ5UmVzcG9uc2U7XHJcbiAgICAvLyBOZXR3b3JrIGludGVyZmFjZSB0byBtYWtlIHJlcXVlc3RzIHdpdGguXHJcbiAgICBwcm90ZWN0ZWQgbmV0d29ya0ludGVyZmFjZTogSU5ldHdvcmtNb2R1bGU7XHJcblxyXG4gICAgLy8gU2VlIGFib3ZlIGZvciBBdXRob3JpdHlUeXBlXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IGF1dGhvcml0eVR5cGUoKTogQXV0aG9yaXR5VHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgVVJMIHRoYXQgaXMgdGhlIGF1dGhvcml0eSBzZXQgYnkgdGhlIGRldmVsb3BlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNhbm9uaWNhbEF1dGhvcml0eSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkudXJsU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjYW5vbmljYWwgYXV0aG9yaXR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGNhbm9uaWNhbEF1dGhvcml0eSh1cmw6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eSA9IG5ldyBVcmxTdHJpbmcodXJsKTtcclxuICAgICAgICB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkudmFsaWRhdGVBc1VyaSgpO1xyXG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGF1dGhvcml0eSBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMoKTogSVVyaSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMgPSB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkuZ2V0VXJsQ29tcG9uZW50cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGVuYW50IGZvciBhdXRob3JpdHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdGVuYW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cy5QYXRoU2VnbWVudHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPQXV0aCAvYXV0aG9yaXplIGVuZHBvaW50IGZvciByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF1dGhvcml6YXRpb25FbmRwb2ludCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlVGVuYW50KHRoaXMudGVuYW50RGlzY292ZXJ5UmVzcG9uc2UuYXV0aG9yaXphdGlvbl9lbmRwb2ludCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUVuZHBvaW50RGlzY292ZXJ5SW5jb21wbGV0ZUVycm9yKFwiRGlzY292ZXJ5IGluY29tcGxldGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9BdXRoIC90b2tlbiBlbmRwb2ludCBmb3IgcmVxdWVzdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0b2tlbkVuZHBvaW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYodGhpcy5kaXNjb3ZlcnlDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VUZW5hbnQodGhpcy50ZW5hbnREaXNjb3ZlcnlSZXNwb25zZS50b2tlbl9lbmRwb2ludCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUVuZHBvaW50RGlzY292ZXJ5SW5jb21wbGV0ZUVycm9yKFwiRGlzY292ZXJ5IGluY29tcGxldGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9BdXRoIGxvZ291dCBlbmRwb2ludCBmb3IgcmVxdWVzdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBlbmRTZXNzaW9uRW5kcG9pbnQoKTogc3RyaW5nIHtcclxuICAgICAgICBpZih0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVRlbmFudCh0aGlzLnRlbmFudERpc2NvdmVyeVJlc3BvbnNlLmVuZF9zZXNzaW9uX2VuZHBvaW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlRW5kcG9pbnREaXNjb3ZlcnlJbmNvbXBsZXRlRXJyb3IoXCJEaXNjb3ZlcnkgaW5jb21wbGV0ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT0F1dGggaXNzdWVyIGZvciByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNlbGZTaWduZWRKd3RBdWRpZW5jZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlVGVuYW50KHRoaXMudGVuYW50RGlzY292ZXJ5UmVzcG9uc2UuaXNzdWVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlRW5kcG9pbnREaXNjb3ZlcnlJbmNvbXBsZXRlRXJyb3IoXCJEaXNjb3ZlcnkgaW5jb21wbGV0ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgdGVuYW50IGluIHVybCBwYXRoIHdpdGggY3VycmVudCB0ZW5hbnQuIERlZmF1bHRzIHRvIGNvbW1vbi5cclxuICAgICAqIEBwYXJhbSB1cmxTdHJpbmcgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVwbGFjZVRlbmFudCh1cmxTdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHVybFN0cmluZy5yZXBsYWNlKFwie3RlbmFudH1cIiwgdGhpcy50ZW5hbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgb3BlbiBpZCBjb25maWd1cmF0aW9uIGVuZHBvaW50IGZvciBhbnkgY2Fub25pY2FsIGF1dGhvcml0eS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldCBkZWZhdWx0T3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY2Fub25pY2FsQXV0aG9yaXR5fXYyLjAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGF1dGhvcml0eTogc3RyaW5nLCBuZXR3b3JrSW50ZXJmYWNlOiBJTmV0d29ya01vZHVsZSkge1xyXG4gICAgICAgIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5ID0gYXV0aG9yaXR5O1xyXG5cclxuICAgICAgICB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkudmFsaWRhdGVBc1VyaSgpO1xyXG4gICAgICAgIHRoaXMubmV0d29ya0ludGVyZmFjZSA9IG5ldHdvcmtJbnRlcmZhY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCb29sZWFuIHRoYXQgcmV0dXJucyB3aGV0aHIgb3Igbm90IHRlbmFudCBkaXNjb3ZlcnkgaGFzIGJlZW4gY29tcGxldGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNjb3ZlcnlDb21wbGV0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnRlbmFudERpc2NvdmVyeVJlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBPQXV0aCBlbmRwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gT3BlbklEIGNvbmZpZ3VyYXRpb24gZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gb3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50IFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGRpc2NvdmVyRW5kcG9pbnRzKG9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludDogc3RyaW5nKTogUHJvbWlzZTxUZW5hbnREaXNjb3ZlcnlSZXNwb25zZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtJbnRlcmZhY2Uuc2VuZEdldFJlcXVlc3RBc3luYzxUZW5hbnREaXNjb3ZlcnlSZXNwb25zZT4ob3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGZ1bmN0aW9uIHdoaWNoIHdpbGwgZ2V0IHRoZSBPcGVuSUQgY29uZmlndXJhdGlvbiBlbmRwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGFzeW5jIGdldE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludEFzeW5jKCk6IFByb21pc2U8c3RyaW5nPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm0gZW5kcG9pbnQgZGlzY292ZXJ5IHRvIGRpc2NvdmVyIHRoZSAvYXV0aG9yaXplLCAvdG9rZW4gYW5kIGxvZ291dCBlbmRwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyByZXNvbHZlRW5kcG9pbnRzQXN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3Qgb3BlbklkQ29uZmlnRW5kcG9pbnQgPSBhd2FpdCB0aGlzLmdldE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludEFzeW5jKCk7XHJcbiAgICAgICAgdGhpcy50ZW5hbnREaXNjb3ZlcnlSZXNwb25zZSA9IGF3YWl0IHRoaXMuZGlzY292ZXJFbmRwb2ludHMob3BlbklkQ29uZmlnRW5kcG9pbnQpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEF1dGhvcml0eSB0eXBlcyBzdXBwb3J0ZWQgYnkgTVNBTC5cclxuICovXHJcbmV4cG9ydCBlbnVtIEF1dGhvcml0eVR5cGUge1xyXG4gICAgQWFkLFxyXG4gICAgQWRmcyxcclxuICAgIEIyQ1xyXG59XHJcbiIsIi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgeyBBdXRob3JpdHkgfSBmcm9tIFwiLi9BdXRob3JpdHlcIjtcclxuaW1wb3J0IHsgT3BlbklkQ29uZmlnUmVzcG9uc2UgfSBmcm9tIFwiLi9PcGVuSWRDb25maWdSZXNwb25zZVwiO1xyXG5pbXBvcnQgeyBBdXRob3JpdHlUeXBlIH0gZnJvbSBcIi4vQXV0aG9yaXR5VHlwZVwiO1xyXG5pbXBvcnQgeyBBQURUcnVzdGVkSG9zdExpc3QsIENvbnN0YW50cyB9IGZyb20gXCIuLi8uLi91dGlscy9Db25zdGFudHNcIjtcclxuaW1wb3J0IHsgSU5ldHdvcmtNb2R1bGUgfSBmcm9tIFwiLi4vLi4vbmV0d29yay9JTmV0d29ya01vZHVsZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBBYWRBdXRob3JpdHkgY2xhc3MgZXh0ZW5kcyB0aGUgQXV0aG9yaXR5IGNsYXNzIGFuZCBhZGRzIGZ1bmN0aW9uYWxpdHkgc3BlY2lmaWMgdG8gdGhlIEF6dXJlIEFEIE9BdXRoIEF1dGhvcml0eS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBYWRBdXRob3JpdHkgZXh0ZW5kcyBBdXRob3JpdHkge1xyXG4gICAgLy8gU2V0IGF1dGhvcml0eSB0eXBlIHRvIEFBRFxyXG4gICAgcHVibGljIGdldCBhdXRob3JpdHlUeXBlKCk6IEF1dGhvcml0eVR5cGUge1xyXG4gICAgICAgIHJldHVybiBBdXRob3JpdHlUeXBlLkFhZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IEFBRCBJbnN0YW5jZSBEaXNjb3ZlcnkgRW5kcG9pbnRcclxuICAgIHByaXZhdGUgZ2V0IGFhZEluc3RhbmNlRGlzY292ZXJ5RW5kcG9pbnRVcmwoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gYCR7Q29uc3RhbnRzLkFBRF9JTlNUQU5DRV9ESVNDT1ZFUllfRU5EUFR9P2FwaS12ZXJzaW9uPTEuMCZhdXRob3JpemF0aW9uX2VuZHBvaW50PSR7dGhpcy5jYW5vbmljYWxBdXRob3JpdHl9b2F1dGgyL3YyLjAvYXV0aG9yaXplYDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoYXV0aG9yaXR5OiBzdHJpbmcsIG5ldHdvcmtJbnRlcmZhY2U6IElOZXR3b3JrTW9kdWxlKSB7XHJcbiAgICAgICAgc3VwZXIoYXV0aG9yaXR5LCBuZXR3b3JrSW50ZXJmYWNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBPSURDIGVuZHBvaW50XHJcbiAgICAgKiBPbmx5IHJlc3BvbmRzIHdpdGggdGhlIGVuZHBvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRPcGVuSWRDb25maWd1cmF0aW9uRW5kcG9pbnRBc3luYygpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5UcnVzdGVkSG9zdExpc3QodGhpcy5jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZvciBjdXN0b20gZG9tYWlucyBpbiBBQUQgd2hlcmUgd2UgcXVlcnkgdGhlIHNlcnZpY2UgZm9yIHRoZSBJbnN0YW5jZSBkaXNjb3ZlcnlcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubmV0d29ya0ludGVyZmFjZS5zZW5kR2V0UmVxdWVzdEFzeW5jPE9wZW5JZENvbmZpZ1Jlc3BvbnNlPih0aGlzLmFhZEluc3RhbmNlRGlzY292ZXJ5RW5kcG9pbnRVcmwpO1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZW5hbnRfZGlzY292ZXJ5X2VuZHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgaG9zdCBpcyBpbiBhIGxpc3Qgb2YgdHJ1c3RlZCBob3N0c1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBob3N0IHRvIGxvb2sgdXBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc0luVHJ1c3RlZEhvc3RMaXN0KGhvc3Q6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBBQURUcnVzdGVkSG9zdExpc3QuaW5jbHVkZXMoaG9zdCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IEF1dGhvcml0eSB9IGZyb20gXCIuL0F1dGhvcml0eVwiO1xyXG5pbXBvcnQgeyBBYWRBdXRob3JpdHkgfSBmcm9tIFwiLi9BYWRBdXRob3JpdHlcIjtcclxuaW1wb3J0IHsgQXV0aG9yaXR5VHlwZSB9IGZyb20gXCIuL0F1dGhvcml0eVR5cGVcIjtcclxuaW1wb3J0IHsgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvclwiO1xyXG5pbXBvcnQgeyBDbGllbnRBdXRoRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yXCI7XHJcbmltcG9ydCB7IElOZXR3b3JrTW9kdWxlIH0gZnJvbSBcIi4uLy4uL25ldHdvcmsvSU5ldHdvcmtNb2R1bGVcIjtcclxuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSBcIi4uLy4uL3VybC9VcmxTdHJpbmdcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBdXRob3JpdHlGYWN0b3J5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSB1cmwgYW5kIGRldGVybWluZSB0aGUgdHlwZSBvZiBhdXRob3JpdHlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGV0ZWN0QXV0aG9yaXR5RnJvbVVybChhdXRob3JpdHlTdHJpbmc6IHN0cmluZyk6IEF1dGhvcml0eVR5cGUge1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eVVybCA9IG5ldyBVcmxTdHJpbmcoYXV0aG9yaXR5U3RyaW5nKTtcclxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gYXV0aG9yaXR5VXJsLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBjb21wb25lbnRzLlBhdGhTZWdtZW50cztcclxuICAgICAgICBzd2l0Y2ggKHBhdGhTZWdtZW50c1swXSkge1xyXG4gICAgICAgICAgICBjYXNlIFwidGZwXCI6XHJcbiAgICAgICAgICAgICAgICAvLyB0ZnAgZGVub3RlcyBhIGIyYyB1cmxcclxuICAgICAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlUeXBlLkIyQztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgYXV0aG9yaXR5IGlzIGFsd2F5cyBBQURcclxuICAgICAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlUeXBlLkFhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYXV0aG9yaXR5IG9iamVjdCBvZiB0aGUgY29ycmVjdCB0eXBlIGJhc2VkIG9uIHRoZSB1cmxcclxuICAgICAqIFBlcmZvcm1zIGJhc2ljIGF1dGhvcml0eSB2YWxpZGF0aW9uIC0gY2hlY2tzIHRvIHNlZSBpZiB0aGUgYXV0aG9yaXR5IGlzIG9mIGEgdmFsaWQgdHlwZSAoZWcgYWFkLCBiMmMpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYXV0aG9yaXR5VXJsOiBzdHJpbmcsIG5ldHdvcmtJbnRlcmZhY2U6IElOZXR3b3JrTW9kdWxlKTogQXV0aG9yaXR5IHtcclxuICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiBhdXRob3JpdHkgdXJsIGlzIGVtcHR5XHJcbiAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmlzRW1wdHkoYXV0aG9yaXR5VXJsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlVXJsRW1wdHlFcnJvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdHlwZSA9IEF1dGhvcml0eUZhY3RvcnkuZGV0ZWN0QXV0aG9yaXR5RnJvbVVybChhdXRob3JpdHlVcmwpO1xyXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiBhYm92ZSBkZXRlY3Rpb24sIGNyZWF0ZSB0aGUgcmlnaHQgdHlwZS5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBBdXRob3JpdHlUeXBlLkFhZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWFkQXV0aG9yaXR5KGF1dGhvcml0eVVybCwgbmV0d29ya0ludGVyZmFjZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlSW52YWxpZEF1dGhvcml0eVR5cGVFcnJvcihgR2l2ZW4gVXJsOiAke2F1dGhvcml0eVVybH1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmltcG9ydCB7IEF1dGhNb2R1bGUgfSBmcm9tIFwiLi9BdXRoTW9kdWxlXCI7XHJcbmltcG9ydCB7IFB1YmxpY0NsaWVudFNQQUNvbmZpZ3VyYXRpb24sIGJ1aWxkUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9jb25maWcvUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vcmVxdWVzdC9BdXRoZW50aWNhdGlvblBhcmFtZXRlcnNcIjtcclxuaW1wb3J0IHsgVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vcmVxdWVzdC9Ub2tlbkV4Y2hhbmdlUGFyYW1ldGVyc1wiO1xyXG5pbXBvcnQgeyBUb2tlblJlbmV3UGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi9yZXF1ZXN0L1Rva2VuUmVuZXdQYXJhbWV0ZXJzXCI7XHJcbmltcG9ydCB7IFNlcnZlckNvZGVSZXF1ZXN0UGFyYW1ldGVycyB9IGZyb20gXCIuLi8uLi9zZXJ2ZXIvU2VydmVyQ29kZVJlcXVlc3RQYXJhbWV0ZXJzXCI7XHJcbmltcG9ydCB7IFNlcnZlclRva2VuUmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vLi4vc2VydmVyL1NlcnZlclRva2VuUmVxdWVzdFBhcmFtZXRlcnNcIjtcclxuaW1wb3J0IHsgQ29kZVJlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL3Jlc3BvbnNlL0NvZGVSZXNwb25zZVwiO1xyXG5pbXBvcnQgeyBUb2tlblJlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL3Jlc3BvbnNlL1Rva2VuUmVzcG9uc2VcIjtcclxuaW1wb3J0IHsgUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIi4uLy4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlclwiO1xyXG5pbXBvcnQgeyBTZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL3NlcnZlci9TZXJ2ZXJBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlXCI7XHJcbmltcG9ydCB7IFNlcnZlckF1dGhvcml6YXRpb25Ub2tlblJlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL3NlcnZlci9TZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZVwiO1xyXG5pbXBvcnQgeyBDbGllbnRBdXRoRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yXCI7XHJcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gXCIuLi8uLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JcIjtcclxuaW1wb3J0IHsgQWNjZXNzVG9rZW5DYWNoZUl0ZW0gfSBmcm9tIFwiLi4vLi4vY2FjaGUvQWNjZXNzVG9rZW5DYWNoZUl0ZW1cIjtcclxuaW1wb3J0IHsgQXV0aG9yaXR5RmFjdG9yeSB9IGZyb20gXCIuLi8uLi9hdXRoL2F1dGhvcml0eS9BdXRob3JpdHlGYWN0b3J5XCI7XHJcbmltcG9ydCB7IElkVG9rZW4gfSBmcm9tIFwiLi4vLi4vYXV0aC9JZFRva2VuXCI7XHJcbmltcG9ydCB7IFNjb3BlU2V0IH0gZnJvbSBcIi4uLy4uL2F1dGgvU2NvcGVTZXRcIjtcclxuaW1wb3J0IHsgVGVtcG9yYXJ5Q2FjaGVLZXlzLCBQZXJzaXN0ZW50Q2FjaGVLZXlzLCBBQURTZXJ2ZXJQYXJhbUtleXMsIENvbnN0YW50cyB9IGZyb20gXCIuLi8uLi91dGlscy9Db25zdGFudHNcIjtcclxuaW1wb3J0IHsgVGltZVV0aWxzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL1RpbWVVdGlsc1wiO1xyXG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gXCIuLi8uLi91dGlscy9TdHJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgeyBVcmxTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXJsL1VybFN0cmluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIEF1dGhvcml6YXRpb25Db2RlTW9kdWxlIGNsYXNzXHJcbiAqIFxyXG4gKiBPYmplY3QgaW5zdGFuY2Ugd2hpY2ggd2lsbCBjb25zdHJ1Y3QgcmVxdWVzdHMgdG8gc2VuZCB0byBhbmQgaGFuZGxlIHJlc3BvbnNlc1xyXG4gKiBmcm9tIHRoZSBNaWNyb3NvZnQgU1RTIHVzaW5nIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgZmxvdy4gXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvbkNvZGVNb2R1bGUgZXh0ZW5kcyBBdXRoTW9kdWxlIHtcclxuXHJcbiAgICAvLyBBcHBsaWNhdGlvbiBjb25maWdcclxuICAgIHByaXZhdGUgY2xpZW50Q29uZmlnOiBQdWJsaWNDbGllbnRTUEFDb25maWd1cmF0aW9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb246IFB1YmxpY0NsaWVudFNQQUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAvLyBJbXBsZW1lbnQgYmFzZSBtb2R1bGVcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIHN5c3RlbU9wdGlvbnM6IGNvbmZpZ3VyYXRpb24uc3lzdGVtT3B0aW9ucyxcclxuICAgICAgICAgICAgbG9nZ2VyT3B0aW9uczogY29uZmlndXJhdGlvbi5sb2dnZXJPcHRpb25zLFxyXG4gICAgICAgICAgICBzdG9yYWdlSW50ZXJmYWNlOiBjb25maWd1cmF0aW9uLnN0b3JhZ2VJbnRlcmZhY2UsXHJcbiAgICAgICAgICAgIG5ldHdvcmtJbnRlcmZhY2U6IGNvbmZpZ3VyYXRpb24ubmV0d29ya0ludGVyZmFjZSxcclxuICAgICAgICAgICAgY3J5cHRvSW50ZXJmYWNlOiBjb25maWd1cmF0aW9uLmNyeXB0b0ludGVyZmFjZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEltcGxlbWVudCBkZWZhdWx0cyBpbiBjb25maWdcclxuICAgICAgICB0aGlzLmNsaWVudENvbmZpZyA9IGJ1aWxkUHVibGljQ2xpZW50U1BBQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IGF1dGhvcml0eSBpbnN0YW5jZVxyXG4gICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eUluc3RhbmNlID0gQXV0aG9yaXR5RmFjdG9yeS5jcmVhdGVJbnN0YW5jZSh0aGlzLmNsaWVudENvbmZpZy5hdXRoLmF1dGhvcml0eSB8fCBDb25zdGFudHMuREVGQVVMVF9BVVRIT1JJVFksIHRoaXMubmV0d29ya0NsaWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdXJsIGZvciBsb2dnaW5nIGluIGEgdXNlci4gVGhpcyB3aWxsIGJ5IGRlZmF1bHQgYXBwZW5kIHRoZSBjbGllbnQgaWQgdG8gdGhlIGxpc3Qgb2Ygc2NvcGVzLCBcclxuICAgICAqIGFsbG93aW5nIHlvdSB0byByZXRyaWV2ZSBhbiBpZCB0b2tlbiBpbiB0aGUgc3Vic2VxdWVudCBjb2RlIGV4Y2hhbmdlLiBBbHNvIHBlcmZvcm1zIHZhbGlkYXRpb24gb2YgdGhlIHJlcXVlc3QgcGFyYW1ldGVycy5cclxuICAgICAqIEluY2x1ZGluZyBhbnkgU1NPIHBhcmFtZXRlcnMgKGFjY291bnQsIHNpZCwgbG9naW5faGludCkgd2lsbCBzaG9ydCBjaXJjdWl0IHRoZSBhdXRoZW50aWNhdGlvbiBhbmQgYWxsb3cgeW91IHRvIHJldHJpZXZlIGEgY29kZSB3aXRob3V0IGludGVyYWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNyZWF0ZUxvZ2luVXJsKHJlcXVlc3Q6IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJsKHJlcXVlc3QsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHVybCBmb3IgbG9nZ2luZyBpbiBhIHVzZXIuIEFsc28gcGVyZm9ybXMgdmFsaWRhdGlvbiBvZiB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzLlxyXG4gICAgICogSW5jbHVkaW5nIGFueSBTU08gcGFyYW1ldGVycyAoYWNjb3VudCwgc2lkLCBsb2dpbl9oaW50KSB3aWxsIHNob3J0IGNpcmN1aXQgdGhlIGF1dGhlbnRpY2F0aW9uIGFuZCBhbGxvdyB5b3UgdG8gcmV0cmlldmUgYSBjb2RlIHdpdGhvdXQgaW50ZXJhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlQWNxdWlyZVRva2VuVXJsKHJlcXVlc3Q6IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJsKHJlcXVlc3QsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjcmVhdGVzIFVSTC4gSWYgaXNMb2dpbkNhbGwgaXMgdHJ1ZSwgTVNBTCBhcHBlbmRzIGNsaWVudCBpZCBzY29wZSB0byByZXRyaWV2ZSBpZCB0b2tlbiBmcm9tIHRoZSBzZXJ2aWNlLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgXHJcbiAgICAgKiBAcGFyYW0gaXNMb2dpbkNhbGwgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlVXJsKHJlcXVlc3Q6IEF1dGhlbnRpY2F0aW9uUGFyYW1ldGVycywgaXNMb2dpbkNhbGw6IGJvb2xlYW4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXV0aG9yaXR5IG9yIHVzZSBkZWZhdWx0LCBhbmQgcGVyZm9ybSBkaXNjb3ZlcnkgZW5kcG9pbnQgY2hlY2suXHJcbiAgICAgICAgY29uc3QgYWNxdWlyZVRva2VuQXV0aG9yaXR5ID0gKHJlcXVlc3QgJiYgcmVxdWVzdC5hdXRob3JpdHkpID8gQXV0aG9yaXR5RmFjdG9yeS5jcmVhdGVJbnN0YW5jZShyZXF1ZXN0LmF1dGhvcml0eSwgdGhpcy5uZXR3b3JrQ2xpZW50KSA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eUluc3RhbmNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFjcXVpcmVUb2tlbkF1dGhvcml0eS5yZXNvbHZlRW5kcG9pbnRzQXN5bmMoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVFbmRwb2ludERpc2NvdmVyeUluY29tcGxldGVFcnJvcihlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgdmFsaWRhdGUgcmVxdWVzdCBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGxldCByZXF1ZXN0UGFyYW1ldGVyczogU2VydmVyQ29kZVJlcXVlc3RQYXJhbWV0ZXJzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJzID0gbmV3IFNlcnZlckNvZGVSZXF1ZXN0UGFyYW1ldGVycyhcclxuICAgICAgICAgICAgICAgIGFjcXVpcmVUb2tlbkF1dGhvcml0eSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Q29uZmlnLmF1dGguY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBY2NvdW50KCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlZGlyZWN0VXJpKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b09iaixcclxuICAgICAgICAgICAgICAgIGlzTG9naW5DYWxsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgU1NPLlxyXG4gICAgICAgICAgICBsZXQgYWRhbElkVG9rZW46IElkVG9rZW4gPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RQYXJhbWV0ZXJzLmhhc1NTT1BhcmFtKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGFkYWwgdG9rZW4gaWYgbm8gU1NPIHBhcmFtcyBhcmUgYmVpbmcgdXNlZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRhbElkVG9rZW5TdHJpbmcgPSB0aGlzLmNhY2hlU3RvcmFnZS5nZXRJdGVtKFBlcnNpc3RlbnRDYWNoZUtleXMuQURBTF9JRF9UT0tFTik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkoYWRhbElkVG9rZW5TdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRhbElkVG9rZW4gPSBuZXcgSWRUb2tlbihhZGFsSWRUb2tlblN0cmluZywgdGhpcy5jcnlwdG9PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVTdG9yYWdlLnJlbW92ZUl0ZW0oUGVyc2lzdGVudENhY2hlS2V5cy5BREFMX0lEX1RPS0VOKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlcXVpcmVkIGNhY2hlIGVudHJpZXMgZm9yIHJlcXVlc3QuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnVwZGF0ZUNhY2hlRW50cmllcyhyZXF1ZXN0UGFyYW1ldGVycywgcmVxdWVzdC5hY2NvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHF1ZXJ5IHBhcmFtZXRlcnMgKHNpZC9sb2dpbl9oaW50L2RvbWFpbl9oaW50KSBhbmQgYW55IG90aGVyIGV4dHJhUXVlcnlQYXJhbWV0ZXJzIHNldCBieSB0aGUgZGV2ZWxvcGVyLlxyXG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1ldGVycy5wb3B1bGF0ZVF1ZXJ5UGFyYW1zKGFkYWxJZFRva2VuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB1cmwgdG8gbmF2aWdhdGUgdG8uXHJcbiAgICAgICAgICAgIGNvbnN0IHVybE5hdmlnYXRlID0gYXdhaXQgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlTmF2aWdhdGVVcmwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhY2hlIHRva2VuIHJlcXVlc3QuXHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVxdWVzdDogVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZXM6IHJlcXVlc3RQYXJhbWV0ZXJzLnNjb3Blcy5nZXRPcmlnaW5hbFNjb3Blc0FzQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgIHJlc291cmNlOiByZXF1ZXN0LnJlc291cmNlLFxyXG4gICAgICAgICAgICAgICAgY29kZVZlcmlmaWVyOiByZXF1ZXN0UGFyYW1ldGVycy5nZW5lcmF0ZWRQa2NlLnZlcmlmaWVyLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFRdWVyeVBhcmFtZXRlcnM6IHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmF1dGhvcml0eUluc3RhbmNlLmNhbm9uaWNhbEF1dGhvcml0eSxcclxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IHJlcXVlc3RQYXJhbWV0ZXJzLmNvcnJlbGF0aW9uSWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVN0b3JhZ2Uuc2V0SXRlbShUZW1wb3JhcnlDYWNoZUtleXMuUkVRVUVTVF9QQVJBTVMsIHRoaXMuY3J5cHRvT2JqLmJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3QpKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXJsTmF2aWdhdGU7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjYWNoZSBpdGVtcyBiZWZvcmUgcmUtdGhyb3dpbmcuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnJlc2V0VGVtcENhY2hlSXRlbXMocmVxdWVzdFBhcmFtZXRlcnMgJiYgcmVxdWVzdFBhcmFtZXRlcnMuc3RhdGUpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGF1dGhvcml6YXRpb24gY29kZSwgaXQgd2lsbCBwZXJmb3JtIGEgdG9rZW4gZXhjaGFuZ2UgdXNpbmcgY2FjaGVkIHZhbHVlcyBmcm9tIGEgcHJldmlvdXMgY2FsbCB0b1xyXG4gICAgICogY3JlYXRlTG9naW5VcmwoKSBvciBjcmVhdGVBY3F1aXJlVG9rZW5VcmwoKS4gWW91IG11c3QgY2FsbCB0aGlzIEFGVEVSIHVzaW5nIG9uZSBvZiB0aG9zZSBBUElzIGZpcnN0LiBZb3Ugc2hvdWxkXHJcbiAgICAgKiBhbHNvIHVzZSB0aGUgaGFuZGxlRnJhZ21lbnRSZXNwb25zZSgpIEFQSSB0byBwYXNzIHRoZSBjb2RlUmVzcG9uc2UgdG8gdGhpcyBmdW5jdGlvbiBhZnRlcndhcmRzLlxyXG4gICAgICogQHBhcmFtIGNvZGVSZXNwb25zZSBcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuKGNvZGVSZXNwb25zZTogQ29kZVJlc3BvbnNlKTogUHJvbWlzZTxUb2tlblJlc3BvbnNlPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gY29kZSByZXNwb25zZSBpcyBnaXZlbiwgd2UgY2Fubm90IGFjcXVpcmUgYSB0b2tlbi5cclxuICAgICAgICAgICAgaWYgKCFjb2RlUmVzcG9uc2UgfHwgU3RyaW5nVXRpbHMuaXNFbXB0eShjb2RlUmVzcG9uc2UuY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVUb2tlblJlcXVlc3RDYW5ub3RCZU1hZGVFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgcmVxdWVzdCBmcm9tIGNhY2hlXHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVxdWVzdDogVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMgPSB0aGlzLmdldENhY2hlZFJlcXVlc3QoY29kZVJlc3BvbnNlLnVzZXJSZXF1ZXN0U3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdXRob3JpdHkgb3IgdXNlIGRlZmF1bHQsIGFuZCBwZXJmb3JtIGRpc2NvdmVyeSBlbmRwb2ludCBjaGVjay5cclxuICAgICAgICAgICAgY29uc3QgYWNxdWlyZVRva2VuQXV0aG9yaXR5ID0gKHRva2VuUmVxdWVzdCAmJiB0b2tlblJlcXVlc3QuYXV0aG9yaXR5KSA/IEF1dGhvcml0eUZhY3RvcnkuY3JlYXRlSW5zdGFuY2UodG9rZW5SZXF1ZXN0LmF1dGhvcml0eSwgdGhpcy5uZXR3b3JrQ2xpZW50KSA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eUluc3RhbmNlO1xyXG4gICAgICAgICAgICBpZiAoIWFjcXVpcmVUb2tlbkF1dGhvcml0eS5kaXNjb3ZlcnlDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFjcXVpcmVUb2tlbkF1dGhvcml0eS5yZXNvbHZlRW5kcG9pbnRzQXN5bmMoKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlRW5kcG9pbnREaXNjb3ZlcnlJbmNvbXBsZXRlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0b2tlbiBlbmRwb2ludC5cclxuICAgICAgICAgICAgY29uc3QgeyB0b2tlbkVuZHBvaW50IH0gPSBhY3F1aXJlVG9rZW5BdXRob3JpdHk7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgcmVxdWVzdCBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICBjb25zdCB0b2tlblJlcVBhcmFtcyA9IG5ldyBTZXJ2ZXJUb2tlblJlcXVlc3RQYXJhbWV0ZXJzKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRDb25maWcuYXV0aC5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHRva2VuUmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIGNvZGVSZXNwb25zZSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVkaXJlY3RVcmkoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3J5cHRvT2JqXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2VyIGhlbHBlciB0byByZXRyaWV2ZSB0b2tlbiByZXNwb25zZS5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byBhd2FpdCBmdW5jdGlvbiBjYWxsIGJlZm9yZSByZXR1cm4gdG8gY2F0Y2ggYW55IHRocm93biBlcnJvcnMuXHJcbiAgICAgICAgICAgIC8vIGlmIGVycm9ycyBhcmUgdGhyb3duIGFzeW5jaHJvbm91c2x5IGluIHJldHVybiBzdGF0ZW1lbnQsIHRoZXkgYXJlIGNhdWdodCBieSBjYWxsZXIgb2YgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkLlxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRUb2tlblJlc3BvbnNlKHRva2VuRW5kcG9pbnQsIHRva2VuUmVxUGFyYW1zLCB0b2tlblJlcXVlc3QsIGNvZGVSZXNwb25zZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjYWNoZSBpdGVtcyBhbmQgc2V0IGFjY291bnQgdG8gbnVsbCBiZWZvcmUgcmUtdGhyb3dpbmcuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnJlc2V0VGVtcENhY2hlSXRlbXMoY29kZVJlc3BvbnNlICYmIGNvZGVSZXNwb25zZS51c2VyUmVxdWVzdFN0YXRlKTtcclxuICAgICAgICAgICAgdGhpcy5hY2NvdW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSB0b2tlbiBmcm9tIGNhY2hlIGlmIGl0IGlzIHN0aWxsIHZhbGlkLCBvciB1c2VzIHRoZSBjYWNoZWQgcmVmcmVzaCB0b2tlbiB0byByZW5ld1xyXG4gICAgICogdGhlIGdpdmVuIHRva2VuIGFuZCByZXR1cm5zIHRoZSByZW5ld2VkIHRva2VuLiBXaWxsIHRocm93IGFuIGVycm9yIGlmIGxvZ2luIGlzIG5vdCBjb21wbGV0ZWQgKHVubGVzc1xyXG4gICAgICogaWQgdG9rZW5zIGFyZSBub3QgYmVpbmcgcmVuZXdlZCkuXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVuZXdUb2tlbihyZXF1ZXN0OiBUb2tlblJlbmV3UGFyYW1ldGVycyk6IFByb21pc2U8VG9rZW5SZXNwb25zZT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIENhbm5vdCByZW5ldyB0b2tlbiBpZiBubyByZXF1ZXN0IG9iamVjdCBpcyBnaXZlbi5cclxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlRW1wdHlUb2tlblJlcXVlc3RFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgYWNjb3VudCBvYmplY3QgZm9yIHRoaXMgcmVxdWVzdC5cclxuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IHJlcXVlc3QuYWNjb3VudCB8fCB0aGlzLmdldEFjY291bnQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFNjb3BlcyA9IG5ldyBTY29wZVNldChyZXF1ZXN0LnNjb3BlcyB8fCBbXSwgdGhpcy5jbGllbnRDb25maWcuYXV0aC5jbGllbnRJZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gaWQgdG9rZW4gcmVuZXdhbCwgYW5kIG5vIGFjY291bnQgaXMgcHJlc2VudCwgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0U2NvcGVzLmlzTG9naW5TY29wZVNldCgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlVXNlckxvZ2luUmVxdWlyZWRFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGF1dGhvcml0eSBvciB1c2UgZGVmYXVsdCwgYW5kIHBlcmZvcm0gZGlzY292ZXJ5IGVuZHBvaW50IGNoZWNrLlxyXG4gICAgICAgICAgICBjb25zdCBhY3F1aXJlVG9rZW5BdXRob3JpdHkgPSByZXF1ZXN0LmF1dGhvcml0eSA/IEF1dGhvcml0eUZhY3RvcnkuY3JlYXRlSW5zdGFuY2UocmVxdWVzdC5hdXRob3JpdHksIHRoaXMubmV0d29ya0NsaWVudCkgOiB0aGlzLmRlZmF1bHRBdXRob3JpdHlJbnN0YW5jZTtcclxuICAgICAgICAgICAgaWYgKCFhY3F1aXJlVG9rZW5BdXRob3JpdHkuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhY3F1aXJlVG9rZW5BdXRob3JpdHkucmVzb2x2ZUVuZHBvaW50c0FzeW5jKCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZUVuZHBvaW50RGlzY292ZXJ5SW5jb21wbGV0ZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBjYWNoZWQgdG9rZW5zXHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFRva2VuSXRlbSA9IHRoaXMuZ2V0Q2FjaGVkVG9rZW5zKHJlcXVlc3RTY29wZXMsIGFjcXVpcmVUb2tlbkF1dGhvcml0eS5jYW5vbmljYWxBdXRob3JpdHksIHJlcXVlc3QucmVzb3VyY2UsIGFjY291bnQgJiYgYWNjb3VudC5ob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBpcmF0aW9uU2VjID0gTnVtYmVyKGNhY2hlZFRva2VuSXRlbS52YWx1ZS5leHBpcmVzT25TZWMpO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRDdXJyZW50VGltZVNlYyA9IFRpbWVVdGlscy5ub3dTZWNvbmRzKCkgKyB0aGlzLmNsaWVudENvbmZpZy5zeXN0ZW1PcHRpb25zLnRva2VuUmVuZXdhbE9mZnNldFNlY29uZHM7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlZnJlc2ggaXMgZm9yY2VkLCBvciBpZiB0b2tlbnMgYXJlIGV4cGlyZWQuIElmIG5laXRoZXIgYXJlIHRydWUsIHJldHVybiBhIHRva2VuIHJlc3BvbnNlIHdpdGggdGhlIGZvdW5kIHRva2VuIGVudHJ5LlxyXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3QuZm9yY2VSZWZyZXNoICYmIGV4cGlyYXRpb25TZWMgJiYgZXhwaXJhdGlvblNlYyA+IG9mZnNldEN1cnJlbnRUaW1lU2VjKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRTY29wZXMgPSBTY29wZVNldC5mcm9tU3RyaW5nKGNhY2hlZFRva2VuSXRlbS5rZXkuc2NvcGVzLCB0aGlzLmNsaWVudENvbmZpZy5hdXRoLmNsaWVudElkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUb2tlblJlc3BvbnNlOiBUb2tlblJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUlkOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudElkOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlczogY2FjaGVkU2NvcGVzLmFzQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGU6IGNhY2hlZFRva2VuSXRlbS52YWx1ZS50b2tlblR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBpZFRva2VuQ2xhaW1zOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjYWNoZWRUb2tlbkl0ZW0udmFsdWUuYWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiBjYWNoZWRUb2tlbkl0ZW0udmFsdWUucmVmcmVzaFRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNPbjogbmV3IERhdGUoZXhwaXJhdGlvblNlYyAqIDEwMDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlclJlcXVlc3RTdGF0ZTogXCJcIlxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHBvcHVsYXRlIGlkIHRva2VuIGlmIGl0IGV4aXN0cyBpbiBjYWNoZSBpdGVtLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLmlzRW1wdHkoY2FjaGVkVG9rZW5JdGVtLnZhbHVlLmlkVG9rZW4pID8gZGVmYXVsdFRva2VuUmVzcG9uc2UgOiBcclxuICAgICAgICAgICAgICAgICAgICBSZXNwb25zZUhhbmRsZXIuc2V0UmVzcG9uc2VJZFRva2VuKGRlZmF1bHRUb2tlblJlc3BvbnNlLCBuZXcgSWRUb2tlbihjYWNoZWRUb2tlbkl0ZW0udmFsdWUuaWRUb2tlbiwgdGhpcy5jcnlwdG9PYmopKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmV3IHRoZSB0b2tlbnMuXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmF1dGhvcml0eSA9IGNhY2hlZFRva2VuSXRlbS5rZXkuYXV0aG9yaXR5O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbkVuZHBvaW50IH0gPSBhY3F1aXJlVG9rZW5BdXRob3JpdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSByZXF1ZXN0IHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblJlcVBhcmFtcyA9IG5ldyBTZXJ2ZXJUb2tlblJlcXVlc3RQYXJhbWV0ZXJzKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Q29uZmlnLmF1dGguY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UmVkaXJlY3RVcmkoKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b09iaixcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWRUb2tlbkl0ZW0udmFsdWUucmVmcmVzaFRva2VuXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZXIgaGVscGVyIHRvIHJldHJpZXZlIHRva2VuIHJlc3BvbnNlLlxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhd2FpdCBmdW5jdGlvbiBjYWxsIGJlZm9yZSByZXR1cm4gdG8gY2F0Y2ggYW55IHRocm93biBlcnJvcnMuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBlcnJvcnMgYXJlIHRocm93biBhc3luY2hyb25vdXNseSBpbiByZXR1cm4gc3RhdGVtZW50LCB0aGV5IGFyZSBjYXVnaHQgYnkgY2FsbGVyIG9mIHRoaXMgZnVuY3Rpb24gaW5zdGVhZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRva2VuUmVzcG9uc2UodG9rZW5FbmRwb2ludCwgdG9rZW5SZXFQYXJhbXMsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjYWNoZSBpdGVtcyBhbmQgc2V0IGFjY291bnQgdG8gbnVsbCBiZWZvcmUgcmUtdGhyb3dpbmcuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnJlc2V0VGVtcENhY2hlSXRlbXMoKTtcclxuICAgICAgICAgICAgdGhpcy5hY2NvdW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBMb2dvdXRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0byBsb2cgb3V0IHRoZSBjdXJyZW50IHVzZXIsIGFuZCByZWRpcmVjdCB0aGUgdXNlciB0byB0aGUgcG9zdExvZ291dFJlZGlyZWN0VXJpLlxyXG4gICAgICogRGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG8gYHdpbmRvdy5sb2NhdGlvbi5ocmVmYC5cclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlVcmkgXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvZ291dChhdXRob3JpdHlVcmk/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50ID0gdGhpcy5nZXRBY2NvdW50KCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGhvbWVBY2NvdW50SWRlbnRpZmllci4gRG8gbm90IHNlbmQgYW55dGhpbmcgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgICAgICBjb25zdCBob21lQWNjb3VudElkZW50aWZpZXIgPSBjdXJyZW50QWNjb3VudCA/IGN1cnJlbnRBY2NvdW50LmhvbWVBY2NvdW50SWRlbnRpZmllciA6IFwiXCI7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBwZXJ0aW5lbnQgYWNjZXNzIHRva2Vucy5cclxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5yZW1vdmVBbGxBY2Nlc3NUb2tlbnModGhpcy5jbGllbnRDb25maWcuYXV0aC5jbGllbnRJZCwgYXV0aG9yaXR5VXJpLCBcIlwiLCBob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgIC8vIENsZWFyIHJlbWFpbmluZyBjYWNoZSBpdGVtcy5cclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5jbGVhcigpO1xyXG4gICAgICAgIC8vIENsZWFyIGN1cnJlbnQgYWNjb3VudC5cclxuICAgICAgICB0aGlzLmFjY291bnQgPSBudWxsO1xyXG4gICAgICAgIC8vIEdldCBwb3N0TG9nb3V0UmVkaXJlY3RVcmkuXHJcbiAgICAgICAgbGV0IHBvc3RMb2dvdXRSZWRpcmVjdFVyaSA9IFwiXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcG9zdExvZ291dFJlZGlyZWN0VXJpID0gYD8ke0FBRFNlcnZlclBhcmFtS2V5cy5QT1NUX0xPR09VVF9VUkl9PWAgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXRQb3N0TG9nb3V0UmVkaXJlY3RVcmkoKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge31cclxuXHJcbiAgICAgICAgLy8gQWNxdWlyZSB0b2tlbiBhdXRob3JpdGllcy5cclxuICAgICAgICBjb25zdCBhY3F1aXJlVG9rZW5BdXRob3JpdHkgPSAoYXV0aG9yaXR5VXJpKSA/IEF1dGhvcml0eUZhY3RvcnkuY3JlYXRlSW5zdGFuY2UoYXV0aG9yaXR5VXJpLCB0aGlzLm5ldHdvcmtDbGllbnQpIDogdGhpcy5kZWZhdWx0QXV0aG9yaXR5SW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKCFhY3F1aXJlVG9rZW5BdXRob3JpdHkuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWNxdWlyZVRva2VuQXV0aG9yaXR5LnJlc29sdmVFbmRwb2ludHNBc3luYygpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlRW5kcG9pbnREaXNjb3ZlcnlJbmNvbXBsZXRlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnN0cnVjdCBsb2dvdXQgVVJJLlxyXG4gICAgICAgIGNvbnN0IGxvZ291dFVyaSA9IGAke2FjcXVpcmVUb2tlbkF1dGhvcml0eS5lbmRTZXNzaW9uRW5kcG9pbnR9JHtwb3N0TG9nb3V0UmVkaXJlY3RVcml9YDtcclxuICAgICAgICByZXR1cm4gbG9nb3V0VXJpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIFJlc3BvbnNlIEhhbmRsaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSBoYXNoIGZyYWdtZW50IHJlc3BvbnNlIGZyb20gcHVibGljIGNsaWVudCBjb2RlIHJlcXVlc3QuIFJldHVybnMgYSBjb2RlIHJlc3BvbnNlIHVzZWQgYnlcclxuICAgICAqIHRoZSBjbGllbnQgdG8gZXhjaGFuZ2UgZm9yIGEgdG9rZW4gaW4gYWNxdWlyZVRva2VuLlxyXG4gICAgICogQHBhcmFtIGhhc2hGcmFnbWVudCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGhhbmRsZUZyYWdtZW50UmVzcG9uc2UoaGFzaEZyYWdtZW50OiBzdHJpbmcpOiBDb2RlUmVzcG9uc2Uge1xyXG4gICAgICAgIC8vIEhhbmRsZSByZXNwb25zZXMuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gbmV3IFJlc3BvbnNlSGFuZGxlcih0aGlzLmNsaWVudENvbmZpZy5hdXRoLmNsaWVudElkLCB0aGlzLmNhY2hlU3RvcmFnZSwgdGhpcy5jYWNoZU1hbmFnZXIsIHRoaXMuY3J5cHRvT2JqLCB0aGlzLmxvZ2dlcik7XHJcbiAgICAgICAgLy8gRGVzZXJpYWxpemUgaGFzaCBmcmFnbWVudCByZXNwb25zZSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGNvbnN0IGhhc2hVcmxTdHJpbmcgPSBuZXcgVXJsU3RyaW5nKGhhc2hGcmFnbWVudCk7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyUGFyYW1zID0gaGFzaFVybFN0cmluZy5nZXREZXNlcmlhbGl6ZWRIYXNoPFNlcnZlckF1dGhvcml6YXRpb25Db2RlUmVzcG9uc2U+KCk7XHJcbiAgICAgICAgLy8gR2V0IGNvZGUgcmVzcG9uc2VcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2VIYW5kbGVyLmhhbmRsZVNlcnZlckNvZGVSZXNwb25zZShzZXJ2ZXJQYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIEhlbHBlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBjYWNoZSBvZiBpdGVtcyByZWxhdGVkIHRvIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbmNlbFJlcXVlc3QoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkU3RhdGUgPSB0aGlzLmNhY2hlU3RvcmFnZS5nZXRJdGVtKFRlbXBvcmFyeUNhY2hlS2V5cy5SRVFVRVNUX1NUQVRFKTtcclxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5yZXNldFRlbXBDYWNoZUl0ZW1zKGNhY2hlZFN0YXRlIHx8IFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdG9rZW4gZXhjaGFuZ2UgcGFyYW1ldGVycyBmcm9tIHRoZSBjYWNoZS4gVGhyb3dzIGFuIGVycm9yIGlmIG5vdGhpbmcgaXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q2FjaGVkUmVxdWVzdChzdGF0ZTogc3RyaW5nKTogVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0b2tlbiByZXF1ZXN0IGZyb20gY2FjaGUgYW5kIHBhcnNlIGFzIFRva2VuRXhjaGFuZ2VQYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVG9rZW5SZXF1ZXN0ID0gdGhpcy5jYWNoZVN0b3JhZ2UuZ2V0SXRlbShUZW1wb3JhcnlDYWNoZUtleXMuUkVRVUVTVF9QQVJBTVMpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXF1ZXN0ID0gSlNPTi5wYXJzZSh0aGlzLmNyeXB0b09iai5iYXNlNjREZWNvZGUoZW5jb2RlZFRva2VuUmVxdWVzdCkpIGFzIFRva2VuRXhjaGFuZ2VQYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZS5yZW1vdmVJdGVtKFRlbXBvcmFyeUNhY2hlS2V5cy5SRVFVRVNUX1BBUkFNUyk7XHJcbiAgICAgICAgICAgIC8vIEdldCBjYWNoZWQgYXV0aG9yaXR5IGFuZCB1c2UgaWYgbm8gYXV0aG9yaXR5IGlzIGNhY2hlZCB3aXRoIHJlcXVlc3QuXHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdVdGlscy5pc0VtcHR5KHBhcnNlZFJlcXVlc3QuYXV0aG9yaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXR5S2V5OiBzdHJpbmcgPSB0aGlzLmNhY2hlTWFuYWdlci5nZW5lcmF0ZUF1dGhvcml0eUtleShzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpdHk6IHN0cmluZyA9IHRoaXMuY2FjaGVTdG9yYWdlLmdldEl0ZW0oYXV0aG9yaXR5S2V5KTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZFJlcXVlc3QuYXV0aG9yaXR5ID0gY2FjaGVkQXV0aG9yaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXF1ZXN0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlVG9rZW5SZXF1ZXN0Q2FjaGVFcnJvcihlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGNhY2hlZCB0b2tlbnMgYmFzZWQgb24gdGhlIGdpdmVuIGNyaXRlcmlhLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RTY29wZXMgXHJcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5VXJpIFxyXG4gICAgICogQHBhcmFtIHJlc291cmNlSWQgXHJcbiAgICAgKiBAcGFyYW0gaG9tZUFjY291bnRJZGVudGlmaWVyIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENhY2hlZFRva2VucyhyZXF1ZXN0U2NvcGVzOiBTY29wZVNldCwgYXV0aG9yaXR5VXJpOiBzdHJpbmcsIHJlc291cmNlSWQ6IHN0cmluZywgaG9tZUFjY291bnRJZGVudGlmaWVyOiBzdHJpbmcpOiBBY2Nlc3NUb2tlbkNhY2hlSXRlbSB7XHJcbiAgICAgICAgLy8gR2V0IGFsbCBhY2Nlc3MgdG9rZW5zIHdpdGggbWF0Y2hpbmcgYXV0aG9yaXR5LCByZXNvdXJjZSBpZCBhbmQgaG9tZSBhY2NvdW50IElEXHJcbiAgICAgICAgY29uc3QgdG9rZW5DYWNoZUl0ZW1zOiBBcnJheTxBY2Nlc3NUb2tlbkNhY2hlSXRlbT4gPSB0aGlzLmNhY2hlTWFuYWdlci5nZXRBbGxBY2Nlc3NUb2tlbnModGhpcy5jbGllbnRDb25maWcuYXV0aC5jbGllbnRJZCwgYXV0aG9yaXR5VXJpIHx8IFwiXCIsIHJlc291cmNlSWQgfHwgXCJcIiwgaG9tZUFjY291bnRJZGVudGlmaWVyIHx8IFwiXCIpO1xyXG4gICAgICAgIGlmICh0b2tlbkNhY2hlSXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IENsaWVudEF1dGhFcnJvci5jcmVhdGVOb1Rva2Vuc0ZvdW5kRXJyb3IocmVxdWVzdFNjb3Blcy5wcmludFNjb3BlcygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpbHRlciBjYWNoZSBpdGVtcyBiYXNlZCBvbiBhdmFpbGFibGUgc2NvcGVzLlxyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FjaGVJdGVtczogQXJyYXk8QWNjZXNzVG9rZW5DYWNoZUl0ZW0+ID0gdG9rZW5DYWNoZUl0ZW1zLmZpbHRlcihjYWNoZUl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWRTY29wZXMgPSBTY29wZVNldC5mcm9tU3RyaW5nKGNhY2hlSXRlbS5rZXkuc2NvcGVzLCB0aGlzLmNsaWVudENvbmZpZy5hdXRoLmNsaWVudElkLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNjb3Blcy5jb250YWluc1Njb3BlU2V0KHJlcXVlc3RTY29wZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBJZiBjYWNoZSBpdGVtcyBjb250YWlucyB0b28gbWFueSBtYXRjaGluZyB0b2tlbnMsIHRocm93IGVycm9yLlxyXG4gICAgICAgIGlmIChmaWx0ZXJlZENhY2hlSXRlbXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBDbGllbnRBdXRoRXJyb3IuY3JlYXRlTXVsdGlwbGVNYXRjaGluZ1Rva2Vuc0luQ2FjaGVFcnJvcihyZXF1ZXN0U2NvcGVzLnByaW50U2NvcGVzKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyZWRDYWNoZUl0ZW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gc2luZ2xlIGNhY2hlIGl0ZW0uXHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZENhY2hlSXRlbXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGNhY2hlIGl0ZW1zIGFyZSBlbXB0eSwgdGhyb3cgZXJyb3IuXHJcbiAgICAgICAgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZU5vVG9rZW5zRm91bmRFcnJvcihyZXF1ZXN0U2NvcGVzLnByaW50U2NvcGVzKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgYSByZXF1ZXN0IHRvIHRoZSB0b2tlbiBlbmRwb2ludCB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGFuZCBwYXJzZXMgdGhlIHJlc3BvbnNlLlxyXG4gICAgICogQHBhcmFtIHRva2VuRW5kcG9pbnQgXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5SZXFQYXJhbXMgXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5SZXF1ZXN0IFxyXG4gICAgICogQHBhcmFtIGNvZGVSZXNwb25zZSBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRUb2tlblJlc3BvbnNlKHRva2VuRW5kcG9pbnQ6IHN0cmluZywgdG9rZW5SZXFQYXJhbXM6IFNlcnZlclRva2VuUmVxdWVzdFBhcmFtZXRlcnMsIHRva2VuUmVxdWVzdDogVG9rZW5FeGNoYW5nZVBhcmFtZXRlcnMsIGNvZGVSZXNwb25zZT86IENvZGVSZXNwb25zZSk6IFByb21pc2U8VG9rZW5SZXNwb25zZT4ge1xyXG4gICAgICAgIC8vIFBlcmZvcm0gdG9rZW4gcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBhY3F1aXJlZFRva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuc2VuZFBvc3RSZXF1ZXN0QXN5bmM8U2VydmVyQXV0aG9yaXphdGlvblRva2VuUmVzcG9uc2U+KFxyXG4gICAgICAgICAgICB0b2tlbkVuZHBvaW50LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5OiB0b2tlblJlcVBhcmFtcy5jcmVhdGVSZXF1ZXN0Qm9keSgpLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdG9rZW5SZXFQYXJhbXMuY3JlYXRlUmVxdWVzdEhlYWRlcnMoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHJlc3BvbnNlIGhhbmRsZXJcclxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKHRoaXMuY2xpZW50Q29uZmlnLmF1dGguY2xpZW50SWQsIHRoaXMuY2FjaGVTdG9yYWdlLCB0aGlzLmNhY2hlTWFuYWdlciwgdGhpcy5jcnlwdG9PYmosIHRoaXMubG9nZ2VyKTtcclxuICAgICAgICAvLyBWYWxpZGF0ZSByZXNwb25zZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3MgYSBzZXJ2ZXIgZXJyb3IgaWYgYW4gZXJyb3IgaXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cclxuICAgICAgICByZXNwb25zZUhhbmRsZXIudmFsaWRhdGVTZXJ2ZXJBdXRob3JpemF0aW9uVG9rZW5SZXNwb25zZShhY3F1aXJlZFRva2VuUmVzcG9uc2UpO1xyXG4gICAgICAgIC8vIFJldHVybiB0b2tlbiByZXNwb25zZSB3aXRoIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gcmVzcG9uc2VIYW5kbGVyLmNyZWF0ZVRva2VuUmVzcG9uc2UoYWNxdWlyZWRUb2tlblJlc3BvbnNlLCB0b2tlblJlcXVlc3QuYXV0aG9yaXR5LCB0b2tlblJlcXVlc3QucmVzb3VyY2UsIGNvZGVSZXNwb25zZSAmJiBjb2RlUmVzcG9uc2UudXNlclJlcXVlc3RTdGF0ZSk7XHJcbiAgICAgICAgLy8gU2V0IGN1cnJlbnQgYWNjb3VudCB0byByZWNlaXZlZCByZXNwb25zZSBhY2NvdW50LCBpZiBhbnkuXHJcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gdG9rZW5SZXNwb25zZS5hY2NvdW50O1xyXG4gICAgICAgIHJldHVybiB0b2tlblJlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBVc2UgdG8gZ2V0IHRoZSByZWRpcmVjdCB1cmkgY29uZmlndXJlZCBpbiBNU0FMIG9yIG51bGwuXHJcbiAgICAgKiBFdmFsdWF0ZXMgcmVkaXJlY3RVcmkgaWYgaXRzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBzaW1wbHkgcmV0dXJucyBpdHMgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSByZWRpcmVjdCBVUkxcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSZWRpcmVjdFVyaSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLmNsaWVudENvbmZpZy5hdXRoLnJlZGlyZWN0VXJpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnRDb25maWcuYXV0aC5yZWRpcmVjdFVyaSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRDb25maWcuYXV0aC5yZWRpcmVjdFVyaSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFTdHJpbmdVdGlscy5pc0VtcHR5KHRoaXMuY2xpZW50Q29uZmlnLmF1dGgucmVkaXJlY3RVcmkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRDb25maWcuYXV0aC5yZWRpcmVjdFVyaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgdGhyb3cgdW5sZXNzIHdpbmRvdy5sb2NhdGlvbi5ocmVmIGlzIHJldHVybmluZyBlbXB0eS5cclxuICAgICAgICB0aHJvdyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IuY3JlYXRlUmVkaXJlY3RVcmlFbXB0eUVycm9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdG8gZ2V0IHRoZSBwb3N0IGxvZ291dCByZWRpcmVjdCB1cmkgY29uZmlndXJlZCBpbiBNU0FMIG9yIG51bGwuXHJcbiAgICAgKiBFdmFsdWF0ZXMgcG9zdExvZ291dHJlZGlyZWN0VXJpIGlmIGl0cyBhIGZ1bmN0aW9uLCBvdGhlcndpc2Ugc2ltcGx5IHJldHVybnMgaXRzIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBvc3QgbG9nb3V0IHJlZGlyZWN0IFVSTFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UG9zdExvZ291dFJlZGlyZWN0VXJpKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50Q29uZmlnLmF1dGgucG9zdExvZ291dFJlZGlyZWN0VXJpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnRDb25maWcuYXV0aC5wb3N0TG9nb3V0UmVkaXJlY3RVcmkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Q29uZmlnLmF1dGgucG9zdExvZ291dFJlZGlyZWN0VXJpKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHkodGhpcy5jbGllbnRDb25maWcuYXV0aC5wb3N0TG9nb3V0UmVkaXJlY3RVcmkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRDb25maWcuYXV0aC5wb3N0TG9nb3V0UmVkaXJlY3RVcmk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHRocm93IHVubGVzcyB3aW5kb3cubG9jYXRpb24uaHJlZiBpcyByZXR1cm5pbmcgZW1wdHkuXHJcbiAgICAgICAgdGhyb3cgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLmNyZWF0ZVBvc3RMb2dvdXRSZWRpcmVjdFVyaUVtcHR5RXJyb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbn1cclxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQXV0aFJlc3BvbnNlIGJhc2UgdHlwZSByZXR1cm5lZCBieSBNU0FMIGxpYnJhcnkgb24gc3VjY2Vzc1xyXG4gKiAtIHVzZXJSZXF1ZXN0U3RhdGU6IFVzZXIgZ2l2ZW4gc3RhdGVcclxuICovXHJcbmV4cG9ydCB0eXBlIEF1dGhSZXNwb25zZSA9IHtcclxuICAgIHVzZXJSZXF1ZXN0U3RhdGU6IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSByZXNwb25zZSB0aGF0IG9ubHkgc2V0cyBzdGF0ZVxyXG4gKiBAcGFyYW0gcmVzcG9uc2VTdGF0ZSBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJlc3BvbnNlU3RhdGVPbmx5KHJlc3BvbnNlU3RhdGU6IHN0cmluZykgOiBBdXRoUmVzcG9uc2Uge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VyUmVxdWVzdFN0YXRlOiByZXNwb25zZVN0YXRlXHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
