"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeHttpAndTokenManager = exports.TokenManager = void 0;
const axios_1 = __importDefault(require("axios"));
const querystring_1 = __importDefault(require("querystring"));
const jsonwebtoken_1 = require("jsonwebtoken");
class TokenManager {
    constructor(config) {
        this.config = config;
        this.accessToken = '';
        this._refreshToken = '';
        this.reAuthed = false;
        this.retry = 0;
    }
    async getInitializedRefreshToken() {
        if (!this.config.authentication.refreshToken) {
            return null;
        }
        if (!this._refreshToken) {
            await this.authenticate();
        }
        return this._refreshToken;
    }
    async getAccessToken() {
        if (!this.accessToken || this.isTokenExpired()) {
            await this.authenticate();
        }
        return this.accessToken;
    }
    async handleAuthenticationError(err, requestConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const maxRetries = (_b = (_a = this.config.conflict) === null || _a === void 0 ? void 0 : _a.maximumRetries) !== null && _b !== void 0 ? _b : 3;
        const retryAfter = (_d = (_c = this.config.conflict) === null || _c === void 0 ? void 0 : _c.retryOnConflictDelayMs) !== null && _d !== void 0 ? _d : 1000;
        if (((_e = err.response) === null || _e === void 0 ? void 0 : _e.status) === 401 && !this.reAuthed) {
            this.reAuthed = true;
            await this.authenticate();
            requestConfig.headers = requestConfig.headers || {};
            requestConfig.headers.authorization = `Bearer ${this.accessToken}`;
            return (0, axios_1.default)(requestConfig);
        }
        else if (((_f = err.response) === null || _f === void 0 ? void 0 : _f.status) === 409 &&
            ((_h = (_g = this.config) === null || _g === void 0 ? void 0 : _g.conflict) === null || _h === void 0 ? void 0 : _h.retryOnConflict) &&
            this.retry < maxRetries) {
            this.retry++;
            await new Promise((resolve) => setTimeout(resolve, retryAfter));
            return (0, axios_1.default)(requestConfig);
        }
        this.retry = 0;
        this.reAuthed = false;
        throw err;
    }
    async authenticate() {
        let authData = this.prepareAuthData();
        try {
            const res = await axios_1.default.post(`https://login.microsoftonline.com/${this.config.partnerDomain}/oauth2/token`, authData, {
                headers: {
                    'content-type': 'application/x-www-form-urlencoded',
                },
            });
            const body = res.data;
            this.accessToken = body.access_token;
            if (body.refresh_token) {
                this.config.authentication.refreshToken = body.refresh_token;
                this._refreshToken = body.refresh_token;
            }
        }
        catch (error) {
            throw new Error('Failed to authenticate with the Microsoft Partner Center.');
        }
    }
    prepareAuthData() {
        if (this.config.authentication.refreshToken) {
            return querystring_1.default.stringify({
                grant_type: 'refresh_token',
                refresh_token: this.config.authentication.refreshToken,
                client_id: this.config.authentication.clientId,
                client_secret: this.config.authentication.clientSecret,
                scope: 'https://api.partnercenter.microsoft.com/.default',
            });
        }
        return querystring_1.default.stringify({
            grant_type: 'client_credentials',
            resource: 'https://graph.windows.net',
            client_id: this.config.authentication.clientId,
            client_secret: this.config.authentication.clientSecret,
        });
    }
    isTokenExpired() {
        if (!this.accessToken) {
            return true; // If there's no token, it's considered expired
        }
        try {
            const decodedToken = (0, jsonwebtoken_1.decode)(this.accessToken) || null;
            if (!decodedToken || !decodedToken.exp) {
                return true;
            }
            const currentUnixTime = Math.floor(Date.now() / 1000);
            // Check if the token has expired
            return decodedToken.exp < currentUnixTime;
        }
        catch (error) {
            return true;
        }
    }
}
exports.TokenManager = TokenManager;
function initializeHttpAndTokenManager(config) {
    const baseURL = 'https://api.partnercenter.microsoft.com/v1/';
    const tokenManager = new TokenManager(config);
    const agent = axios_1.default.create({ baseURL, timeout: config.timeoutMs });
    agent.interceptors.request.use(async (req) => {
        req.headers.authorization = `Bearer ${await tokenManager.getAccessToken()}`;
        return req;
    });
    agent.interceptors.response.use((res) => res, async (err) => tokenManager.handleAuthenticationError(err, err.config));
    return {
        agent,
        tokenManager,
    };
}
exports.initializeHttpAndTokenManager = initializeHttpAndTokenManager;
