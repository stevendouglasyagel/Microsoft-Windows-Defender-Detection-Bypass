"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_token_manager_1 = require("./http-token-manager");
const jest_mock_axios_1 = __importDefault(require("jest-mock-axios"));
const axios_1 = __importDefault(require("axios"));
const jsonwebtoken_1 = require("jsonwebtoken");
jest.mock('axios', () => {
    return {
        create: () => {
            return {
                post: jest.fn(),
                get: jest.fn(),
                interceptors: {
                    request: { eject: jest.fn(), use: jest.fn() },
                    response: { eject: jest.fn(), use: jest.fn() },
                },
            };
        },
        post: jest.fn(),
        get: jest.fn(),
    };
});
jest.mock('jsonwebtoken', () => ({
    ...jest.requireActual('jsonwebtoken'),
    decode: jest.fn(),
}));
describe('HttpAgent', () => {
    let instance;
    let tokenManager;
    const conf = {
        partnerDomain: 'test',
        authentication: {
            clientId: 'test',
            clientSecret: 'test',
        },
    };
    beforeEach(() => {
        jest.resetAllMocks();
        const { agent, tokenManager: _tokenManager } = (0, http_token_manager_1.initializeHttpAndTokenManager)(conf);
        instance = agent;
        tokenManager = _tokenManager;
        jest.spyOn(jest_mock_axios_1.default, 'create');
    });
    it('creates an axios instance', () => {
        expect(instance).toBeTruthy();
    });
    it('should authenticate and set a new token', async () => {
        jest.spyOn(axios_1.default, 'post').mockResolvedValue({
            data: {
                access_token: 'newAccessToken',
                refresh_token: 'newRefreshToken',
            },
        });
        await tokenManager.getAccessToken();
        expect(tokenManager.getAccessToken()).resolves.toBe('newAccessToken');
    });
    it('should re-auth when token is expired', async () => {
        tokenManager.accessToken = 'invalidToken';
        jsonwebtoken_1.decode.mockImplementation((token) => {
            if (token === 'validToken') {
                return { userId: '123', exp: Date.now() / 1000 + 3600 };
            }
            return {
                userId: '123',
                exp: Date.now() / 1000 - 3600,
            };
        });
        jest.spyOn(axios_1.default, 'post').mockResolvedValue({
            data: {
                access_token: 'validAccessToken',
                refresh_token: 'newRefreshToken',
            },
        });
        await tokenManager.getAccessToken();
        expect(tokenManager.getAccessToken()).resolves.toBe('validAccessToken');
    });
});
